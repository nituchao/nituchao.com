<!DOCTYPE html>

<html lang="en">
	<head>
		<meta charset="utf-8">
		<meta name="viewport" content="width=device-width, initial-scale=1">
		<link rel="alternate" href="/index.xml" type="application/rss+xml" title="泥土巢">
		<link rel="icon" href="http://nituchao.com/favicon.ico">
		<title>AtomicIntegerFieldUpdater源码分析 - 泥土巢</title>
		
		<link rel="stylesheet" href="http://nituchao.com/css/highlight/atelier-estuary-dark.css">
		<link rel="stylesheet" href="http://nituchao.com/css/bootstrap.min.css">
		<link rel="stylesheet" href="http://nituchao.com/css/bootstrap-theme.min.css">
		<link rel="stylesheet" href="http://nituchao.com/css/theme.css">
		<link rel="stylesheet" href="http://nituchao.com/css/bootie-docs.css">
	</head>

<body role="document">

	
	<nav class="navbar navbar-inverse navbar-fixed-top">
		<div class="container">
			<div class="navbar-header">
				<button type="button" class="navbar-toggle collapsed" data-toggle="collapse" data-target="#navbar" aria-expanded="false" aria-controls="navbar">
					<span class="sr-only">Toggle navigation</span>
					<span class="icon-bar"></span>
					<span class="icon-bar"></span>
					<span class="icon-bar"></span>
				</button>
				<a class="navbar-brand" href="http://nituchao.com/">泥土巢</a>
			</div>
			<div id="navbar" class="navbar-collapse collapse">
				<ul class="nav navbar-nav">
					<li ><a href="http://nituchao.com/">主页</a></li>
			
			
				
					
					<li ><a href="http://nituchao.com/post">文章</a></li>
				
					
					<li ><a href="http://nituchao.com/kk">作品</a></li>
				
					
					<li ><a href="http://nituchao.com/book">书单</a></li>
				
					
					<li ><a href="http://nituchao.com/device">设备</a></li>
				
					
					<li ><a href="http://nituchao.com/te">经济学人</a></li>
				
					
					<li ><a href="http://nituchao.com/about">关于</a></li>
				
			
				
					<li class="dropdown">
						<a href="#" class="dropdown-toggle" data-toggle="dropdown" role="button" aria-expanded="false">文章分类<span class="caret"></span></a>
						<ul class="dropdown-menu" role="menu">
						
							<li><a href="http://nituchao.com/categories/abc_atomic">Abc_atomic</a></li>
						
							<li><a href="http://nituchao.com/categories/abc_concurrent">Abc_concurrent</a></li>
						
							<li><a href="http://nituchao.com/categories/abc_lock">Abc_lock</a></li>
						
							<li><a href="http://nituchao.com/categories/amqp">Amqp</a></li>
						
							<li><a href="http://nituchao.com/categories/console">Console</a></li>
						
							<li><a href="http://nituchao.com/categories/daily">Daily</a></li>
						
							<li><a href="http://nituchao.com/categories/java">Java</a></li>
						
							<li><a href="http://nituchao.com/categories/jvm">Jvm</a></li>
						
							<li><a href="http://nituchao.com/categories/linux">Linux</a></li>
						
							<li><a href="http://nituchao.com/categories/macos">Macos</a></li>
						
							<li><a href="http://nituchao.com/categories/mysql">Mysql</a></li>
						
							<li><a href="http://nituchao.com/categories/queue">Queue</a></li>
						
							<li><a href="http://nituchao.com/categories/words">Words</a></li>
						
							<li><a href="http://nituchao.com/categories/xa">Xa</a></li>
						
						</ul>
					</li>
				
				</ul>
				
			</div>
		</div>
	</nav>

<div class="container">


<div class="row">
	<div class="col-sm-8 doc-main">
		<main role="main">
			<article>
				<a id="title"></a>
				<h1 class="doc-entry-title">AtomicIntegerFieldUpdater源码分析</h1>
				<div class="doc-entry-meta">
					<span><time datetime="2017-02-23">2017年02月23日</time></span>
				</div>
				<section>
					

<h2 id="概述">概述</h2>

<p>在原子变量相关类中，<code>AtomicIntegerFieldUpdater</code>, <code>AtomicLongFieldUpdater</code>, <code>AtomicReferenceFieldUpdater</code>三个类是用于原子地修改对象的成员属性，它们的原理和用法类似，区别在于对Integer，Long，Reference类型的成员属性进行修改。本文重点研究<code>AtomicIntegerFieldUpdater</code>。</p>

<p>AtomicIntegerFieldUpdater的设计非常有意思。AtomicIntegerFieldUpdater本身是一个抽象类，只有一个受保护的构造函数，它本身不能被实例化。在AtomicIntegerFieldUpdater中定义了一些基本的模板方法，然后通过一个静态内部子类AtomicIntegerFieldUpdaterImpl来实现具体的操作。AtomicIntegerFieldUpdaterImpl中的相关操作也都是基于Unsafe类来实现的。</p>

<p>本文基于JDK1.7.0_67</p>

<blockquote>
<p>java version &ldquo;1.7.0_67&rdquo;</p>

<p>_Java™ SE Runtime Environment (build 1.7.0_67-b01)</p>

<p>Java HotSpot™ 64-Bit Server VM (build 24.65-b04, mixed mode)</p>
</blockquote>

<h2 id="内部类">内部类</h2>

<p>AtomicIntegerFieldUpdater本身是一个抽象类，通过一个静态内部子类来实现相关的操作。</p>

<pre><code class="language-java">private static class AtomicIntegerFieldUpdaterImpl&lt;T&gt; extends AtomicIntegerFieldUpdater&lt;T&gt;
</code></pre>

<h3 id="成员变量">成员变量</h3>

<p><code>AtomicIntegerFieldUpdater</code>是个抽象类，具体的业务逻辑都是交给它的子类实现的，它本身没有包含任何成员变量。</p>

<h2 id="函数列表">函数列表</h2>

<pre><code class="language-java">// 受保护的无操作构造函数，供子类使用
protected AtomicIntegerFieldUpdater()
// 为对象创建并返回一个具有给定字段的更新器。
public static &lt;U&gt; AtomicIntegerFieldUpdater&lt;U&gt; newUpdater(Class&lt;U&gt; tclass, String fieldName)
// 以原子方式设置当前值为update
// 如果当前值等于expect，并设置成功，返回true
// 如果当前值不等于expect，则设置失败，返回false
// 该过程通过CAS实现，不阻塞
public abstract boolean compareAndSet(T obj, int expect, int update)
// 以原子方式设置当前值为update
// 如果当前值等于expect，并设置成功，返回true
// 如果当前值不等于expect，则设置失败，返回false
// 该过程通过CAS实现，不阻塞
// 该过程不保证volatile成员的happens-before语义顺序
public abstract boolean weakCompareAndSet(T obj, int expect, int update)
// 以原子方式设置当前值为newValue
// 使用Unsafe类的putIntVolatile进行操作，具有原子性
public abstract void set(T obj, int newValue)
// 以原子方式设置当前值为newValue
// 使用Unsafe类的putOrderedInt进行操作，所以本身具有原子性
public abstract void lazySet(T obj, int newValue)
// 以原子方式获取当前值
// 使用Unsafe类的getIntVolatile进行操作，所以本身具有原子性
public abstract int get(T obj)
// 以原子方式设置当前值为newValue，并返回更新前的值
// 使用Unsafe类的compareAndSwapInt进行操作，所以本身具有原子性
// 操作过程中使用自旋方式，直到操作成功
public int getAndSet(T obj, int newValue)
// 以原子方式将当前值加1，并返回更新前的值
// 使用Unsafe类的compareAndSwapInt进行操作，所以本身具有原子性
// 操作过程中使用自旋方式，直到操作成功
public int getAndIncrement(T obj)
// 以原子方式将当前值减1，并返回更新前的值
// 使用Unsafe类的compareAndSwapInt进行操作，所以本身具有原子性
// 操作过程中使用自旋方式，直到操作成功
public int getAndDecrement(T obj)
// 以原子方式将当前值加上给定值delta，并返回更新前的值
// 使用Unsafe类的compareAndSwapInt进行操作，所以本身具有原子性
// 操作过程中使用自旋方式，直到操作成功
public int getAndAdd(T obj, int delta)
// 以原子方式将当前值加1，并返回更新后的值
// 使用Unsafe类的compareAndSwapInt进行操作，所以本身具有原子性
// 操作过程中使用自旋方式，直到操作成功
public int incrementAndGet(T obj)
// 以原子方式将当前值减1，并返回更新前的值
// 使用Unsafe类的compareAndSwapInt进行操作，所以本身具有原子性
// 操作过程中使用自旋方式，直到操作成功
public int decrementAndGet(T obj)
// 以原子方式将当前值加上给定值delta，并返回更新后的值
// 使用Unsafe类的compareAndSwapInt进行操作，所以本身具有原子性
// 操作过程中使用自旋方式，直到操作成功
public int addAndGet(T obj, int delta)
</code></pre>

<h2 id="重点函数分析">重点函数分析</h2>

<h3 id="newupdater">newUpdater</h3>

<p>为对象创建并返回一个具有给定字段的更新器实例。在该方法中，直接构造一个AtomicIntegerFieldUpdaterImpl实例。</p>

<pre><code class="language-java">public static &lt;U&gt; AtomicIntegerFieldUpdater&lt;U&gt; newUpdater(Class&lt;U&gt; tclass, String fieldName) {
        return new AtomicIntegerFieldUpdaterImpl&lt;U&gt;(tclass, fieldName, Reflection.getCallerClass());
    }
</code></pre>

<h3 id="atomicintegerfieldupdater">AtomicIntegerFieldUpdater</h3>

<p>受保护的无操作构造函数，供子类实现。AtomicIntegerFieldUpdaterImpl是唯一的子类，我们来看一下他是怎么实现的。在构造函数中，首先获取要更新的类(tclass)的指定成员变量fieldName的访问策略(Modifier: public, private, default, protected)，然后检查调用类(caller)是否有权限访问该成员变量fieldName，如果没有权限则抛出异常。接下来，判断指定的成员变量fieldName的类型是否是long，如果不是，也抛出异常。接下来，判断当前指定的成员变量是否是volatile类型的，如果不是，也抛出异常。接下来，实例化调用者类cclass，和操作目标类tclass。最后，计算指定成员变量fieldName的内存偏移值。</p>

<pre><code class="language-java">// 成员变量unsafe是原子变量相关操作的基础
// 原子变量的修改操作最终有sun.misc.Unsafe类的CAS操作实现
private static final Unsafe unsafe = Unsafe.getUnsafe();
// 成员变量fieldName的内存偏移值，在构造函数中初始化
private final long offset;
// 操作目标类，对该类中的fieldName字段进行更新
private final Class&lt;T&gt; tclass;
// 调用者类，通过反射获取
private final Class cclass;

AtomicIntegerFieldUpdaterImpl(Class&lt;T&gt; tclass, String fieldName, Class&lt;?&gt; caller) {
  	Field field = null;
  	int modifiers = 0;
    try {
      	// 获取要更新的类的指定成员变量fieldName的访问策略
        field = tclass.getDeclaredField(fieldName);
        modifiers = field.getModifiers();
      	// 验证访问策略
        sun.reflect.misc.ReflectUtil.ensureMemberAccess(
          caller, tclass, null, modifiers);
        sun.reflect.misc.ReflectUtil.checkPackageAccess(tclass);
    } catch (Exception ex) {
      	throw new RuntimeException(ex);
    }

  	// 当前成员变量的类型必须是int
    Class fieldt = field.getType();
    if (fieldt != int.class)
      	throw new IllegalArgumentException(&quot;Must be integer type&quot;);

  	// 当前成员变量必须是volatile修饰
    if (!Modifier.isVolatile(modifiers))
      	throw new IllegalArgumentException(&quot;Must be volatile type&quot;);
	// 设置调用者类
    this.cclass = (Modifier.isProtected(modifiers) &amp;&amp;
                   caller != tclass) ? caller : null;
    // 设置目标操作类
  	this.tclass = tclass;
	// 设置成员变量的内存偏移值
    offset = unsafe.objectFieldOffset(field);
}
</code></pre>

<h3 id="weakcompareandset">weakCompareAndSet</h3>

<p>以原子方式设置当前值为update。如果当前值等于expect，并设置成功，返回true。如果当前值不等于expect，则设置失败，返回false。</p>

<p>weakCompareAndSet的实现与compareAndSet完全相同，但是，在JDK文档中声明，weakCompareAndSet不保证volatile的happens-before内存顺序性语义，这是它们的区别。</p>

<p>在<code>AtomicIntegerFieldUpdater</code>类中，这是一个抽象方法。具体的实现在子类AtomicIntegerFieldUpdaterImpl提供。</p>

<pre><code class="language-java">public abstract boolean weakCompareAndSet(T obj, int expect, int update);
</code></pre>

<p>AtomicIntegerFieldUpdaterImpl中weakCompareAndSet方法的实现如下：</p>

<pre><code class="language-java">public boolean weakCompareAndSet(T obj, int expect, int update) {
	if (obj == null || obj.getClass() != tclass || cclass != null) fullCheck(obj);
	return unsafe.compareAndSwapInt(obj, offset, expect, update);
}
</code></pre>

<h3 id="compareandset">compareAndSet</h3>

<p>以原子方式设置当前值为update。如果当前值等于expect，并设置成功，返回true。如果当前值不等于expect，则设置失败，返回false。</p>

<p>在<code>AtomicIntegerFieldUpdater</code>类中，这是一个抽象方法。具体的实现在子类AtomicIntegerFieldUpdaterImpl提供。</p>

<pre><code class="language-java">public abstract boolean compareAndSet(T obj, int expect, int update);
</code></pre>

<p>AtomicIntegerFieldUpdaterImpl中的compareAndSet方法的实现如下：</p>

<pre><code class="language-java">public boolean compareAndSet(T obj, int expect, int update) {
	if (obj == null || obj.getClass() != tclass || cclass != null) fullCheck(obj);
	return unsafe.compareAndSwapInt(obj, offset, expect, update);
}

private void fullCheck(T obj) {
    if (!tclass.isInstance(obj))
      	throw new ClassCastException();
    if (cclass != null)
      	ensureProtectedAccess(obj);
}

private void ensureProtectedAccess(T obj) {
    if (cclass.isInstance(obj)) {
      	return;
    }
    throw new RuntimeException(
      	new IllegalAccessException(&quot;Class &quot; +
            cclass.getName() +
            &quot; can not access a protected member of class &quot; +
            tclass.getName() +
            &quot; using an instance of &quot; +
            obj.getClass().getName()
            )
    );
}
</code></pre>

<h3 id="get">get</h3>

<p>以原子方式获取当前值。通过Unsafe的getIntVolatile保证原则性。</p>

<p>在<code>AtomicIntegerFieldUpdater</code>类中，这是一个抽象方法。具体的实现在子类AtomicIntegerFieldUpdaterImpl提供。</p>

<pre><code class="language-java">public abstract int get(T obj);
</code></pre>

<p>AtomicIntegerFieldUpdaterImpl中的get方法的实现如下：</p>

<pre><code class="language-java">public final int get(T obj) {
	if (obj == null || obj.getClass() != tclass || cclass != null) fullCheck(obj);
	return unsafe.getIntVolatile(obj, offset);
}
</code></pre>

<h3 id="set">set</h3>

<p>以原子方式设置当前值为newValue。通过Unsafe的putIntVolatile保证原子性。</p>

<p>在<code>AtomicIntegerFieldUpdater</code>类中，这是一个抽象方法。具体的实现在子类AtomicIntegerFieldUpdaterImpl提供。</p>

<pre><code class="language-java">public abstract void set(T obj, int newValue);
</code></pre>

<p>AtomicIntegerFieldUpdaterImpl中的set方法的实现如下。</p>

<pre><code class="language-java">public void set(T obj, int newValue) {
	if (obj == null || obj.getClass() != tclass || cclass != null) fullCheck(obj);
	unsafe.putIntVolatile(obj, offset, newValue);
}
</code></pre>

<h3 id="lazyset">lazySet</h3>

<p>以原子方式设置当前值为newValue。与set方法的区别在于使用Unsafe类的putOreredInt保证原子性，同时该方法优先保证数据的更新，而不保证可见性，效率高。</p>

<p>在<code>AtomicIntegerFieldUpdater</code>类中，这是一个抽象方法。具体的实现在子类AtomicIntegerFieldUpdaterImpl提供。</p>

<pre><code class="language-java">public abstract void lazySet(T obj, int newValue);
</code></pre>

<p>AtomicIntegerFieldUpdaterImpl中的lazySet方法的实现如下：</p>

<pre><code class="language-java">public void lazySet(T obj, int newValue) {
  	if (obj == null || obj.getClass() != tclass || cclass != null) fullCheck(obj);
  	unsafe.putOrderedInt(obj, offset, newValue);
}
</code></pre>

<h3 id="getandset">getAndSet</h3>

<p>以原子方式将当前值更新为newValue，并返回更新前的值。</p>

<p>在<code>AtomicIntegerFieldUpdater</code>类中，这是一个模板方法。该方法通过自旋的方式循环调用compareAndSet方法，直到操作成功。</p>

<pre><code class="language-java">public int getAndSet(T obj, int newValue) {
  for (;;) {
    int current = get(obj);
    if (compareAndSet(obj, current, newValue))
    	return current;
  }
}
</code></pre>

<p>类似的方法还有如下几个，它们的实现大同小异，不在一一列举：</p>

<pre><code class="language-java">public int getAndSet(T obj, int newValue)
public int getAndIncrement(T obj)
public int getAndDecrement(T obj)
public int getAndAdd(T obj, int delta)
public int incrementAndGet(T obj)
public int decrementAndGet(T obj)
public int addAndGet(T obj, int delta)
</code></pre>

				</section>
			</article>
		</main>
	</div> 

	

<div class="col-sm-3 col-sm-offset-1 doc-sidebar">
	<div id="sidebar">
	<div class="sidebar-module">
		<div class="sidebar-toc">
			<h4 class="sidebar-heading">本文导航</h4>
			<ul>
				<li><strong><a href="#title">AtomicIntegerFieldUpdater源码分析</a></strong></li>
			</ul>
			<nav id="TableOfContents">
<ul>
<li>
<ul>
<li><a href="#概述">概述</a></li>
<li><a href="#内部类">内部类</a>
<ul>
<li><a href="#成员变量">成员变量</a></li>
</ul></li>
<li><a href="#函数列表">函数列表</a></li>
<li><a href="#重点函数分析">重点函数分析</a>
<ul>
<li><a href="#newupdater">newUpdater</a></li>
<li><a href="#atomicintegerfieldupdater">AtomicIntegerFieldUpdater</a></li>
<li><a href="#weakcompareandset">weakCompareAndSet</a></li>
<li><a href="#compareandset">compareAndSet</a></li>
<li><a href="#get">get</a></li>
<li><a href="#set">set</a></li>
<li><a href="#lazyset">lazySet</a></li>
<li><a href="#getandset">getAndSet</a></li>
</ul></li>
</ul></li>
</ul>
</nav>
		</div>
	</div>
	</div>
</div>


</div> 


<hr />

<div class="row">
	<div class="col-sm-8">
		  <p class="doc-footer-em"><a href="#" onclick="resetSidebarPos()">返回顶部</a></p>
	</div>
</div>

</div> 

<footer class="doc-footer">
	<p>Copyright (c) 2017, nituchao | All rights reserved.</p>
	<p>Powered by <strong><a href="https://github.com/key-amb/hugo-theme-bootie-docs">Bootie Docs</a></strong> - theme for <a href="http://gohugo.io/">Hugo</a> by <a href="https://github.com/key-amb/">key-amb</a>.</p>
</footer>



<script src="http://nituchao.com/js/jquery.min.js"></script>
<script src="http://nituchao.com/js/bootstrap.min.js"></script>

<script src="http://nituchao.com/js/highlight.pack.js"></script>
<script>hljs.initHighlightingOnLoad();</script>
<script src="http://nituchao.com/js/ie10-viewport-bug-workaround.js"></script>
<script src="http://nituchao.com/js/bootie-docs.js"></script>

</body>
</html>


