<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Posts on 泥土巢</title>
    <link>http://nituchao.com/post/index.xml</link>
    <description>Recent content in Posts on 泥土巢</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh-CN</language>
    <copyright>Copyright (c) 2017, nituchao | All rights reserved.</copyright>
    <lastBuildDate>Mon, 06 Mar 2017 09:34:07 +0800</lastBuildDate>
    <atom:link href="http://nituchao.com/post/index.xml" rel="self" type="application/rss+xml" />
    
    <item>
      <title>YourKit远程连接线上服务器</title>
      <link>http://nituchao.com/post/2017/your-kit-yuan-cheng-lian-jie-xian-shang-fu-wu/</link>
      <pubDate>Mon, 06 Mar 2017 09:34:07 +0800</pubDate>
      
      <guid>http://nituchao.com/post/2017/your-kit-yuan-cheng-lian-jie-xian-shang-fu-wu/</guid>
      <description>

&lt;p&gt;YourKit是一款业内领先的性能分析工具，目前支持Java和.NET两个平台。该工具功能全面强悍，能通过本地连接或者远程连接的方式，对各种服务器，框架，平台的性能进行分析，并提供了多种由浅入深，针对开发环境或者生产环境的分析模式。该工具提供了高效的图形化显示方式，动动鼠标就可以对系统进行显微镜式的观察分析。&lt;/p&gt;

&lt;p&gt;通过YourKit可以对以下内容进行分析：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;CPU profiling - investigate performace issues&lt;/li&gt;
&lt;li&gt;Memory profiling - memory leaks, usage, GC&lt;/li&gt;
&lt;li&gt;Threads and synchronization&lt;/li&gt;
&lt;li&gt;Exception profiling&lt;/li&gt;
&lt;li&gt;Web, Database, I/O&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;本文想总结一下，YourKit提供的两种连接到Java进程的方式，一种是attach方式，另一种是integrate方式。&lt;/p&gt;

&lt;h2 id=&#34;通过attach方式连接到远程服务器&#34;&gt;通过attach方式连接到远程服务器&lt;/h2&gt;

&lt;p&gt;在控制台，attach方式可以通过进程号，连接到运行中的任何Java进程中，这种方式并不保证总能连接成功，而且会禁用某些分析功能。&lt;/p&gt;

&lt;h4 id=&#34;线上环境&#34;&gt;线上环境&lt;/h4&gt;

&lt;ul&gt;
&lt;li&gt;CentOS release 6.3 64-Bit&lt;/li&gt;
&lt;li&gt;Java 1.7.0_79 HotSpot&amp;trade; 64-Bit Server VM&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&#34;下载安装包&#34;&gt;下载安装包&lt;/h4&gt;

&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;# wget https://www.yourkit.com/download/yjp-2017.02-b53.zip
# unzip yjp-2017.02-b53.zip
# cd yjp-2017.02
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;确定服务进程号&#34;&gt;确定服务进程号&lt;/h4&gt;

&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;# jps
2230 Resin
3959 Jps
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;console连接进程&#34;&gt;Console连接进程&lt;/h4&gt;

&lt;p&gt;通过下面的命令来连接到Java进程。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;# bin/yjp.sh -attach
[YourKit Java Profiler 2017.02-b53] Log file: /root/.yjp/log/yjp-4473.log
Running JVMs:

Name                             |   PID| Status
-------------------------------- |------|--------------------------------
Resin                            | 11760| Ready for attach
ThriftMain                       |  2934| Ready for attach
Resin                            |  2230| Agent already loaded, agent port is 10001
Resin                            | 14232| Ready for attach
Resin                            |  3657| Ready for attach
WatchdogManager                  | 16411| Ready for attach

Enter PID of the application you want to attach (0 to exit) and press Enter:
&amp;gt;2230
Please specify comma-separated list of startup options, or press Enter for default options (recommended):
&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;上面的操作执行完成后，会出现如下提示，表示YourKit Console服务已经成功运行，并在10001开始工作。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;Attaching to process 2230 using default options
[YourKit Java Profiler 2017.02-b53] Log file: /root/.yjp/log/yjp-30209.log
The profiler agent has attached. Waiting while it initializes...
The agent is loaded and is listening on port 10001.
You can connect to it from the profiler UI.
# lsof -i:10001
COMMAND  PID USER   FD   TYPE    DEVICE SIZE/OFF NODE NAME
java    2230 root   72u  IPv4 199000044      0t0  TCP *:scp-config (LISTEN)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;在浏览器，通过ip:port的方式，可以看到YourKit的运行概况。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://olno3yiqc.bkt.clouddn.com/blog/img/your-kit-attach.png&#34; alt=&#34;YourKit Attach&#34; /&gt;&lt;/p&gt;

&lt;h4 id=&#34;yourkit-ui连接远程服务&#34;&gt;YourKit UI连接远程服务&lt;/h4&gt;

&lt;p&gt;打开YourKit UI，点击Connect to remote application，输入IP:PORT进行连接。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://olno3yiqc.bkt.clouddn.com/blog/img/yourkit-connect-attach.png&#34; alt=&#34;YourKit Connect&#34; /&gt;&lt;/p&gt;

&lt;p&gt;连接成功后，进行性能分析界面，大功告成。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://olno3yiqc.bkt.clouddn.com/blog/img/yourkit-home-attach.png&#34; alt=&#34;YourKit性能分析界面&#34; /&gt;&lt;/p&gt;

&lt;h4 id=&#34;疑难问题&#34;&gt;疑难问题&lt;/h4&gt;

&lt;p&gt;通过attach方式并不总能连接到Java进程，常常会出现JVM无响应的问题，控制台报错如下：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;Attaching to process 31833 using options
com.yourkit.util.bf: com.sun.tools.attach.AttachNotSupportedException: Unable to open socket file: target process not responding or HotSpot VM not loaded
	at com.yourkit.b.f.a(a:128)
	at com.yourkit.b.c.attach(a:1)
	at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)
	at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.lang.reflect.Method.invoke(Method.java:498)
	at com.yourkit.h.run(a:17)

Attach to a running JVM failed.

Solution: start JVM with the profiler agent instead of attaching it to a running JVM:
https://www.yourkit.com/docs/java/help/running_with_profiler.jsp
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;因此，分析本地Java进程时可以选择attach方式，对于远程服务，还是推荐integrate方式。&lt;/p&gt;

&lt;h2 id=&#34;通过integrate方式连接到远程服务器-重点推荐&#34;&gt;通过integrate方式连接到远程服务器（重点推荐）&lt;/h2&gt;

&lt;p&gt;integrate方式通过修服务器启动配置文件，随服务启动，这种方式比较稳定，而且能够全面启用YourKit的所有功能。&lt;/p&gt;

&lt;h4 id=&#34;线上环境-1&#34;&gt;线上环境&lt;/h4&gt;

&lt;ul&gt;
&lt;li&gt;CentOS release 6.3 64-Bit&lt;/li&gt;
&lt;li&gt;Java 1.7.0_79 HotSpot&amp;trade; 64-Bit Server VM&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&#34;下载安装包-1&#34;&gt;下载安装包&lt;/h4&gt;

&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;# wget https://www.yourkit.com/download/yjp-2017.02-b53.zip
# unzip yjp-2017.02-b53.zip
# cd yjp-2017.02
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;确定服务进程号-1&#34;&gt;确定服务进程号&lt;/h4&gt;

&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;# jps
2230 Resin
3959 Jps
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;console连接进程-1&#34;&gt;Console连接进程&lt;/h4&gt;

&lt;p&gt;通过下面的命令来连接到Java进程。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;# bin/yjp.sh -integrate
Choose server to integrate with:
1) Geronimo
2) GlassFish
3) JBoss / WildFly
4) Jetty
5) JRun 4
6) Resin 3.1/4
7) Tomcat 3–8
8) WebLogic 9 and newer
9) WebSphere Application Server 7 or newer
10) WebSphere Application Server V8.5 Liberty profile
11) Generic server (use if your server is not on the list)
Enter number which corresponds to your server (0 to exit) and press Enter:
&amp;gt;6
Please specify whether the server runs on a 32-bit JVM or a 64-bit JVM.
Hint: If you are not sure what to choose, choose &amp;quot;32-bit JVM&amp;quot;. If with this choice the server does not start with profiling, re-run the integration and choose &amp;quot;64-bit Java&amp;quot; option.
1) 32-bit JVM
2) 64-bit JVM
&amp;gt;2
Resin configuration file (&amp;lt;RESIN_HOME&amp;gt;/conf/resin.xml or &amp;lt;RESIN_HOME&amp;gt;/conf/resin.conf):
&amp;gt;/home/work/bin/miui-sec-adv/resin/conf/resin.xml

Startup options configuration: step 1 of 5
Should option &#39;disablestacktelemetry&#39; be specified?
1) Yes (recommended to minimize profiling overhead in production)
2) No
&amp;gt;2
Startup options configuration: step 2 of 5
Should option &#39;exceptions=disable&#39; be specified?
1) Yes (recommended to minimize profiling overhead in production)
2) No
&amp;gt;1
Startup options configuration: step 3 of 5
Built-in probes:

1) Enabled: recommended for use in DEVELOPMENT; gives high level profiling results, but may add overhead
2) Disabled: recommended for use in PRODUCTION to minimise overhead, or for troubleshooting

Hint: It&#39;s recommended to choose #1 in development and #2 in production.
If choosing #1 makes profiling overhead big or there are startup issues, re-run the integration and choose #2.
&amp;gt;2
Startup options configuration: step 4 of 5
Should option &#39;delay=10000&#39; be specified?
1) Yes (recommended)
2) No
&amp;gt;1
Startup options configuration: step 5 of 5
Please specify comma-separated list of additional startup options, or press Enter for no additional options:
&amp;gt;
A new config file is created:

/home/work/bin/miui-sec-adv/resin/conf/resin_yjp.xml

To profile the server:

1) [Recommended] Backup original &#39;resin.xml&#39;
2) Rename &#39;resin_yjp.xml&#39; to &#39;resin.xml&#39;
3) Start the server
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;上面的操作执行完成后，会在操作中指定的resin配置文件目录生成&lt;code&gt;resin_yjp.xml&lt;/code&gt;文件，接下来将该&lt;code&gt;resin_yjp.xml&lt;/code&gt;重命名为&lt;code&gt;resin.xml&lt;/code&gt;，并启动服务器。正常情况下，YourKit的Console程序便会随着Resin服务器自动启动，可以通过&lt;code&gt;lsof&lt;/code&gt;命令确认一下。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;# lsof -i:10001
COMMAND  PID USER   FD   TYPE     DEVICE SIZE/OFF NODE NAME
java    2389 work    8u  IPv4 3188835745      0t0  TCP *:scp-config (LISTEN)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;同时，可以通过IP:PORT的方式在浏览器中查看YourKit Console服务的概况。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://olno3yiqc.bkt.clouddn.com/blog/img/yourkit-page-integrate.png&#34; alt=&#34;YourKit Page&#34; /&gt;&lt;/p&gt;

&lt;h4 id=&#34;yourkit-ui连接远程服务-1&#34;&gt;YourKit UI连接远程服务&lt;/h4&gt;

&lt;p&gt;打开YourKit UI，点击Connect to remote application，输入IP:PORT进行连接。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://olno3yiqc.bkt.clouddn.com/blog/img/yourkit-ui-connect-integrate.png&#34; alt=&#34;YourKit UI Connect&#34; /&gt;&lt;/p&gt;

&lt;p&gt;连接成功后，进行性能分析界面，大功告成。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://olno3yiqc.bkt.clouddn.com/blog/img/your-kit-home-integrate.png&#34; alt=&#34;YourKit性能分析界面&#34; /&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>在CentOS上安装Rabbitmq集群</title>
      <link>http://nituchao.com/post/2017/centos-an-zhuang-rabbit-cluster/</link>
      <pubDate>Thu, 02 Mar 2017 17:35:54 +0800</pubDate>
      
      <guid>http://nituchao.com/post/2017/centos-an-zhuang-rabbit-cluster/</guid>
      <description>

&lt;h2 id=&#34;系统环境&#34;&gt;系统环境&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;CentOS 7 四台&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;安装包准备&#34;&gt;安装包准备&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;wxBase-2.8.12-1.el6.centos.x86_64.rpm&lt;/li&gt;
&lt;li&gt;wxGTK-2.8.12-1.el6.centos.x86_64.rpm&lt;/li&gt;
&lt;li&gt;wxGTK-gl-2.8.12-1.el6.centos.x86_64.rpm&lt;/li&gt;
&lt;li&gt;esl-erlang_19.2.3~centos~6_amd64.rpm&lt;/li&gt;
&lt;li&gt;otp_src_19.1.tar.gz&lt;/li&gt;
&lt;li&gt;rabbitmq-server-3.6.6-1.el6.noarch.rpm&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;安装erlang环境&#34;&gt;安装Erlang环境&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;# yum localinstall wxBase-2.8.12-1.el6.centos.x86_64.rpm
# yum localinstall wxGTK-2.8.12-1.el6.centos.x86_64.rpm
# yum localinstall wxGTK-gl-2.8.12-1.el6.centos.x86_64.rpm
# yum localinstall esl-erlang_19.2.3~centos~6_amd64.rpm
# yum install build-essential openssl openssl-devel unixODBC unixODBC-devel make gcc gcc-c++ kernel-devel m4 ncurses-devel tk tc
# tar -zxvf otp_src_19.1.tar.gz
# cd otp_src_19.1
# ./configure --prefix=/home/erlang --without-javac
# make &amp;amp;&amp;amp; make install
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;安装完Erlang之后，修改/etc/profile增加&lt;/p&gt;

&lt;p&gt;export PATH=$PATH:/home/erlang/bin&lt;/p&gt;

&lt;p&gt;执行source /etc/profile使得环境变量生效&lt;/p&gt;

&lt;h2 id=&#34;安装rabbitmq&#34;&gt;安装Rabbitmq&lt;/h2&gt;

&lt;h3 id=&#34;安装rabbitmq-1&#34;&gt;安装rabbitmq&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;# rpm --import https://www.rabbitmq.com/rabbitmq-release-signing-key.asc
# rpm --nodeps -Uvh rabbitmq-server-3.6.6-1.noarch.rpm
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;添加开机启动&#34;&gt;添加开机启动&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;# chkconfig rabbitmq-server on
# service rabbitmq-server start
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;开启web管理界面&#34;&gt;开启web管理界面&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;# rabbitmq-plugins enable rabbitmq_management
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;添加用户&#34;&gt;添加用户&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;# rabbitmqctl add_user work workO^m15213
# rabbitmqctl set_user_tags work administrator
# rabbitmqctl set_permissions -p / work &amp;quot;.*&amp;quot;&amp;quot;.*&amp;quot;&amp;quot;.*&amp;quot;
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>jstack命令</title>
      <link>http://nituchao.com/post/2017/tong-guo-jstack-fen-xi/</link>
      <pubDate>Tue, 28 Feb 2017 19:01:58 +0800</pubDate>
      
      <guid>http://nituchao.com/post/2017/tong-guo-jstack-fen-xi/</guid>
      <description>

&lt;p&gt;Java程序在操作系统上是以单进程、多线程的形式运行。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;[work@zc-stage1-miui-sec02 ~]$ jstack
Usage:
    jstack [-l] &amp;lt;pid&amp;gt;
        (to connect to running process)
    jstack -F [-m] [-l] &amp;lt;pid&amp;gt;
        (to connect to a hung process)
    jstack [-m] [-l] &amp;lt;executable&amp;gt; &amp;lt;core&amp;gt;
        (to connect to a core file)
    jstack [-m] [-l] [server_id@]&amp;lt;remote server IP or hostname&amp;gt;
        (to connect to a remote debug server)

Options:
    -F  to force a thread dump. Use when jstack &amp;lt;pid&amp;gt; does not respond (process is hung)
    -m  to print both java and native frames (mixed mode)
    -l  long listing. Prints additional information about locks
    -h or -help to print this help message
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;jstack参数说明&#34;&gt;jstack参数说明&lt;/h2&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;连接到运行中的进程&lt;/p&gt;

&lt;p&gt;&amp;ldquo;jstack pid&amp;rdquo;，pid为进程号，可以通过jps或者top命令查到。&lt;/p&gt;

&lt;p&gt;命令执行成功则堆栈信息打印在控制台，可以通过&amp;rdquo;jstack 7023 &amp;gt; stack.log&amp;rdquo;这种方式将内容输出文件。&lt;/p&gt;

&lt;p&gt;导出的文本中包含线程号，线程号状态，线程调用栈等信息，结合ps命令中查询出的线程号，可以分析出CPU使用率比较高的线程，以及该线程中的调用堆栈，进而可以定位到项目代码。&lt;/p&gt;

&lt;p&gt;```
Thread 1091: (state = BLOCKED)&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;sun.misc.Unsafe.park(boolean, long) @bci=0 (Compiled frame; information may be imprecise)&lt;/li&gt;
&lt;li&gt;java.util.concurrent.locks.LockSupport.park() @bci=5, line=315 (Interpreted frame)&lt;/li&gt;
&lt;li&gt;com.caucho.env.thread2.ResinThread2.park() @bci=29, line=196 (Compiled frame)&lt;/li&gt;
&lt;li&gt;com.caucho.env.thread2.ResinThread2.runTasks() @bci=65, line=147 (Compiled frame)&lt;/li&gt;
&lt;li&gt;com.caucho.env.thread2.ResinThread2.run() @bci=15, line=118 (Interpreted frame)
```&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;Thread 1089: (state = BLOCKED)
    - sun.misc.Unsafe.park(boolean, long) @bci=0 (Compiled frame; information may be imprecise)
    - java.util.concurrent.locks.LockSupport.park() @bci=5, line=315 (Interpreted frame)
    - com.caucho.env.thread2.ResinThread2.park() @bci=29, line=196 (Compiled frame)
    - com.caucho.env.thread2.ResinThread2.runTasks() @bci=65, line=147 (Compiled frame)
    - com.caucho.env.thread2.ResinThread2.run() @bci=15, line=118 (Interpreted frame)&lt;/p&gt;

&lt;p&gt;Thread 1088: (state = IN_NATIVE)
    - java.net.SocketInputStream.socketRead0(java.io.FileDescriptor, byte[], int, int, int) @bci=0 (Compiled frame; information may be imprecise)
    - java.net.SocketInputStream.read(byte[], int, int, int) @bci=79, line=150 (Compiled frame)
    - java.net.SocketInputStream.read(byte[], int, int) @bci=11, line=121 (Compiled frame)
    - java.net.SocketInputStream.read(byte[]) @bci=5, line=107 (Compiled frame)
    - redis.clients.util.RedisInputStream.ensureFill() @bci=20, line=195 (Compiled frame)
    - redis.clients.util.RedisInputStream.readByte() @bci=1, line=40 (Compiled frame)
    - redis.clients.jedis.Protocol.process(redis.clients.util.RedisInputStream) @bci=1, line=141 (Compiled frame)
    - redis.clients.jedis.Protocol.read(redis.clients.util.RedisInputStream) @bci=1, line=205 (Compiled frame)
    - redis.clients.jedis.Connection.readProtocolWithCheckingBroken() @bci=4, line=297 (Compiled frame)
    - redis.clients.jedis.Connection.getBinaryBulkReply() @bci=15, line=216 (Compiled frame)
    - redis.clients.jedis.Connection.getBulkReply() @bci=1, line=205 (Compiled frame)
    - redis.clients.jedis.Jedis.get(java.lang.String) @bci=27, line=101 (Compiled frame)
    - redis.clients.jedis.JedisCluster$3.execute(redis.clients.jedis.Jedis) @bci=5, line=79 (Compiled frame)
    - redis.clients.jedis.JedisCluster$3.execute(redis.clients.jedis.Jedis) @bci=2, line=76 (Compiled frame)
    - redis.clients.jedis.JedisClusterCommand.runWithRetries(byte[], int, boolean, boolean) @bci=78, line=119 (Compiled frame)
    - redis.clients.jedis.JedisClusterCommand.run(java.lang.String) @bci=25, line=30 (Compiled frame)
    - redis.clients.jedis.JedisCluster.get(java.lang.String) @bci=18, line=81 (Compiled frame)
    - com.xiaomi.miui.sec.service.RedisCacheService$14.call(redis.clients.jedis.RedisCluster) @bci=5, line=667 (Compiled frame)
    - com.xiaomi.miui.sec.service.RedisCacheService$14.call(java.lang.Object) @bci=5, line=663 (Compiled frame)
    - com.xiaomi.miui.cache.rediscluster.DefaultRedisClusterCache.get(java.lang.Object, com.xiaomi.miui.cache.rediscluster.RedisClusterCallable) @bci=22, line=68 (Compiled frame)
    - com.xiaomi.miui.sec.service.RedisCacheService.getSettingAdv(java.lang.String, java.lang.String, java.lang.String) @bci=49, line=663 (Compiled frame)
    - com.xiaomi.miui.sec.service.CacheService.getSettingAdv(java.lang.String, java.lang.String, java.lang.String) @bci=7, line=113 (Compiled frame)
    - com.xiaomi.miui.sec.bizLogic.SettingBiz.postHandlerMiCom(net.sf.json.JSONObject, com.xiaomi.miui.sec.thrift.Device, net.paoding.rose.web.Invocation) @bci=55, line=119 (Compiled frame)
    - com.xiaomi.miui.sec.bizLogic.SettingBiz.postHandler(net.sf.json.JSONObject, com.xiaomi.miui.sec.thrift.Device, net.paoding.rose.web.Invocation) @bci=118, line=65 (Compiled frame)
    - com.xiaomi.miui.sec.bizLogic.BasicBiz.mainHandler(net.paoding.rose.web.Invocation) @bci=29, line=59 (Compiled frame)
    - com.xiaomi.miui.sec.controllers.InfoController.setting(net.paoding.rose.web.Invocation, java.lang.String) @bci=73, line=252 (Compiled frame)
    - sun.reflect.GeneratedMethodAccessor31.invoke(java.lang.Object, java.lang.Object[]) @bci=48 (Compiled frame)
    - sun.reflect.DelegatingMethodAccessorImpl.invoke(java.lang.Object, java.lang.Object[]) @bci=6, line=43 (Compiled frame)
    - java.lang.reflect.Method.invoke(java.lang.Object, java.lang.Object[]) @bci=57, line=606 (Compiled frame)&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;
   ​

## jstack分析java线程的CPU使用率和使用时长



## jstack分析分析已有的javacore文件



## jstack连接到远程调试服务器进行分析
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>解决Java进程占用CPU过高的问题</title>
      <link>http://nituchao.com/post/2017/ji-lu-yi-ci-cpu-guo-gao-chu-li/</link>
      <pubDate>Tue, 28 Feb 2017 09:16:18 +0800</pubDate>
      
      <guid>http://nituchao.com/post/2017/ji-lu-yi-ci-cpu-guo-gao-chu-li/</guid>
      <description></description>
    </item>
    
    <item>
      <title>CopyOnWriteArrayList源码分析</title>
      <link>http://nituchao.com/post/juc.concurrent/copy-on-write-array-list/</link>
      <pubDate>Thu, 23 Feb 2017 18:25:27 +0800</pubDate>
      
      <guid>http://nituchao.com/post/juc.concurrent/copy-on-write-array-list/</guid>
      <description>

&lt;h2 id=&#34;概述&#34;&gt;概述&lt;/h2&gt;

&lt;p&gt;CopyOnWriteArrayList相当于线程安全的ArrayList。和ArrayList一样，它是个可变数组；但是和ArrayList不同的是，它具有以下特性：
1. 它最适合于具有以下特征的应用程序：List大小通常保持很小，只读操作远多于可变操作，需要在遍历期间防止线程间的冲突。
2. 它是线程安全的。它的线程安全表现在两个方面，修改时使用锁进行同步，读取时使用数据快照。
3. 因为通常要复制整个基础数组，所以可变操作（add()、set()和remove()等操作）的开销很大。
4. 迭代器支持hasNext()、next等不可变操作，但不支持可变remove()等操作。
5. 使用迭代器进行遍历的速度很快，并且不会与其他线程发生冲突。在构造迭代器时，迭代器依赖于不变的数组快照。&lt;/p&gt;

&lt;h2 id=&#34;copyonwritearraylist原理和数据结构&#34;&gt;CopyOnWriteArrayList原理和数据结构&lt;/h2&gt;

&lt;p&gt;CopyOnWriteArrayList的数据结构，如下图所示：&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;CopyOnWriteArrayList UML图&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;说明：
1. CopyOnWriteArrayList实现了List接口，因此可以认为它是一个有序的集合。
2. CopyOnWriteArrayList实现了RandomAccess接口，因此可以认为它的元素可以随机访问。
3. CopyOnWriteArrayList包含一个可重入锁Lock。每一个CopyOnWriteArrayList都和一个互斥锁lock绑定，通过lock，实现了对CopyOnWriteArrayList的互斥访问。
4. CopyOnWriteArrayList包含了成员array数组，这说明CopyOnWriteArrayList本质上通过数组实现的。而且，可存储的元素个数没有上限。&lt;/p&gt;

&lt;p&gt;下面从&amp;rdquo;动态数组&amp;rdquo;和&amp;rdquo;线程安全&amp;rdquo;两个方面进一步对CopyOnWriteArrayList的原理进行说明。
1. &lt;strong&gt;CopyOnWriteArrayList的&amp;rdquo;动态数组&amp;rdquo;机制&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;它内部有个&amp;rdquo;volatile数组&amp;rdquo;(array)来保持数据。在&amp;rdquo;添加/修改/删除&amp;rdquo;数据时，都会新建一个数组，并将更新后的数据拷贝到新建的数组中，最后再将该数组赋值给&amp;rdquo;volatile数组&amp;rdquo;。这就是它叫做CopyOnWriteArrayList的原因！&lt;/p&gt;

&lt;p&gt;CopyOnWriteArrayList就是通过这种方式实现的动态数组；不过正由于它在&amp;rdquo;添加/修改/删除&amp;rdquo;数据时，都会新建数组，所以涉及到修改数据的操作，CopyOnWriteArrayList效率很低。但是单单只是进行遍历的话，效率比较高。&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;CopyOnWriteArrayList的&amp;rdquo;线程安全&amp;rdquo;机制&lt;/strong&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;是通过volatile和互斥锁来实现的。
 a. CopyOnWriteArrayList是通过&amp;rdquo;volatile数组&amp;rdquo;来保存数据的。&lt;/p&gt;

&lt;p&gt;一个线程读取volatile数组时，总能看到其他线程对该volatile变量最后的写入。就这样，通过volatile提供了&amp;rdquo;读取到的数据总是最新的&amp;rdquo;这个机制的保证。
 b. CopyOnWriteArrayList通过互斥锁来保护数据。&lt;/p&gt;

&lt;p&gt;在&amp;rdquo;添加/修改/删除&amp;rdquo;数据时，会先&amp;rdquo;获取互斥锁&amp;rdquo;，在修改完毕后，先将数据更新到&amp;rdquo;volatile数组&amp;rdquo;中，然后再&amp;rdquo;释放互斥锁&amp;rdquo;；这样，就达到了保护数据的目的。&lt;/p&gt;

&lt;h2 id=&#34;copyonwritearraylist成员变量&#34;&gt;CopyOnWriteArrayList成员变量&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;/** 可重入锁，对数组进行添加/修改/删除操作时，通过lock来进行同步操作 */
transient final ReentrantLock lock = new ReentrantLock();

/** 数组，保存数据的地方。对数组array的操作都要通过getArray和setArray进行操作 */
private volatile transient Object[] array;
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;copyonwritearraylist函数列表&#34;&gt;CopyOnWriteArrayList函数列表&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;// 创建一个空列表，默认大小为0。
CopyOnWriteArrayList()
// 创建一个按 collection 的迭代器返回元素的顺序包含指定 collection 元素的列表。
CopyOnWriteArrayList(Collection&amp;lt;? extends E&amp;gt; c)
// 创建一个保存给定数组的副本的列表。 
CopyOnWriteArrayList(E[] toCopyIn)
// 将指定元素添加到此列表的尾部。
boolean add(E e)
// 在此列表的指定位置上插入指定元素。
void add(int index, E element)
// 按照指定 collection 的迭代器返回元素的顺序，将指定 collection 中的所有元素添加此列表的尾部。
boolean addAll(Collection&amp;lt;? extends E&amp;gt; c)
// 从指定位置开始，将指定 collection 的所有元素插入此列表。
boolean addAll(int index, Collection&amp;lt;? extends E&amp;gt; c)
// 按照指定 collection 的迭代器返回元素的顺序，将指定 collection 中尚未包含在此列表中的所有元素添加列表的尾部。
int addAllAbsent(Collection&amp;lt;? extends E&amp;gt; c)
// 添加元素（如果不存在）。
boolean addIfAbsent(E e)
// 从此列表移除所有元素。
void clear()
// 返回此列表的浅表副本。
Object clone()
// 如果此列表包含指定的元素，则返回 true。
boolean contains(Object o)
// 如果此列表包含指定 collection 的所有元素，则返回 true。
boolean containsAll(Collection&amp;lt;?&amp;gt; c)
// 比较指定对象与此列表的相等性。
boolean equals(Object o)
// 返回列表中指定位置的元素。
E get(int index)
// 返回此列表的哈希码值。
int hashCode()
// 返回第一次出现的指定元素在此列表中的索引，从 index 开始向前搜索，如果没有找到该元素，则返回 -1。
int indexOf(E e, int index)
// 返回此列表中第一次出现的指定元素的索引；如果此列表不包含该元素，则返回 -1。
int indexOf(Object o)
// 如果此列表不包含任何元素，则返回 true。
boolean isEmpty()
// 返回以恰当顺序在此列表元素上进行迭代的迭代器。
Iterator&amp;lt;E&amp;gt; iterator()
// 返回最后一次出现的指定元素在此列表中的索引，从 index 开始向后搜索，如果没有找到该元素，则返回 -1。
int lastIndexOf(E e, int index)
// 返回此列表中最后出现的指定元素的索引；如果列表不包含此元素，则返回 -1。
int lastIndexOf(Object o)
// 返回此列表元素的列表迭代器（按适当顺序）。
ListIterator&amp;lt;E&amp;gt; listIterator()
// 返回列表中元素的列表迭代器（按适当顺序），从列表的指定位置开始。
ListIterator&amp;lt;E&amp;gt; listIterator(int index)
// 移除此列表指定位置上的元素。
E remove(int index)
// 从此列表移除第一次出现的指定元素（如果存在）。
boolean remove(Object o)
// 从此列表移除所有包含在指定 collection 中的元素。
boolean removeAll(Collection&amp;lt;?&amp;gt; c)
// 只保留此列表中包含在指定 collection 中的元素。
boolean retainAll(Collection&amp;lt;?&amp;gt; c)
// 用指定的元素替代此列表指定位置上的元素。
E set(int index, E element)
// 返回此列表中的元素数。
int size()
// 返回此列表中 fromIndex（包括）和 toIndex（不包括）之间部分的视图。
List&amp;lt;E&amp;gt; subList(int fromIndex, int toIndex)
// 返回一个按恰当顺序（从第一个元素到最后一个元素）包含此列表中所有元素的数组。
Object[] toArray()
// 返回以恰当顺序（从第一个元素到最后一个元素）包含列表所有元素的数组；返回数组的运行时类型是指定数组的运行时类型。
&amp;lt;T&amp;gt; T[] toArray(T[] a)
// 返回此列表的字符串表示形式。
String toString()
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;copyonwritearraylist重点函数分析&#34;&gt;CopyOnWriteArrayList重点函数分析&lt;/h2&gt;

&lt;h3 id=&#34;构造函数&#34;&gt;构造函数&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;// 初始化一个大小为0的对象数组
public CopyOnWriteArrayList() {
    setArray(new Object[0]);
}

// 使用一个集合里的元素来初始化一个对象数组
public CopyOnWriteArrayList(Collection&amp;lt;? extends E&amp;gt; c) {
    Object[] elements = c.toArray();
    if (elements.getClass() != Object[].class)
        elements = Arrays.copyOf(elements, elements.length, Object[].class);
    setArray(elements);
}

// 使用一个数组里元素来初始化一个对象数组
public CopyOnWriteArrayList(E[] toCopyIn) {
    setArray(Arrays.copyOf(toCopyIn, toCopyIn.length, Object[].class));
}

final Object[] getArray() {
    return array;
}

final void setArray(Object[] a) {
    array = a;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;CopyOnWriteArrayList的三个构造函数都调用了setArray()，将新创建的数组赋值给CopyOnWriteArrayList的成员变量array。&lt;/p&gt;

&lt;h3 id=&#34;添加&#34;&gt;添加&lt;/h3&gt;

&lt;h4 id=&#34;直接添加&#34;&gt;直接添加&lt;/h4&gt;

&lt;p&gt;以add(E e)为例来分析&lt;code&gt;CopyOnWriteArrayList&lt;/code&gt;的添加操作。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public boolean add(E e) {
    final ReentrantLock lock = this.lock;
    // 获取“锁”
    lock.lock();
    try {
        // 获取原始”volatile数组“中的数据和数据长度。
        Object[] elements = getArray();
        int len = elements.length;
        // 新建一个数组newElements，并将原始数据拷贝到newElements中；
        // newElements数组的长度=“原始数组的长度”+1
        Object[] newElements = Arrays.copyOf(elements, len + 1);
        // 将“新增加的元素”保存到newElements中。
        newElements[len] = e;
        // 将newElements赋值给”volatile数组“。
        setArray(newElements);
        return true;
    } finally {
        // 释放“锁”
        lock.unlock();
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;说明&lt;/strong&gt;：&lt;/p&gt;

&lt;p&gt;add(E e)的作用就是将数据e添加到”volatile数组“中。它的实现方式是，新建一个数组，接着将原始的”volatile数组“的数据拷贝到新数组中，然后将新增数据也添加到新数组中；最后，将新数组赋值给”volatile数组“。&lt;/p&gt;

&lt;p&gt;在add(E e)中有两点需要关注。&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;在”添加操作“开始前，获取独占锁(lock)，若此时有需要线程要获取锁，则必须等待；在操作完毕后，释放独占锁(lock)，此时其它线程才能获取锁。通过独占锁，来防止多线程同时修改数据！lock的定义如下：&lt;/li&gt;
&lt;/ol&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;transient final ReentrantLock lock = new ReentrantLock();
&lt;/code&gt;&lt;/pre&gt;

&lt;ol&gt;
&lt;li&gt;操作完毕时，会通过setArray()来更新”volatile数组“。而且，前面我们提过”即对一个volatile变量的读，总是能看到（任意线程）对这个volatile变量最后的写入“；这样，每次添加元素之后，其它线程都能看到新添加的元素。&lt;/li&gt;
&lt;/ol&gt;

&lt;h4 id=&#34;不重复添加&#34;&gt;不重复添加&lt;/h4&gt;

&lt;p&gt;由于CopyOnWriteArraySet是通过聚合了一个CopyOnWriteArrayList实现的，而CopyOnWriteArraySet是不包含重复元素的，因此CopyOnWriteArrayList提供了一个不添加重复元素的方法&lt;code&gt;addIfAbsent&lt;/code&gt;，该方法每次从头遍历数组，如果发现元素已经存在，则直接返回false，如果遍历后待添加元素不存在，则添加到新数组的末尾，然后将新数组设置为成员数组。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public boolean addIfAbsent(E e) {
        final ReentrantLock lock = this.lock;
        lock.lock();
        try {
            // Copy while checking if already present.
            // This wins in the most common case where it is not present
            Object[] elements = getArray();
            int len = elements.length;
            Object[] newElements = new Object[len + 1];
            for (int i = 0; i &amp;lt; len; ++i) {
                if (eq(e, elements[i]))
                    return false; // exit, throwing away copy
                else
                    newElements[i] = elements[i];
            }
            newElements[len] = e;
            setArray(newElements);
            return true;
        } finally {
            lock.unlock();
        }
    }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;有在检查待添加元素是否已经存在时要从头遍历数组，因此随着元素个数递增，该方法的效率线性下降。&lt;/p&gt;

&lt;h3 id=&#34;获取&#34;&gt;获取&lt;/h3&gt;

&lt;p&gt;以get(int index)为例，来对&lt;code&gt;CopyOnWriteArrayList&lt;/code&gt;的删除操作进行说明。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public E get(int index) {
    return get(getArray(), index);
}

private E get(Object[] a, int index) {
    return (E) a[index];
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;说明:&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;get(int index)的实现非常简单，就是返回&amp;rdquo;volatile数组&amp;rdquo;中的第index个元素。读取元素的过程不需要加锁，是读取时array的镜像。&lt;/p&gt;

&lt;h4 id=&#34;删除&#34;&gt;删除&lt;/h4&gt;

&lt;p&gt;以remove(int index)为例，来说明&lt;code&gt;CopyOnWriteArrayList&lt;/code&gt;的删除操作。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public E remove(int index) {
    final ReentrantLock lock = this.lock;
    // 获取“锁”
    lock.lock();
    try {
        // 获取原始”volatile数组“中的数据和数据长度。
        Object[] elements = getArray();
        int len = elements.length;
        // 获取elements数组中的第index个数据。
        E oldValue = get(elements, index);
        int numMoved = len - index - 1;
        // 如果被删除的是最后一个元素，则直接通过Arrays.copyOf()进行处理，而不需要新建数组。
        // 否则，新建数组，然后将”volatile数组中被删除元素之外的其它元素“拷贝到新数组中。
        // 最后，将新数组赋值给”volatile数组“。
        if (numMoved == 0)
            setArray(Arrays.copyOf(elements, len - 1));
        else {
            Object[] newElements = new Object[len - 1];
            System.arraycopy(elements, 0, newElements, 0, index);
            System.arraycopy(elements, index + 1, newElements, index,
                             numMoved);
            setArray(newElements);
        }
        return oldValue;
    } finally {
        // 释放“锁”
        lock.unlock();
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;说明&lt;/strong&gt;：&lt;/p&gt;

&lt;p&gt;remove(int index)的作用就是将”volatile数组“中第index个元素删除。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;em&gt;它的实现方式是，如果被删除的是最后一个元素，则直接通过Arrays.copyOf()进行处理，而不需要新建数组。&lt;/em&gt;&lt;/strong&gt;否则，新建数组，然后将”volatile数组中被删除元素之外的其它元素“拷贝到新数组中。最后，将新数组赋值给”volatile数组“。
和add(E e)一样，remove(int index)也是”在操作之前，获取独占锁；操作完成之后，释放独占是“；并且”在操作完成时，会通过将数据更新到volatile数组中“。&lt;/p&gt;

&lt;p&gt;remove操作没有检查index的合法性，有可能会抛出IndexOutOfBoundsExceptions&lt;/p&gt;

&lt;h3 id=&#34;遍历&#34;&gt;遍历&lt;/h3&gt;

&lt;p&gt;以&lt;code&gt;iterator()&lt;/code&gt;为例，来说明&lt;code&gt;CopyOnWriteArrayList&lt;/code&gt;的遍历操作。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public Iterator&amp;lt;E&amp;gt; iterator() {
  return new COWIterator&amp;lt;E&amp;gt; (getArray(), 0);
}

private static class COWIterator&amp;lt;E&amp;gt; implements ListIterator&amp;lt;E&amp;gt; {
    private final Object[] snapshot;
    private int cursor;

    private COWIterator(Object[] elements, int initialCursor) {
        cursor = initialCursor;
        snapshot = elements;
    }

    public boolean hasNext() {
        return cursor &amp;lt; snapshot.length;
    }

    public boolean hasPrevious() {
        return cursor &amp;gt; 0;
    }

    // 获取下一个元素
    @SuppressWarnings(&amp;quot;unchecked&amp;quot;)
    public E next() {
        if (!hasNext())
            throw new NoSuchElementException();
        return (E) snapshot[cursor++];
    }

    // 获取上一个元素
    @SuppressWarnings(&amp;quot;unchecked&amp;quot;)
    public E previous() {
        if (!hasPrevious())
            throw new NoSuchElementException();
        return (E) snapshot[--cursor];
    }

    public int nextIndex() {
        return cursor;
    }

    public int previousIndex() {
        return cursor-1;
    }

    public void remove() {
        throw new UnsupportedOperationException();
    }

    public void set(E e) {
        throw new UnsupportedOperationException();
    }

    public void add(E e) {
        throw new UnsupportedOperationException();
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;说明&lt;/strong&gt;：&lt;/p&gt;

&lt;p&gt;COWIterator不支持修改元素的操作。例如，对于&lt;code&gt;remove()&lt;/code&gt;,&lt;code&gt;set()&lt;/code&gt;,&lt;code&gt;add()&lt;/code&gt;等操作，&lt;code&gt;COWIterator&lt;/code&gt;都会抛出异常！
另外，需要提到的一点是，CopyOnWriteArrayList返回迭代器不会抛出&lt;code&gt;ConcurrentModificationException&lt;/code&gt;异常，即它不是fail-fast机制的！&lt;/p&gt;

&lt;p&gt;参考：&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;http://www.cnblogs.com/skywang12345/p/3498483.html&#34;&gt;Java多线程系列之CopyOnWriteArrayList&lt;/a&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>CopyOnWriteArraySet源码分析</title>
      <link>http://nituchao.com/post/juc.concurrent/copy-on-write-array-set/</link>
      <pubDate>Thu, 23 Feb 2017 18:25:27 +0800</pubDate>
      
      <guid>http://nituchao.com/post/juc.concurrent/copy-on-write-array-set/</guid>
      <description>

&lt;h2 id=&#34;一句话&#34;&gt;一句话&lt;/h2&gt;

&lt;p&gt;&lt;code&gt;CopyOnWriteArraySet&lt;/code&gt;是线程安全的无序集合，它是通过聚合了一个&lt;code&gt;CopyOnWriteArray&lt;/code&gt;成员变量来实现的。&lt;/p&gt;

&lt;h2 id=&#34;概要&#34;&gt;概要&lt;/h2&gt;

&lt;p&gt;&lt;code&gt;CopyOnWriteArraySet&lt;/code&gt;是线程安全的无序集合，可以将它理解成线程安全的HashSet。有意思的是，&lt;code&gt;CopyOnWriteArraySet&lt;/code&gt;和HashSet虽然都继承于共同的父类AbstractSet；但是，HashSet是通过&amp;rdquo;散列表(HashSet)&amp;ldquo;实现的，而CopyConWriteArraySet则是通过&amp;rdquo;动态数组(CopyOnWriteArrayList)&amp;ldquo;实现的，并不是散列表。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;CopyOnWriteArraySet&lt;/code&gt;具有以下特性：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;它最适合于具有以下特征的应用程序：Set 大小通常保持很小，只读操作远多于可变操作，需要在遍历期间防止线程间的冲突。&lt;/li&gt;
&lt;li&gt;它是线程安全的。它的线程安全通过volatile、互斥锁来实现。&lt;/li&gt;
&lt;li&gt;因为通常需要复制整个基础数组，所以可变操作（add()、set() 和 remove() 等等）的开销很大。&lt;/li&gt;
&lt;li&gt;迭代器支持hasNext(), next()等不可变操作，但不支持可变 remove()等 操作。&lt;/li&gt;
&lt;li&gt;使用迭代器进行遍历的速度很快，并且不会与其他线程发生冲突。在构造迭代器时，迭代器依赖于不变的数组快照。&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&#34;copyonwritearrayset原理&#34;&gt;CopyOnWriteArraySet原理&lt;/h2&gt;

&lt;p&gt;CopyOnWriteArraySet的数据结构，如下图所示：&lt;/p&gt;

&lt;p&gt;&lt;code&gt;图&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;说明&lt;/strong&gt;&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;CopyOnWriteArraySet继承于AbstractSet，这就意味着它是一个集合。&lt;/li&gt;
&lt;li&gt;CopyOnWriteArraySet聚合了一个CopyOnWriteArrayList对象，它是通过CopyOnWriteArrayList实现的。而CopyOnWriteArrayList本质是个动态数组队列，所以CopyOnWriteArraySet相当于通过动态数组实现的&amp;rdquo;集合&amp;rdquo;！&lt;/li&gt;
&lt;li&gt;CopyOnWriteArraySet不允许有重复元素。因此，CopyOnWriteArrayList额外提供了addIfAbsent()和addAllAbsent()这两个添加元素的API，通过这些API来添加元素时，只有当元素不存在时才执行添加操作。&lt;/li&gt;
&lt;li&gt;CopyOnWriteArraySet的&amp;rdquo;线程安全&amp;rdquo;机制是通过volatile和互斥锁来实现的。而它本身没有volatile变量和互斥锁，都是借由CopyOnWriteArrayList实现。&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&#34;copyonwritearrayset函数列表&#34;&gt;CopyOnWriteArraySet函数列表&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;// 创建一个空 set。
CopyOnWriteArraySet()
// 创建一个包含指定 collection 所有元素的 set。
CopyOnWriteArraySet(Collection&amp;lt;? extends E&amp;gt; c)

// 如果指定元素并不存在于此 set 中，则添加它。
boolean add(E e)
// 如果此 set 中没有指定 collection 中的所有元素，则将它们都添加到此 set 中。
boolean addAll(Collection&amp;lt;? extends E&amp;gt; c)
// 移除此 set 中的所有元素。
void clear()
// 如果此 set 包含指定元素，则返回 true。
boolean contains(Object o)
// 如果此 set 包含指定 collection 的所有元素，则返回 true。
boolean containsAll(Collection&amp;lt;?&amp;gt; c)
// 比较指定对象与此 set 的相等性。
boolean equals(Object o)
// 如果此 set 不包含任何元素，则返回 true。
boolean isEmpty()
// 返回按照元素添加顺序在此 set 中包含的元素上进行迭代的迭代器。
Iterator&amp;lt;E&amp;gt; iterator()
// 如果指定元素存在于此 set 中，则将其移除。
boolean remove(Object o)
// 移除此 set 中包含在指定 collection 中的所有元素。
boolean removeAll(Collection&amp;lt;?&amp;gt; c)
// 仅保留此 set 中那些包含在指定 collection 中的元素。
boolean retainAll(Collection&amp;lt;?&amp;gt; c)
// 返回此 set 中的元素数目。
int size()
// 返回一个包含此 set 所有元素的数组。
Object[] toArray()
// 返回一个包含此 set 所有元素的数组；返回数组的运行时类型是指定数组的类型。
&amp;lt;T&amp;gt; T[] toArray(T[] a)
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;copyonwritearrayset成员变量&#34;&gt;CopyOnWriteArraySet成员变量&lt;/h2&gt;

&lt;p&gt;CopyOnWriteArraySet只有下面一个成员变量&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;private final CopyOnWriteArrayList&amp;lt;E&amp;gt; al;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;说明:&lt;/strong&gt;&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;成员变量al是&lt;code&gt;final&lt;/code&gt;类型的，通过构造函数进行初始化后将不能再修改。&lt;/li&gt;
&lt;li&gt;成员变量al里的&lt;code&gt;添加/修改/删除&lt;/code&gt;操作都是通过互斥锁和volatile变量来保证现场安全的，因此，成员变量al不再用&lt;code&gt;volatile&lt;/code&gt;修饰，也不再额外声明可重入锁lock。&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&#34;copyonwritearrayset重点函数&#34;&gt;CopyOnWriteArraySet重点函数&lt;/h2&gt;

&lt;h3 id=&#34;构造函数&#34;&gt;构造函数&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public CopyOnWriteArraySet() {
        al = new CopyOnWriteArrayList&amp;lt;E&amp;gt;();
}
public CopyOnWriteArraySet(Collection&amp;lt;? extends E&amp;gt; c) {
        al = new CopyOnWriteArrayList&amp;lt;E&amp;gt;();
        al.addAllAbsent(c);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;CopyOnWriteArraySet允许初始化一个空的集合，也允许通过复制一个集合里的元素来进行初始化。本质上将，CopyOnWriteArraySet的初始化是通过初始化成员变量CopyOnWriteArrayList al来实现的。&lt;/p&gt;

&lt;h3 id=&#34;添加&#34;&gt;添加&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public boolean add(E e) {
        return al.addIfAbsent(e);
}

public boolean addAll(Collection&amp;lt;? extends E&amp;gt; c) {
        return al.addAllAbsent(c) &amp;gt; 0;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;CopyOnWriteArraySet不允许重复元素。因此，添加操作都是调用CopyOnWriteArrayList的&lt;code&gt;addIfAbsent&lt;/code&gt;方法或者&lt;code&gt;addAllAbsent&lt;/code&gt;方法实现的。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Linux网络I/O模型整理</title>
      <link>http://nituchao.com/post/2017/linux-io-mode/</link>
      <pubDate>Wed, 22 Feb 2017 18:25:27 +0800</pubDate>
      
      <guid>http://nituchao.com/post/2017/linux-io-mode/</guid>
      <description>

&lt;p&gt;Linux的内核将所有外部设备都看做一个文件来操作，对一个文件的读写操作会调用内核提供的系统命令，返回一个file description(fd，文件描述符)。而对一个socket的读写也会有相应的描述符，称为socketfd(socket描述符)，描述符就是一个数字，它指向内核中的一个结构体(文件路径，数据区等一些属性)。&lt;/p&gt;

&lt;h2 id=&#34;linux文件类型&#34;&gt;Linux文件类型&lt;/h2&gt;

&lt;p&gt;Linux操作系统定义了七种文件，对这些文件的操作都属于I/O操作。其中，操作TCP套接字文件时会产生网络I/O。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;d: 目录文件(directory file)&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;这种文件包含了其他文件的名字以及指向与这些文件有关信息的指针。对一个目录文件具有读权限的任一进程都可以读该目录的内容，但只有内核可以直接写目录文件。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;l: 符号链接文件(symbolic link)&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;这种类型的文件指向另一个文件。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;s: 套接字文件(socket)&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;这种类型的文件用于进程间的网络通信。套接字也可用于在一台宿主机上进程之间的非网络通信。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;b: 块设备文件，二进制文件(block special file)&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;这种为类型的文件提供对设备(如磁盘)带缓冲的访问，每次访问以固定长度为单位进行。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;c: 字符设备文件(character special file)&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;这种类型的文件提供对设备不带缓冲的访问，每次访问长度可变。系统中的所有设备要么是字符特殊文件，要么是块特殊文件。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;p: 命名管道文件(FIFO)&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;这种类型的文件用于进程间通信，有时被称为命名管道(named pipe)。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;-: 普通文件(regular file)&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;这是最常用的文件类型，这种文件包含了某种形式的数据。至于这种数据是文本还是二进制数据，对于UNIX内核而言并无区别。对普通文件内容的解释由处理该文件的应用程序进行。&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;一个值得注意的例外是二进制可执行文件。为了执行程序，内核必须理解其格式。所有二进制可执行文件都遵循一种标准化的格式，这种格式使内核能够确定程序文本和数据的加载位置。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&#34;linux网络i-o模型&#34;&gt;Linux网络I/O模型&lt;/h2&gt;

&lt;p&gt;根据UNIX网络编程对I/O模型的分类，UNIX提供了五种I/O模型，服务器会根据自己的类型定位，使用其中一种或者多种I/O模型来处理网络请求。&lt;/p&gt;

&lt;h3 id=&#34;阻塞i-o模型&#34;&gt;阻塞I/O模型&lt;/h3&gt;

&lt;p&gt;最常用的I/O模型就是阻塞I/O模型，缺省情形下，所有文件操作都是阻塞的。我们以套接字借口为例来讲解此模型：在进程空间中调用recvfrom，其系统调用直到数据包到达且被复制到应用进程的缓冲区中或者发生错误时才返回，在此期间一直会等待，进程在从调用recvfrom开始到它返回的整段时间内都是被阻塞的，因此被称为阻塞I/O模型，如图1-1所示：&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://olno3yiqc.bkt.clouddn.com/blog/img/block-io.png&#34; alt=&#34;阻塞I/O模型&#34; /&gt;&lt;/p&gt;

&lt;h3 id=&#34;非阻塞i-o模型&#34;&gt;非阻塞I/O模型&lt;/h3&gt;

&lt;p&gt;recvfrom从应用层到内核的时候，如果该缓冲区没有数据的话，就直接返回一个EWORLDBLOCK错误，一般都对非阻塞I/O模型进行轮询检查这个状态，看内核是不是有数据到来，如图1-2所示：&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://olno3yiqc.bkt.clouddn.com/blog/img/non-block-io.png&#34; alt=&#34;非阻塞I/O模型&#34; /&gt;&lt;/p&gt;

&lt;h3 id=&#34;i-o复用模型&#34;&gt;I/O复用模型&lt;/h3&gt;

&lt;p&gt;Linux提供select/poll，进程通过将一个或者多个fd传递给select或者poll系统调用，阻塞在select操作上，这样select/poll可以帮我们侦测多个fd是否处于就绪状态。select/poll是顺序扫描fd是否就绪，而且支持的fd数量有限，因此它的使用受到了一些制约。&lt;/p&gt;

&lt;p&gt;Linux还提供了一个epoll系统调用，epoll使用基于事件驱动方法代替顺序扫描，因此性能更高。当有fd就绪时，立即回调函数rollback，如图1-3所示：&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://olno3yiqc.bkt.clouddn.com/blog/img/selector-io.png&#34; alt=&#34;I/O复用模型&#34; /&gt;&lt;/p&gt;

&lt;h3 id=&#34;信号驱动i-o模型&#34;&gt;信号驱动I/O模型&lt;/h3&gt;

&lt;p&gt;首先开启套接字接口信号驱动I/O功能，并通过系统调用sigaction执行一个信号处理函数(此系统调用立即返回，进程继续工作，它是非阻塞的)。当数据准备就绪时，就为该进程生成一个SIGIO信号，通过信号回调通知应用程序调用recvfrom来读取数据，并通知主循环函数处理数据，如图1-4所示：&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://olno3yiqc.bkt.clouddn.com/blog/img/signal-io.png&#34; alt=&#34;信号驱动I/O模型&#34; /&gt;&lt;/p&gt;

&lt;h3 id=&#34;异步i-o模型&#34;&gt;异步I/O模型&lt;/h3&gt;

&lt;p&gt;告知内核启动某个操作，并让内核在整个操作完成后（包括将数据从内核复制到用户自己的缓冲区）通知我们。这种模型与信号驱动模型的主要区别是：信号驱动I/O由内核通过我们何时可以开始一个I/O操作；异步I/O模型由内核通知我们I/O操作何时已经完成，如图1-5所示：&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://olno3yiqc.bkt.clouddn.com/blog/img/aio-io.png&#34; alt=&#34;异步I/O模型&#34; /&gt;&lt;/p&gt;

&lt;h2 id=&#34;常用服务器&#34;&gt;常用服务器&lt;/h2&gt;

&lt;p&gt;目前流行的服务器大致分为普通应用服务器和高性能服务器两种。&lt;/p&gt;

&lt;p&gt;应用服务器通常会运行具体的业务代码，比如：订单交易，网站管理等。这些业务通常使用基于MVC模式的框架，并进行数据库操作。应用服务器往往跟编程语言和应用框架绑定，提供上下文管理能力，单次业务的处理时间比较长，业务逻辑比较复杂。因此，应用服务器往往采用阻塞式I/O模型或者非阻塞I/O模型。基于请求/响应的方式工作。&lt;/p&gt;

&lt;p&gt;高性能服务器往往需要面对极高的并发网络连接，并对内存分配、CPU使用提出更加苛刻的要求，比如：适用于反向代理的负载均衡服务器Nignx。因此，高性能服务器往往采用I/O复用模型或信号驱动I/O模型，有些对性能要求更高得服务器会采用纯异步I/O模型。相比较请求/响应的工作方式，使用后面三种I/O模型的服务器的处理方式更多样，也更复杂。&lt;/p&gt;

&lt;h3 id=&#34;使用阻塞i-o模型或非阻塞i-o模型的服务器&#34;&gt;使用阻塞I/O模型或非阻塞I/O模型的服务器&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;Apache&lt;/li&gt;
&lt;li&gt;Tomcat&lt;/li&gt;
&lt;li&gt;Resin&lt;/li&gt;
&lt;li&gt;Caddy&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;使用多路复用i-o模型的服务器&#34;&gt;使用多路复用I/O模型的服务器&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;Nginx&lt;/li&gt;
&lt;li&gt;Netty&lt;/li&gt;
&lt;li&gt;Mina&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;参考资料&#34;&gt;参考资料&lt;/h2&gt;

&lt;p&gt;1, 《Netty权威指南 第二版》，李林峰&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Paxos协议整理</title>
      <link>http://nituchao.com/post/2017/paxos-protocol/</link>
      <pubDate>Wed, 15 Feb 2017 10:13:27 +0800</pubDate>
      
      <guid>http://nituchao.com/post/2017/paxos-protocol/</guid>
      <description>

&lt;p&gt;Paxos是一种提高分布式系统容错性的一致性算法。&lt;/p&gt;

&lt;p&gt;其算法描述如下：&lt;/p&gt;

&lt;h2 id=&#34;阶段一&#34;&gt;阶段一&lt;/h2&gt;

&lt;p&gt;1，Proposer选择一个提案编号Mn，然后向Acceptor的某个超过半数的子集成员发送编号为Mn的Prepare请求。&lt;/p&gt;

&lt;p&gt;2，如果一个Acceptor收到一个编号为Mn的Prepare请求，且编号Mn大于该Acctpor已经响应的所有Prepare请求的编号，那么它就会将它已经批准过的最大编号的提案作为响应反馈给Proposer，同时该Acceptor会承诺不会再批准任何编号小于Mn的提案。&lt;/p&gt;

&lt;p&gt;举个例子来说，假定一个Acceptor已经响应过的所有Prepare请求对应的提案编号分别为1、2、&amp;hellip;、5和7，那么该Acceptor在接收一个编号为8的Prepare请求后，就会将编号为7的提案作为响应反馈给Proposer。&lt;/p&gt;

&lt;h2 id=&#34;阶段二&#34;&gt;阶段二&lt;/h2&gt;

&lt;p&gt;1，如果Proposer收到来自半数以上的Acceptor对于其发出的编号为Mn的Prepare请求的响应，那么它就会发送一个针对[Mn, Vn]提案的Accept请求给Acceptor。注意，Vn的值就是收到的响应中编号最大的提案的值，如果响应中不包含任何提案，那么它就是任意值。&lt;/p&gt;

&lt;p&gt;2，如果Acceptor收到这个针对[Mn, Vn]提案的Accept请求，只要改Acceptor尚未对编号大于Mn的Prepare请求作出响应，它就可以通过这个提案。&lt;/p&gt;

&lt;p&gt;当然，在实际运行过程中，每一个Proposer都有可能会产生多个提案，但只要每个Proposer都遵循如何所述的算法运行，就一定能够保证算法执行的正确性。值得一提的是，每个Proposer都可以在任意时刻丢弃一个提案，哪怕针对该提案的请求和响应在提案被丢弃后会到达，但根据Paxos算法的一系列规约，依然可以保证其在提案选定上的正确性。事实上，如果某个Proposer已经在视图生成编号更大的提案，那么丢弃一些就的提案未尝不是一个好的选择。因此，如果一个Acceptor因为已经收到过更大编号的Prepare请求而忽略某个编号更小的Prepare或者Accept请求，那么它也应当通知其对应的Proposer，以便该Proposer也能够将该提案进行丢弃&amp;ndash;这和上面&amp;rdquo;算法优化&amp;rdquo;部分中提到的提案丢弃是一致的。&lt;/p&gt;

&lt;h2 id=&#34;提案的获取&#34;&gt;提案的获取&lt;/h2&gt;

&lt;p&gt;现在，我们再来看看如何让Learner获取提案，大体可以有以下几种方案。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;方案一&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;Learner获取一个已经被选定的提案的前提是，该提案已经被半数以上的Acceptor批准。因此，最简单的做法就是一旦Acceptor批准了一个提案，就将该提案发送给所有的Leaner。&lt;/p&gt;

&lt;p&gt;很显然，这种做法虽然可以让Leaner尽快地获取被选定的提案，但是却需要让每个Acceptor与所有的Leaner逐个进行一次通信，通信的次数至少为二者个数的乘积。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;方案二&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;另一种可行的方案是，我们可以让所有的Acceptor将他们对提案的批准情况，统一发送给一个特定的Leaner(下文中我们将这样的Leaner称为&amp;rdquo;主Leaner&amp;rdquo;)，在不考虑拜占庭将军问题的前提下，我们假定Leaner之间可以通过消息通信来相互感知提案的选定情况。基于这样的前提，当主Leaner被通知一个提案已经被选定时，它会负责通知其他的Leaner。&lt;/p&gt;

&lt;p&gt;这种方案中，Acceptor首先会将得到批准的提案发送给主Learner，再由其同步给其他Leaner，因此较方案一而言，方案二虽然需要多一个步骤才能将提案通知到所有的Leaner，但其通信次数却大大减少了，通常只是Acceptor和Learner的个数总和。但同时，该方案引入了一个新的不稳定因素：主Learner随时可能出现故障。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;方案三&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;在讲解方案二的时候，我们提到，方案二最大的问题在于主Learner存在单点问题，即主Learner随时可能出现故障。因此，对方案二进行改进，可以将主Learner的范围扩大，即Acceptor可以将批准的提案发送给一个特定的Learner集合，该集合中的每个Learner都可以在一个提案被选定后通知所有其他的Learner。这个Learner集合中的Learner个数越多，可靠性就越好，但同时网络通信的复杂度也就越高。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>3PC协议整理</title>
      <link>http://nituchao.com/post/2017/three-phase-commit-protocol/</link>
      <pubDate>Wed, 15 Feb 2017 10:12:58 +0800</pubDate>
      
      <guid>http://nituchao.com/post/2017/three-phase-commit-protocol/</guid>
      <description>

&lt;p&gt;3PC，是Three-Phase Commit的缩写，即三阶段提交，是2PC的改进版，其将二阶段提交协议的&amp;rdquo;提交事务请求&amp;rdquo;过程一分为二，形成了由CanCommit、PreCommit和doCommit三个阶段组成的事务处理协议。&lt;/p&gt;

&lt;h2 id=&#34;阶段一-cancommit&#34;&gt;阶段一：CanCommit&lt;/h2&gt;

&lt;p&gt;1，事务询问&lt;/p&gt;

&lt;p&gt;协调者向所有的参与者发送一个包含事务内容的canCommit请求，询问是否可以执行事务提交操作，并开始等待个参与者的响应。&lt;/p&gt;

&lt;p&gt;2，各参与者向协调者反馈事务询问的响应&lt;/p&gt;

&lt;p&gt;参与者在接收到来自协调者的canCommit请求后，正常情况下，如果其自身认为可以顺利执行事务，那么会反馈Yes响应，并进入预备状态，否则反馈No响应。&lt;/p&gt;

&lt;h2 id=&#34;阶段二-precommit&#34;&gt;阶段二：PreCommit&lt;/h2&gt;

&lt;p&gt;在阶段二中，协调者会根据各参与者的反馈情况来决定是否可以进行事务的PreCommit操作，正常情况下，包含两种可能。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;执行事务预提交&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;假设协调者从所有的参与者获得的反馈都是Yes响应，那么就会执行事务预提交。&lt;/p&gt;

&lt;p&gt;1，发送预提交请求&lt;/p&gt;

&lt;p&gt;协调者向所有参与者节点发出preCommit的请求，并进入Prepared阶段。&lt;/p&gt;

&lt;p&gt;2，事务预提交&lt;/p&gt;

&lt;p&gt;参与者接收到preCommit请求后，会执行事务操作，并将Undo和Redo信息记录到事务日志中。&lt;/p&gt;

&lt;p&gt;3，各参与者向协调者反馈事务执行的响应&lt;/p&gt;

&lt;p&gt;如果参与者成功执行事务操作，那么就会反馈给协调者Ack响应，同时等待最终的指令：提交(commit)或终止(abort)。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;中断事务&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;假如任何一个参与者向协调者反馈了No响应，或者在等待超时之后，协调者尚无法接收到所有参与者的反馈响应，那么就会中断事务。&lt;/p&gt;

&lt;p&gt;1，发送中断请求&lt;/p&gt;

&lt;p&gt;协调者向所有参与者节点发出abort请求。&lt;/p&gt;

&lt;p&gt;2，中断事务&lt;/p&gt;

&lt;p&gt;无论是收到来自协调者的abort请求，或者是在等待协调者过程中出现超时，参与者都会中断事务。&lt;/p&gt;

&lt;h2 id=&#34;阶段三-docommit&#34;&gt;阶段三：doCommit&lt;/h2&gt;

&lt;p&gt;该阶段将进行真正的事务提交，会存在以下两种可能的情况。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;执行提交&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;1，发送提交请求&lt;/p&gt;

&lt;p&gt;进入这一阶段，假设协调者处于正常工作状态，并且它接收到了来自所有参与者的Ack响应，那么它将从&amp;rdquo;预提交&amp;rdquo;状态转换到&amp;rdquo;提交&amp;rdquo;状态，并向所有的参与者发送doCommit请求。&lt;/p&gt;

&lt;p&gt;2，事务提交&lt;/p&gt;

&lt;p&gt;参与者接收到doCommit请求后，会正式执行事务提交操作，并在完成提交之后释放在整个事务执行期间占用的事务资源。&lt;/p&gt;

&lt;p&gt;3，反馈事务提交结果&lt;/p&gt;

&lt;p&gt;参与者在完成事务提交之后，相协调者发送Ack消息。&lt;/p&gt;

&lt;p&gt;4，完成事务&lt;/p&gt;

&lt;p&gt;协调者接收到所有参与者反馈的Ack消息后，完成事务。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;中断事务&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;进入这一阶段，假设协调者处于正常工作状态，并且有任意一个参与者向协调者反馈了No响应，或者在等待超时之后，协调者尚无法接收到所有参与者的反馈响应，那么就会中断事务。&lt;/p&gt;

&lt;p&gt;1，发送中断请求。&lt;/p&gt;

&lt;p&gt;协调者向所有的参与者节点发送abort请求。&lt;/p&gt;

&lt;p&gt;2，事务回滚。&lt;/p&gt;

&lt;p&gt;参与者接收到abort请求后，会利用其在阶段二中记录的Undo信息来执行事务回滚操作，并在完成回滚之后释放在整个事务执行期间占用的资源。&lt;/p&gt;

&lt;p&gt;3，反馈事务回滚结果。&lt;/p&gt;

&lt;p&gt;参与者在完成事务回滚之后，向协调者发送Ack消息。&lt;/p&gt;

&lt;p&gt;4，中断事务。&lt;/p&gt;

&lt;p&gt;协调者接收到所有参与者反馈的Ack消息后，中断事务。&lt;/p&gt;

&lt;p&gt;需要注意的是，一旦进入阶段三，可能会存在以下两种故障：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;协调者出现问题&lt;/li&gt;
&lt;li&gt;协调者和参与者之间的网络出现故障。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;无论出现哪种情况，最终都会导致参与者无法及时接收老子协调者的doCommit或者abort请求，针对这样的异常情况，&lt;code&gt;参与者都会在等待超时之后，继续进行事务提交。&lt;/code&gt;&lt;/p&gt;

&lt;h2 id=&#34;优缺点&#34;&gt;优缺点&lt;/h2&gt;

&lt;p&gt;三阶段提交协议的优点：相较于二阶段提交协议，三阶段提交协议最大的优点就是降低了参与者的阻塞范围，并且能够出现单点故障后继续达成一致。&lt;/p&gt;

&lt;p&gt;三阶段提交协议的缺点：三阶段提交协议在去除阻塞的同时也引入了新的问题，那就是在参与者接收到preCommit消息后，如果网络出现分区，此时协调者所在的节点和参与者无法进行正常的网络通信，在这种情况下，该参与者依然会进行事务的提交，这必然出现数据不一致性。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>2PC协议整理</title>
      <link>http://nituchao.com/post/2017/two-phase-commit-protocol/</link>
      <pubDate>Wed, 15 Feb 2017 10:12:41 +0800</pubDate>
      
      <guid>http://nituchao.com/post/2017/two-phase-commit-protocol/</guid>
      <description>

&lt;p&gt;2PC，是Two-Phase Commit的缩写，即二阶段提交，是计算机网络尤其是在数据库领域内，为了使基于分布式系统架构下的所有节点在进行事务处理的过程中能够保持原子性和一致性而设计的一种算法。通常，二阶段提交协议也被认为是一种一致性协议，用来保证分布式系统数据的一致性。目前，绝大部分的关系型数据库都是采用二阶段提交协议来完成分布式事务处理的，利用该协议能够非常方便地完成所有分布式事务参与者的协调，统一决定事务的提交或回滚，从而能够有效地保证分布式数据一致性，因此二阶段提交协议被广泛地应用在许多分布式系统中。&lt;/p&gt;

&lt;h2 id=&#34;协议说明&#34;&gt;协议说明&lt;/h2&gt;

&lt;p&gt;顾名思义，二阶段提交协议是将事务的提交过程分成了两个阶段来进行处理，其执行流程如下：&lt;/p&gt;

&lt;h3 id=&#34;阶段一-提交事务请求&#34;&gt;阶段一：提交事务请求&lt;/h3&gt;

&lt;p&gt;1，事务询问&lt;/p&gt;

&lt;p&gt;协调者向所有的参与者发送事务内容，询问是否可以执行事务提交操作，并开始等待各参与者的响应。&lt;/p&gt;

&lt;p&gt;2，执行事务&lt;/p&gt;

&lt;p&gt;各参与者节点执行事务操作，并将Undo和Redo信息记入事务日志中。&lt;/p&gt;

&lt;p&gt;3，各参与者向协调者反馈事务询问的响应。&lt;/p&gt;

&lt;p&gt;如果参与者成功执行了事务操作，那么就反馈给协调者Yes响应，表示事务可以执行；如果参与者没有成功执行事务，那么就反馈给协调者No响应，表示事务不可以执行。&lt;/p&gt;

&lt;p&gt;由于上面讲述的内容在形式上近似是协调者组织各参与者对一次事务操作的投标表态过程，因此二阶段提交协议的阶段一也被称为&amp;rdquo;投票阶段&amp;rdquo;，即各参与者投票表明是否要继续执行接下去的事务操作。&lt;/p&gt;

&lt;h3 id=&#34;阶段二-执行事务提交&#34;&gt;阶段二：执行事务提交&lt;/h3&gt;

&lt;p&gt;在阶段二，协调者会根据各参与者的反馈情况来决定最终是否可以进行事务提交操作，正常情况下，包含以下两种可能。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;执行事务提交&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;加入协调者从所有的参与者获得的反馈都是Yes响应，那么就会执行事务提交。&lt;/p&gt;

&lt;p&gt;1，发送提交请求。&lt;/p&gt;

&lt;p&gt;协调者向所有参与者节点发出Commit请求。&lt;/p&gt;

&lt;p&gt;2，事务提交。&lt;/p&gt;

&lt;p&gt;参与者接收到Commit请求后，会正式执行事务提交操作，并在完成提交之后释放在整个事务执行期间占用的事务资源。&lt;/p&gt;

&lt;p&gt;3，反馈事务提交结果。&lt;/p&gt;

&lt;p&gt;参与者在完成事务提交之后，向协调者发送Ack消息。&lt;/p&gt;

&lt;p&gt;4，完成事务。&lt;/p&gt;

&lt;p&gt;协调者收到所有参与者反馈的Ack消息后，完成事务。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;中断事务&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;假如任何一个参与者向协调者反馈了No响应，或者在等待超时之后，协调者尚无法接收到所有参与者的反馈响应，那么就会中断事务。&lt;/p&gt;

&lt;p&gt;1，发送回滚请求&lt;/p&gt;

&lt;p&gt;协调者向所有参与者节点发出Rollback请求。&lt;/p&gt;

&lt;p&gt;2，事务回滚&lt;/p&gt;

&lt;p&gt;参与者接收到Rollback请求后，会利用其在阶段一中记录的Undo信息来执行事务回滚操作，并在完成回滚后释放在整个事务执行期间占用的资源。&lt;/p&gt;

&lt;p&gt;3，反馈事务回滚结果。&lt;/p&gt;

&lt;p&gt;参与者在完成事务回滚之后，向协调者发送Ack消息。&lt;/p&gt;

&lt;p&gt;4，中断事务&lt;/p&gt;

&lt;p&gt;协调者接收到所有参与者反馈的Ack消息后，完成事务中断。&lt;/p&gt;

&lt;p&gt;以上就是二阶段提交过程，前后两个阶段分别进行的处理逻辑。简单地讲，二阶段提交讲一个事务的处理过程分为了投票和执行两个阶段，其核心是对每个事务都采用先尝试后提交的处理方式，因此也可以将二阶段提交看做一个强一致性的算法。&lt;/p&gt;

&lt;h3 id=&#34;优缺点&#34;&gt;优缺点&lt;/h3&gt;

&lt;p&gt;二阶段提交协议的优点：原理简单，实现方便。&lt;/p&gt;

&lt;p&gt;二阶段提交协议的缺点：同步阻塞，单点问题，脑裂，太过保守。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;同步阻塞&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;二阶段提交协议的最明显也是最大的一个问题就是同步阻塞，这会极大地限制分布式系统的性能。在二阶段提交的执行过程中，所有参与该事务操作的逻辑都处于阻塞状态，也就是说，各个参与者在等待其他参与者相应的额过程中，将无法进行其他任何操作。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;单点问题&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;在上面的讲解过程中，相信读者可以看出，协调者的角色在整个二阶段提交协议中起到了非常重要的作用。一旦协调者出现问题，那么整个二阶段提交流程将无法运转，更为严重的是，如果协调者是在阶段二中出现问题的话，那么其他参与者将会一直处于锁定事务资源的状态中，而无法继续完成事务操作。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;数据不一致&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;在二阶段提交协议的阶段二，即执行事务提交的时候，当协调者向所有的参与者发送Commit请求之后，发生了局部网络异常或者是协调者在尚未发送完Commit请求之前自身发生了崩溃，导致最终只有部分参与者收到了Commit请求。于是，这部分收到了Commit请求的参与者就会进行事务的提交，而其他没有收到Commit请求的参与者则无法进行事务提交，于是整个分布式系统便出现了数据不一致的现象。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;太过保守&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;如果协调者指示参与者进行事务提交询问的过程中，参与者出现故障而导致协调者始终无法获取到所有参与者的相应信息的话，这时协调者只能依靠其自身的超时机制来判断是否需要中断事务，这样的策略显得比较保守。换句话说，二阶段提交协议咩有设计较为完善的容错机制，任意一个节点的失败都会导致整个事务的失败。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>MySQL提供的事务控制语句</title>
      <link>http://nituchao.com/post/2017/mysql-shi-wu-kong-zhi-yu-ju/</link>
      <pubDate>Tue, 14 Feb 2017 14:09:01 +0800</pubDate>
      
      <guid>http://nituchao.com/post/2017/mysql-shi-wu-kong-zhi-yu-ju/</guid>
      <description>

&lt;p&gt;在MySQL命令行的默认设置下，事务都是自动提交的，即执行SQL语句后就会马上执行&lt;code&gt;COMMIT&lt;/code&gt;操作。因此要显式地开启一个事务需要使用命令&lt;code&gt;BEGIN&lt;/code&gt;, &lt;code&gt;START TRANSACTION&lt;/code&gt;, 或者执行命令&lt;code&gt;SET AUTOCOMMIT=0&lt;/code&gt;, 禁用当前会话的自动提交。&lt;/p&gt;

&lt;p&gt;每个数据库厂商自动提交的设置都会不相同，每个DBA或开发人员需要非常明白这一点，这对之后的SQL编程会有非凡的意义，因此用户不能以之前的经验来判断MySQL数据库的运行方式。&lt;/p&gt;

&lt;p&gt;MySQL为开发者提供了三种类型的事务，分别是扁平化事务，带保存点的事务，链式事务。通过带保存点的事务还可以模拟实现嵌套事务。&lt;/p&gt;

&lt;h3 id=&#34;start-transaction-begin&#34;&gt;START TRANSACTION | BEGIN&lt;/h3&gt;

&lt;p&gt;显式地开启一个事务。&lt;/p&gt;

&lt;h3 id=&#34;commit&#34;&gt;COMMIT&lt;/h3&gt;

&lt;p&gt;要想使用这个语句的最简形式，只需要发出&lt;code&gt;COMMIT&lt;/code&gt;。也可以更详细一点，写为&lt;code&gt;COMMIT WORK&lt;/code&gt;, 不过这两者几乎是等价的。&lt;code&gt;COMMIT&lt;/code&gt;会提交事务，并使得已对数据库做的修改称为永久性的。&lt;/p&gt;

&lt;h3 id=&#34;rollback&#34;&gt;ROLLBACK&lt;/h3&gt;

&lt;p&gt;要想使用这个语句的最简形式，只需要发出&lt;code&gt;ROLLBACK&lt;/code&gt;。同样地，也可以写为&lt;code&gt;ROLLBACK WORK&lt;/code&gt;，但两者几乎是等价的。回滚会结束用户的事务，并撤销正在进行的所有未提交的修改。&lt;/p&gt;

&lt;h3 id=&#34;savepoint-identity&#34;&gt;SAVEPOINT identity&lt;/h3&gt;

&lt;p&gt;&lt;code&gt;SAVEPOINT&lt;/code&gt;允许在事务中创建一个保存点，一个事务中可以有多个&lt;code&gt;SAVEPOINT&lt;/code&gt;。&lt;/p&gt;

&lt;h3 id=&#34;release-savepoint-identity&#34;&gt;RELEASE SAVEPOINT identity&lt;/h3&gt;

&lt;p&gt;删除一个事务的保存点，当没有一个保存点执行这语句时，会抛出一个异常。&lt;/p&gt;

&lt;h3 id=&#34;rollback-to-savepoint-identity&#34;&gt;ROLLBACK TO [SAVEPOINT] identity&lt;/h3&gt;

&lt;p&gt;这个语句与&lt;code&gt;SAVEPOINT&lt;/code&gt;命令一起使用。可以把事务回滚到标记点，而不回滚在此标记点之前的任何工作。&lt;/p&gt;

&lt;p&gt;例如，可以发出两调&lt;code&gt;UPDATE&lt;/code&gt;语句，后面跟一个&lt;code&gt;SAVEPOINT&lt;/code&gt;, 然后又是两条&lt;code&gt;DELETE&lt;/code&gt;语句。如果执行&lt;code&gt;DELETE&lt;/code&gt;语句期间出现了某种异常情况，并且捕获到这个异常，同时发出了&lt;code&gt;ROLLBACK TO SAVEPOINT&lt;/code&gt;命令，事务就会回滚到指定的SAVEPOINT，撤销&lt;code&gt;DELETE&lt;/code&gt;完成的所有工作，而&lt;code&gt;UPDATE&lt;/code&gt;语句完成的工作不受影响。&lt;/p&gt;

&lt;h3 id=&#34;set-transaction&#34;&gt;SET TRANSACTION&lt;/h3&gt;

&lt;p&gt;这个语句用来设置事务的隔离级别。&lt;/p&gt;

&lt;p&gt;InnoDB存储引擎提供的事务隔离级别有：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;READ UNCOMMITED&lt;/li&gt;
&lt;li&gt;READ COMMITTED&lt;/li&gt;
&lt;li&gt;REPEATABLE READ&lt;/li&gt;
&lt;li&gt;SERIALIZABLE&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;code&gt;START TRANSACTION&lt;/code&gt;, &lt;code&gt;BEGIN&lt;/code&gt;语句都可以在MySQL命令行下显示地开启一个事务。但是在存储过程中，MySQL数据库的分析器会自动将BEGIN识别为BEGIN&amp;hellip;END, 因此在存储过程中只能使用&lt;code&gt;START TRANSACTION&lt;/code&gt;语句来开启一个事务。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;COMMIT&lt;/code&gt;和&lt;code&gt;COMMIT WORK&lt;/code&gt;语句基本是一致的，都是用来提交事务。不同之处在于&lt;code&gt;COMMIT WORK&lt;/code&gt;用来控制事务结束后的行为是&lt;code&gt;CHAIN&lt;/code&gt;还是&lt;code&gt;RELEASE&lt;/code&gt;的。如果是&lt;code&gt;CHAIN&lt;/code&gt;方式，那么事务就变成了链事务。&lt;/p&gt;

&lt;p&gt;用户可以通过参数&lt;code&gt;completion_type&lt;/code&gt;来进行控制，该参数默认为0，表示没有任何操作。&lt;/p&gt;

&lt;p&gt;当参数&lt;code&gt;completion_type&lt;/code&gt;的值为1时，&lt;code&gt;COMMIT WORK&lt;/code&gt;等同于&lt;code&gt;COMMIT AND CHAIN&lt;/code&gt;, 表示马上自动开启一个相同隔离级别的事务。&lt;/p&gt;

&lt;p&gt;当参数&lt;code&gt;completion_type&lt;/code&gt;的值为2时，&lt;code&gt;COMMIT WORK&lt;/code&gt;等同于&lt;code&gt;COMMIT AND RELEASE&lt;/code&gt;, 在事务提交后会自动断开与服务器的连接。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>JVM调试相关的配置参数</title>
      <link>http://nituchao.com/post/2016/jvm-tiao-shi-xiang-guan-de-pei-zhi-can-shu/</link>
      <pubDate>Thu, 29 Dec 2016 20:15:12 +0800</pubDate>
      
      <guid>http://nituchao.com/post/2016/jvm-tiao-shi-xiang-guan-de-pei-zhi-can-shu/</guid>
      <description>&lt;p&gt;本文将详细分析JVM配置参数中，与调试相关的配置参数，这些配置参数将方便开发人员跟踪JVM运行，查看JVM日志等相关工作。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>JVM行为相关的配置参数</title>
      <link>http://nituchao.com/post/2016/jvm-xing-wei-xiang-guan-de-pei-zhi-can-shu/</link>
      <pubDate>Thu, 29 Dec 2016 13:53:12 +0800</pubDate>
      
      <guid>http://nituchao.com/post/2016/jvm-xing-wei-xiang-guan-de-pei-zhi-can-shu/</guid>
      <description>&lt;p&gt;文本将分析与JVM行为相关的配置参数。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>JVM G1收集器配置参数</title>
      <link>http://nituchao.com/post/2016/jvm-g1-shou-ji-qi-pei-zhi-can-shu/</link>
      <pubDate>Thu, 29 Dec 2016 12:22:12 +0800</pubDate>
      
      <guid>http://nituchao.com/post/2016/jvm-g1-shou-ji-qi-pei-zhi-can-shu/</guid>
      <description>&lt;p&gt;G1收集器配置参数&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>JVM常用的非标准配置参数</title>
      <link>http://nituchao.com/post/2016/jvm-chan-yong-de-fei-biao-zhun-pei-zhi-can-shu/</link>
      <pubDate>Thu, 29 Dec 2016 10:18:12 +0800</pubDate>
      
      <guid>http://nituchao.com/post/2016/jvm-chan-yong-de-fei-biao-zhun-pei-zhi-can-shu/</guid>
      <description>&lt;p&gt;本文将研究JVM常见常见的非标准配置参数。&lt;/p&gt;
</description>
    </item>
    
  </channel>
</rss>