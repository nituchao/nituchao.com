<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Posts on 泥土巢</title>
    <link>http://nituchao.com/post/index.xml</link>
    <description>Recent content in Posts on 泥土巢</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh-CN</language>
    <copyright>Copyright (c) 2017, nituchao | All rights reserved.</copyright>
    <lastBuildDate>Mon, 06 Mar 2017 09:34:07 +0800</lastBuildDate>
    <atom:link href="http://nituchao.com/post/index.xml" rel="self" type="application/rss+xml" />
    
    <item>
      <title>YourKit远程连接线上服务器</title>
      <link>http://nituchao.com/post/2017/your-kit-yuan-cheng-lian-jie-xian-shang-fu-wu/</link>
      <pubDate>Mon, 06 Mar 2017 09:34:07 +0800</pubDate>
      
      <guid>http://nituchao.com/post/2017/your-kit-yuan-cheng-lian-jie-xian-shang-fu-wu/</guid>
      <description>

&lt;p&gt;YourKit是一款业内领先的性能分析工具，目前支持Java和.NET两个平台。该工具功能全面强悍，能通过本地连接或者远程连接的方式，对各种服务器，框架，平台的性能进行分析，并提供了多种由浅入深，针对开发环境或者生产环境的分析模式。该工具提供了高效的图形化显示方式，动动鼠标就可以对系统进行显微镜式的观察分析。&lt;/p&gt;

&lt;p&gt;通过YourKit可以对以下内容进行分析：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;CPU profiling - investigate performace issues&lt;/li&gt;
&lt;li&gt;Memory profiling - memory leaks, usage, GC&lt;/li&gt;
&lt;li&gt;Threads and synchronization&lt;/li&gt;
&lt;li&gt;Exception profiling&lt;/li&gt;
&lt;li&gt;Web, Database, I/O&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;本文想总结一下，YourKit提供的两种连接到Java进程的方式，一种是attach方式，另一种是integrate方式。&lt;/p&gt;

&lt;h2 id=&#34;通过attach方式连接到远程服务器&#34;&gt;通过attach方式连接到远程服务器&lt;/h2&gt;

&lt;p&gt;在控制台，attach方式可以通过进程号，连接到运行中的任何Java进程中，这种方式并不保证总能连接成功，而且会禁用某些分析功能。&lt;/p&gt;

&lt;h4 id=&#34;线上环境&#34;&gt;线上环境&lt;/h4&gt;

&lt;ul&gt;
&lt;li&gt;CentOS release 6.3 64-Bit&lt;/li&gt;
&lt;li&gt;Java 1.7.0_79 HotSpot&amp;trade; 64-Bit Server VM&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&#34;下载安装包&#34;&gt;下载安装包&lt;/h4&gt;

&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;# wget https://www.yourkit.com/download/yjp-2017.02-b53.zip
# unzip yjp-2017.02-b53.zip
# cd yjp-2017.02
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;确定服务进程号&#34;&gt;确定服务进程号&lt;/h4&gt;

&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;# jps
2230 Resin
3959 Jps
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;console连接进程&#34;&gt;Console连接进程&lt;/h4&gt;

&lt;p&gt;通过下面的命令来连接到Java进程。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;# bin/yjp.sh -attach
[YourKit Java Profiler 2017.02-b53] Log file: /root/.yjp/log/yjp-4473.log
Running JVMs:

Name                             |   PID| Status
-------------------------------- |------|--------------------------------
Resin                            | 11760| Ready for attach
ThriftMain                       |  2934| Ready for attach
Resin                            |  2230| Agent already loaded, agent port is 10001
Resin                            | 14232| Ready for attach
Resin                            |  3657| Ready for attach
WatchdogManager                  | 16411| Ready for attach

Enter PID of the application you want to attach (0 to exit) and press Enter:
&amp;gt;2230
Please specify comma-separated list of startup options, or press Enter for default options (recommended):
&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;上面的操作执行完成后，会出现如下提示，表示YourKit Console服务已经成功运行，并在10001开始工作。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;Attaching to process 2230 using default options
[YourKit Java Profiler 2017.02-b53] Log file: /root/.yjp/log/yjp-30209.log
The profiler agent has attached. Waiting while it initializes...
The agent is loaded and is listening on port 10001.
You can connect to it from the profiler UI.
# lsof -i:10001
COMMAND  PID USER   FD   TYPE    DEVICE SIZE/OFF NODE NAME
java    2230 root   72u  IPv4 199000044      0t0  TCP *:scp-config (LISTEN)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;在浏览器，通过ip:port的方式，可以看到YourKit的运行概况。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://olno3yiqc.bkt.clouddn.com/blog/img/your-kit-attach.png&#34; alt=&#34;YourKit Attach&#34; /&gt;&lt;/p&gt;

&lt;h4 id=&#34;yourkit-ui连接远程服务&#34;&gt;YourKit UI连接远程服务&lt;/h4&gt;

&lt;p&gt;打开YourKit UI，点击Connect to remote application，输入IP:PORT进行连接。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://olno3yiqc.bkt.clouddn.com/blog/img/yourkit-connect-attach.png&#34; alt=&#34;YourKit Connect&#34; /&gt;&lt;/p&gt;

&lt;p&gt;连接成功后，进行性能分析界面，大功告成。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://olno3yiqc.bkt.clouddn.com/blog/img/yourkit-home-attach.png&#34; alt=&#34;YourKit性能分析界面&#34; /&gt;&lt;/p&gt;

&lt;h4 id=&#34;疑难问题&#34;&gt;疑难问题&lt;/h4&gt;

&lt;p&gt;通过attach方式并不总能连接到Java进程，常常会出现JVM无响应的问题，控制台报错如下：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;Attaching to process 31833 using options
com.yourkit.util.bf: com.sun.tools.attach.AttachNotSupportedException: Unable to open socket file: target process not responding or HotSpot VM not loaded
	at com.yourkit.b.f.a(a:128)
	at com.yourkit.b.c.attach(a:1)
	at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)
	at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.lang.reflect.Method.invoke(Method.java:498)
	at com.yourkit.h.run(a:17)

Attach to a running JVM failed.

Solution: start JVM with the profiler agent instead of attaching it to a running JVM:
https://www.yourkit.com/docs/java/help/running_with_profiler.jsp
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;因此，分析本地Java进程时可以选择attach方式，对于远程服务，还是推荐integrate方式。&lt;/p&gt;

&lt;h2 id=&#34;通过integrate方式连接到远程服务器-重点推荐&#34;&gt;通过integrate方式连接到远程服务器（重点推荐）&lt;/h2&gt;

&lt;p&gt;integrate方式通过修服务器启动配置文件，随服务启动，这种方式比较稳定，而且能够全面启用YourKit的所有功能。&lt;/p&gt;

&lt;h4 id=&#34;线上环境-1&#34;&gt;线上环境&lt;/h4&gt;

&lt;ul&gt;
&lt;li&gt;CentOS release 6.3 64-Bit&lt;/li&gt;
&lt;li&gt;Java 1.7.0_79 HotSpot&amp;trade; 64-Bit Server VM&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&#34;下载安装包-1&#34;&gt;下载安装包&lt;/h4&gt;

&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;# wget https://www.yourkit.com/download/yjp-2017.02-b53.zip
# unzip yjp-2017.02-b53.zip
# cd yjp-2017.02
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;确定服务进程号-1&#34;&gt;确定服务进程号&lt;/h4&gt;

&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;# jps
2230 Resin
3959 Jps
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;console连接进程-1&#34;&gt;Console连接进程&lt;/h4&gt;

&lt;p&gt;通过下面的命令来连接到Java进程。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;# bin/yjp.sh -integrate
Choose server to integrate with:
1) Geronimo
2) GlassFish
3) JBoss / WildFly
4) Jetty
5) JRun 4
6) Resin 3.1/4
7) Tomcat 3–8
8) WebLogic 9 and newer
9) WebSphere Application Server 7 or newer
10) WebSphere Application Server V8.5 Liberty profile
11) Generic server (use if your server is not on the list)
Enter number which corresponds to your server (0 to exit) and press Enter:
&amp;gt;6
Please specify whether the server runs on a 32-bit JVM or a 64-bit JVM.
Hint: If you are not sure what to choose, choose &amp;quot;32-bit JVM&amp;quot;. If with this choice the server does not start with profiling, re-run the integration and choose &amp;quot;64-bit Java&amp;quot; option.
1) 32-bit JVM
2) 64-bit JVM
&amp;gt;2
Resin configuration file (&amp;lt;RESIN_HOME&amp;gt;/conf/resin.xml or &amp;lt;RESIN_HOME&amp;gt;/conf/resin.conf):
&amp;gt;/home/work/bin/miui-sec-adv/resin/conf/resin.xml

Startup options configuration: step 1 of 5
Should option &#39;disablestacktelemetry&#39; be specified?
1) Yes (recommended to minimize profiling overhead in production)
2) No
&amp;gt;2
Startup options configuration: step 2 of 5
Should option &#39;exceptions=disable&#39; be specified?
1) Yes (recommended to minimize profiling overhead in production)
2) No
&amp;gt;1
Startup options configuration: step 3 of 5
Built-in probes:

1) Enabled: recommended for use in DEVELOPMENT; gives high level profiling results, but may add overhead
2) Disabled: recommended for use in PRODUCTION to minimise overhead, or for troubleshooting

Hint: It&#39;s recommended to choose #1 in development and #2 in production.
If choosing #1 makes profiling overhead big or there are startup issues, re-run the integration and choose #2.
&amp;gt;2
Startup options configuration: step 4 of 5
Should option &#39;delay=10000&#39; be specified?
1) Yes (recommended)
2) No
&amp;gt;1
Startup options configuration: step 5 of 5
Please specify comma-separated list of additional startup options, or press Enter for no additional options:
&amp;gt;
A new config file is created:

/home/work/bin/miui-sec-adv/resin/conf/resin_yjp.xml

To profile the server:

1) [Recommended] Backup original &#39;resin.xml&#39;
2) Rename &#39;resin_yjp.xml&#39; to &#39;resin.xml&#39;
3) Start the server
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;上面的操作执行完成后，会在操作中指定的resin配置文件目录生成&lt;code&gt;resin_yjp.xml&lt;/code&gt;文件，接下来将该&lt;code&gt;resin_yjp.xml&lt;/code&gt;重命名为&lt;code&gt;resin.xml&lt;/code&gt;，并启动服务器。正常情况下，YourKit的Console程序便会随着Resin服务器自动启动，可以通过&lt;code&gt;lsof&lt;/code&gt;命令确认一下。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;# lsof -i:10001
COMMAND  PID USER   FD   TYPE     DEVICE SIZE/OFF NODE NAME
java    2389 work    8u  IPv4 3188835745      0t0  TCP *:scp-config (LISTEN)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;同时，可以通过IP:PORT的方式在浏览器中查看YourKit Console服务的概况。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://olno3yiqc.bkt.clouddn.com/blog/img/yourkit-page-integrate.png&#34; alt=&#34;YourKit Page&#34; /&gt;&lt;/p&gt;

&lt;h4 id=&#34;yourkit-ui连接远程服务-1&#34;&gt;YourKit UI连接远程服务&lt;/h4&gt;

&lt;p&gt;打开YourKit UI，点击Connect to remote application，输入IP:PORT进行连接。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://olno3yiqc.bkt.clouddn.com/blog/img/yourkit-ui-connect-integrate.png&#34; alt=&#34;YourKit UI Connect&#34; /&gt;&lt;/p&gt;

&lt;p&gt;连接成功后，进行性能分析界面，大功告成。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://olno3yiqc.bkt.clouddn.com/blog/img/your-kit-home-integrate.png&#34; alt=&#34;YourKit性能分析界面&#34; /&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>在CentOS上安装Rabbitmq集群</title>
      <link>http://nituchao.com/post/2017/centos-an-zhuang-rabbit-cluster/</link>
      <pubDate>Thu, 02 Mar 2017 17:35:54 +0800</pubDate>
      
      <guid>http://nituchao.com/post/2017/centos-an-zhuang-rabbit-cluster/</guid>
      <description>

&lt;h2 id=&#34;系统环境&#34;&gt;系统环境&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;CentOS 7 四台&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;安装包准备&#34;&gt;安装包准备&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;wxBase-2.8.12-1.el6.centos.x86_64.rpm&lt;/li&gt;
&lt;li&gt;wxGTK-2.8.12-1.el6.centos.x86_64.rpm&lt;/li&gt;
&lt;li&gt;wxGTK-gl-2.8.12-1.el6.centos.x86_64.rpm&lt;/li&gt;
&lt;li&gt;esl-erlang_19.2.3~centos~6_amd64.rpm&lt;/li&gt;
&lt;li&gt;otp_src_19.1.tar.gz&lt;/li&gt;
&lt;li&gt;rabbitmq-server-3.6.6-1.el6.noarch.rpm&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;安装erlang环境&#34;&gt;安装Erlang环境&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;# yum localinstall wxBase-2.8.12-1.el6.centos.x86_64.rpm
# yum localinstall wxGTK-2.8.12-1.el6.centos.x86_64.rpm
# yum localinstall wxGTK-gl-2.8.12-1.el6.centos.x86_64.rpm
# yum localinstall esl-erlang_19.2.3~centos~6_amd64.rpm
# yum install build-essential openssl openssl-devel unixODBC unixODBC-devel make gcc gcc-c++ kernel-devel m4 ncurses-devel tk tc
# tar -zxvf otp_src_19.1.tar.gz
# cd otp_src_19.1
# ./configure --prefix=/home/erlang --without-javac
# make &amp;amp;&amp;amp; make install
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;安装完Erlang之后，修改/etc/profile增加&lt;/p&gt;

&lt;p&gt;export PATH=$PATH:/home/erlang/bin&lt;/p&gt;

&lt;p&gt;执行source /etc/profile使得环境变量生效&lt;/p&gt;

&lt;h2 id=&#34;安装rabbitmq&#34;&gt;安装Rabbitmq&lt;/h2&gt;

&lt;h3 id=&#34;安装rabbitmq-1&#34;&gt;安装rabbitmq&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;# rpm --import https://www.rabbitmq.com/rabbitmq-release-signing-key.asc
# rpm --nodeps -Uvh rabbitmq-server-3.6.6-1.noarch.rpm
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;添加开机启动&#34;&gt;添加开机启动&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;# chkconfig rabbitmq-server on
# service rabbitmq-server start
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;开启web管理界面&#34;&gt;开启web管理界面&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;# rabbitmq-plugins enable rabbitmq_management
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;添加用户&#34;&gt;添加用户&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;# rabbitmqctl add_user work workO^m15213
# rabbitmqctl set_user_tags work administrator
# rabbitmqctl set_permissions -p / work &amp;quot;.*&amp;quot;&amp;quot;.*&amp;quot;&amp;quot;.*&amp;quot;
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>jstack命令</title>
      <link>http://nituchao.com/post/2017/tong-guo-jstack-fen-xi/</link>
      <pubDate>Tue, 28 Feb 2017 19:01:58 +0800</pubDate>
      
      <guid>http://nituchao.com/post/2017/tong-guo-jstack-fen-xi/</guid>
      <description>

&lt;p&gt;Java程序在操作系统上是以单进程、多线程的形式运行。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;[work@zc-stage1-miui-sec02 ~]$ jstack
Usage:
    jstack [-l] &amp;lt;pid&amp;gt;
        (to connect to running process)
    jstack -F [-m] [-l] &amp;lt;pid&amp;gt;
        (to connect to a hung process)
    jstack [-m] [-l] &amp;lt;executable&amp;gt; &amp;lt;core&amp;gt;
        (to connect to a core file)
    jstack [-m] [-l] [server_id@]&amp;lt;remote server IP or hostname&amp;gt;
        (to connect to a remote debug server)

Options:
    -F  to force a thread dump. Use when jstack &amp;lt;pid&amp;gt; does not respond (process is hung)
    -m  to print both java and native frames (mixed mode)
    -l  long listing. Prints additional information about locks
    -h or -help to print this help message
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;jstack参数说明&#34;&gt;jstack参数说明&lt;/h2&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;连接到运行中的进程&lt;/p&gt;

&lt;p&gt;&amp;ldquo;jstack pid&amp;rdquo;，pid为进程号，可以通过jps或者top命令查到。&lt;/p&gt;

&lt;p&gt;命令执行成功则堆栈信息打印在控制台，可以通过&amp;rdquo;jstack 7023 &amp;gt; stack.log&amp;rdquo;这种方式将内容输出文件。&lt;/p&gt;

&lt;p&gt;导出的文本中包含线程号，线程号状态，线程调用栈等信息，结合ps命令中查询出的线程号，可以分析出CPU使用率比较高的线程，以及该线程中的调用堆栈，进而可以定位到项目代码。&lt;/p&gt;

&lt;p&gt;```
Thread 1091: (state = BLOCKED)&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;sun.misc.Unsafe.park(boolean, long) @bci=0 (Compiled frame; information may be imprecise)&lt;/li&gt;
&lt;li&gt;java.util.concurrent.locks.LockSupport.park() @bci=5, line=315 (Interpreted frame)&lt;/li&gt;
&lt;li&gt;com.caucho.env.thread2.ResinThread2.park() @bci=29, line=196 (Compiled frame)&lt;/li&gt;
&lt;li&gt;com.caucho.env.thread2.ResinThread2.runTasks() @bci=65, line=147 (Compiled frame)&lt;/li&gt;
&lt;li&gt;com.caucho.env.thread2.ResinThread2.run() @bci=15, line=118 (Interpreted frame)
```&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;Thread 1089: (state = BLOCKED)
    - sun.misc.Unsafe.park(boolean, long) @bci=0 (Compiled frame; information may be imprecise)
    - java.util.concurrent.locks.LockSupport.park() @bci=5, line=315 (Interpreted frame)
    - com.caucho.env.thread2.ResinThread2.park() @bci=29, line=196 (Compiled frame)
    - com.caucho.env.thread2.ResinThread2.runTasks() @bci=65, line=147 (Compiled frame)
    - com.caucho.env.thread2.ResinThread2.run() @bci=15, line=118 (Interpreted frame)&lt;/p&gt;

&lt;p&gt;Thread 1088: (state = IN_NATIVE)
    - java.net.SocketInputStream.socketRead0(java.io.FileDescriptor, byte[], int, int, int) @bci=0 (Compiled frame; information may be imprecise)
    - java.net.SocketInputStream.read(byte[], int, int, int) @bci=79, line=150 (Compiled frame)
    - java.net.SocketInputStream.read(byte[], int, int) @bci=11, line=121 (Compiled frame)
    - java.net.SocketInputStream.read(byte[]) @bci=5, line=107 (Compiled frame)
    - redis.clients.util.RedisInputStream.ensureFill() @bci=20, line=195 (Compiled frame)
    - redis.clients.util.RedisInputStream.readByte() @bci=1, line=40 (Compiled frame)
    - redis.clients.jedis.Protocol.process(redis.clients.util.RedisInputStream) @bci=1, line=141 (Compiled frame)
    - redis.clients.jedis.Protocol.read(redis.clients.util.RedisInputStream) @bci=1, line=205 (Compiled frame)
    - redis.clients.jedis.Connection.readProtocolWithCheckingBroken() @bci=4, line=297 (Compiled frame)
    - redis.clients.jedis.Connection.getBinaryBulkReply() @bci=15, line=216 (Compiled frame)
    - redis.clients.jedis.Connection.getBulkReply() @bci=1, line=205 (Compiled frame)
    - redis.clients.jedis.Jedis.get(java.lang.String) @bci=27, line=101 (Compiled frame)
    - redis.clients.jedis.JedisCluster$3.execute(redis.clients.jedis.Jedis) @bci=5, line=79 (Compiled frame)
    - redis.clients.jedis.JedisCluster$3.execute(redis.clients.jedis.Jedis) @bci=2, line=76 (Compiled frame)
    - redis.clients.jedis.JedisClusterCommand.runWithRetries(byte[], int, boolean, boolean) @bci=78, line=119 (Compiled frame)
    - redis.clients.jedis.JedisClusterCommand.run(java.lang.String) @bci=25, line=30 (Compiled frame)
    - redis.clients.jedis.JedisCluster.get(java.lang.String) @bci=18, line=81 (Compiled frame)
    - com.xiaomi.miui.sec.service.RedisCacheService$14.call(redis.clients.jedis.RedisCluster) @bci=5, line=667 (Compiled frame)
    - com.xiaomi.miui.sec.service.RedisCacheService$14.call(java.lang.Object) @bci=5, line=663 (Compiled frame)
    - com.xiaomi.miui.cache.rediscluster.DefaultRedisClusterCache.get(java.lang.Object, com.xiaomi.miui.cache.rediscluster.RedisClusterCallable) @bci=22, line=68 (Compiled frame)
    - com.xiaomi.miui.sec.service.RedisCacheService.getSettingAdv(java.lang.String, java.lang.String, java.lang.String) @bci=49, line=663 (Compiled frame)
    - com.xiaomi.miui.sec.service.CacheService.getSettingAdv(java.lang.String, java.lang.String, java.lang.String) @bci=7, line=113 (Compiled frame)
    - com.xiaomi.miui.sec.bizLogic.SettingBiz.postHandlerMiCom(net.sf.json.JSONObject, com.xiaomi.miui.sec.thrift.Device, net.paoding.rose.web.Invocation) @bci=55, line=119 (Compiled frame)
    - com.xiaomi.miui.sec.bizLogic.SettingBiz.postHandler(net.sf.json.JSONObject, com.xiaomi.miui.sec.thrift.Device, net.paoding.rose.web.Invocation) @bci=118, line=65 (Compiled frame)
    - com.xiaomi.miui.sec.bizLogic.BasicBiz.mainHandler(net.paoding.rose.web.Invocation) @bci=29, line=59 (Compiled frame)
    - com.xiaomi.miui.sec.controllers.InfoController.setting(net.paoding.rose.web.Invocation, java.lang.String) @bci=73, line=252 (Compiled frame)
    - sun.reflect.GeneratedMethodAccessor31.invoke(java.lang.Object, java.lang.Object[]) @bci=48 (Compiled frame)
    - sun.reflect.DelegatingMethodAccessorImpl.invoke(java.lang.Object, java.lang.Object[]) @bci=6, line=43 (Compiled frame)
    - java.lang.reflect.Method.invoke(java.lang.Object, java.lang.Object[]) @bci=57, line=606 (Compiled frame)&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;
   ​

## jstack分析java线程的CPU使用率和使用时长



## jstack分析分析已有的javacore文件



## jstack连接到远程调试服务器进行分析
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>解决Java进程占用CPU过高的问题</title>
      <link>http://nituchao.com/post/2017/ji-lu-yi-ci-cpu-guo-gao-chu-li/</link>
      <pubDate>Tue, 28 Feb 2017 09:16:18 +0800</pubDate>
      
      <guid>http://nituchao.com/post/2017/ji-lu-yi-ci-cpu-guo-gao-chu-li/</guid>
      <description></description>
    </item>
    
    <item>
      <title>Atomic变量</title>
      <link>http://nituchao.com/post/juc.atomic/atomic-summary/</link>
      <pubDate>Thu, 23 Feb 2017 18:39:27 +0800</pubDate>
      
      <guid>http://nituchao.com/post/juc.atomic/atomic-summary/</guid>
      <description>&lt;p&gt;Java原子变量的诞生源自一个简单的需求 —— 多个线程共享某个变量或者对象时，需要对修改和读取操作进行同步。&lt;/p&gt;

&lt;p&gt;同步包含两层含义：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;互斥访问&lt;/li&gt;
&lt;li&gt;可见性&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;通常，多线程对临界资源的互斥访问通过对象锁(synchronized关键字)保证。对象锁是一种独占锁（悲观锁），会导致其它所有需要锁的线程挂起。而可见性则由volatile的内存语义保证。&lt;/p&gt;

&lt;p&gt;Java 1.5开始提供了原子变量和原子引用，这些类放置在&lt;code&gt;java.util.concurrent&lt;/code&gt;下。大概可以归为4类：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;基本类型：AtomicInteger, AtomicLong, AtomicBoolean;&lt;/li&gt;
&lt;li&gt;数组类型：AtomicIntegerArray, AtomicLongArray, AtomicReferenceArray;&lt;/li&gt;
&lt;li&gt;引用类型：AtomicReference, AtomicStampedReference, AtomicMarkableReference;&lt;/li&gt;
&lt;li&gt;对象的属性修改类型：AtomicIntegerFieldUpdater, AtomicLongFieldUpdater, AtomicReferenceFieldUpdater;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;Java原子变量的存在是为了对相应的数据进行原子操作。&lt;/p&gt;

&lt;p&gt;所谓的原子操作包含下面几层含义：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;操作过程不会被中断。&lt;/li&gt;
&lt;li&gt;操作过程不会被阻塞。&lt;/li&gt;
&lt;li&gt;修改结果被其他线程可见。&lt;/li&gt;
&lt;/ol&gt;
</description>
    </item>
    
    <item>
      <title>Java锁之Unsafe类的理解</title>
      <link>http://nituchao.com/post/juc.lock/java-unsafe/</link>
      <pubDate>Thu, 23 Feb 2017 18:39:27 +0800</pubDate>
      
      <guid>http://nituchao.com/post/juc.lock/java-unsafe/</guid>
      <description>

&lt;h2 id=&#34;一言&#34;&gt;一言&lt;/h2&gt;

&lt;p&gt;&lt;code&gt;sun.misc.Unsafe&lt;/code&gt;类是超越Java的存在，它违反了Java在内存管理上的设计初衷，却又是Java很多重要特性与功能得以实现的基础，它使Java的安全性受到威胁，却有使Java在很多方面的性能得到提升，它是魔鬼与天使的混合体。&lt;/p&gt;

&lt;h2 id=&#34;概述&#34;&gt;概述&lt;/h2&gt;

&lt;p&gt;Java是一个安全的开发工具，它阻止开发人员犯很低级的错误，而大部分的错误都是基于内存管理的。Unsafe类突破了Java原生的内存管理体制，使用Unsafe类可以在系统内存的任意地址进行读写数据，而这些操作对于普通用户来说是非常危险的，Unsafe的操作粒度不是类，而是数据和地址。&lt;/p&gt;

&lt;p&gt;从另一方讲，Java正被广泛应用于游戏服务器和高频率的交易应用。这些之所以能够实现主要归功于Java提供的这个非常便利的类&lt;code&gt;sun.mics.Unsafe&lt;/code&gt;。Unsafe类为了速度，在Java严格的安全标准方法做了一些妥协。&lt;/p&gt;

&lt;p&gt;Java在JUC包中提供了对&lt;code&gt;sun.misc.Unsafe&lt;/code&gt;类的封装实现，这就是&lt;code&gt;java.util.concurrent.LockSupport&lt;/code&gt;。&lt;/p&gt;

&lt;p&gt;本文基于JDK1.7.0_67&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;java version &amp;ldquo;1.7.0&lt;em&gt;67&amp;rdquo;&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;_Java&amp;trade; SE Runtime Environment (build 1.7.0_67-b01)&lt;/p&gt;

&lt;p&gt;Java HotSpot&amp;trade; 64-Bit Server VM (build 24.65-b04, mixed mode)&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&#34;重要函数&#34;&gt;重要函数&lt;/h2&gt;

&lt;p&gt;&lt;code&gt;sun.mics.Unsafe&lt;/code&gt;一共提供了106个函数，这些函数涵盖了以下五个方面的功能：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;对变量和数组内容的原子访问，自定义内存屏障&lt;/li&gt;
&lt;li&gt;对序列化的支持&lt;/li&gt;
&lt;li&gt;自定义内存管理/高效的内存布局&lt;/li&gt;
&lt;li&gt;与原生代码和其他JVM进行互操作&lt;/li&gt;
&lt;li&gt;对高级锁的支持&lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&#34;获取实例&#34;&gt;获取实例&lt;/h3&gt;

&lt;p&gt;&lt;code&gt;sun.misc.Unsafe&lt;/code&gt;只有一个无参的私有构造函数，要想实例化&lt;code&gt;sun.misc.Unsafe&lt;/code&gt;可以调用&lt;code&gt;getUnsafe()&lt;/code&gt;方法。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;@CallerSensitive
public static Unsafe getUnsafe() {
  Class var0 = Reflection.getCallerClass();
  if(var0.getClassLoader() != null) {
    throw new SecurityException(&amp;quot;Unsafe&amp;quot;);
  } else {
    return theUnsafe;
  }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;出于安全考虑，Unsafe类只能被系统类加载器实例化，否则会抛出&lt;code&gt;SecurityException&lt;/code&gt;异常。普通用户如果想实例化&lt;code&gt;sun.misc.Unsafe&lt;/code&gt;类的对象，需要通过类反射机制或者修改Java的安全策略。&lt;/p&gt;

&lt;h3 id=&#34;内存操作&#34;&gt;内存操作&lt;/h3&gt;

&lt;h4 id=&#34;获取成员变量偏移量&#34;&gt;获取成员变量偏移量&lt;/h4&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;// 返回对象中指定静态成员变量的内存偏移量(相对于类存储)
public native long staticFieldOffset(Field f);

// 返回对象中指定成员变量的内存偏移量(相对于对象实例)
public native long objectFieldOffset(Field f);

// 返回对象中指定成员变量
public native Object staticFieldBase(Field f);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;sun.misc.Unsafe&lt;/code&gt;的操作对象是内存数据，获取指定成员变量的内存地址是对其进行操作的第一步。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;objectFieldOffset&lt;/code&gt;是一个本地函数，返回指定静态field的内存地址偏移量，&lt;code&gt;Unsafe&lt;/code&gt;类的其他方法中这个值是被用作一个访问特定field的一个方式。这个值对于给定的field是唯一的，并且后续对该方法的调用都返回相同的值。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;objectFieldOffset&lt;/code&gt;获取到的是内存偏移量，并不是真正的内存指针地址，Unsafe类提供了&lt;code&gt;getAddress&lt;/code&gt;函数将该偏移量转换为真正的内存指针地址，有了该内存指针地址，就可以直接操作内存数据的读写了。&lt;/p&gt;

&lt;h4 id=&#34;操作成员变量数据&#34;&gt;操作成员变量数据&lt;/h4&gt;

&lt;p&gt;有了&lt;code&gt;objectFieldOffset&lt;/code&gt;获取到的内存偏移量，就可以使用Unsafe类对该内存位置的数据进行读写。Unsafe类提供了对所有Java基本数据类型（byte, short, int, long, float, double）和对象类型的读写，这些方法都是本地函数（另外有一些对本地函数进行封装的读写函数，已经被标识为弃用）。&lt;/p&gt;

&lt;p&gt;这些操作可以从另一个层面理解为&lt;code&gt;sun.misc.Unsafe&lt;/code&gt;对序列化和反序列化的支持。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;// o: 对象引用
// offset: 内存偏移量，通过objectFieldOffset获取
public native int getInt(Object o, long offset);
// o: 对象引用
// offset: 内存偏移量，通过objectFieldOffset获取
// x: 新的数据值
public native void putInt(Object o, long offset, int x);
public native Object getObject(Object o, long offset);
public native void putObject(Object o, long offset, Object x);
public native boolean getBoolean(Object o, long offset);
public native void    putBoolean(Object o, long offset, boolean x);
public native byte    getByte(Object o, long offset);
public native void    putByte(Object o, long offset, byte x);
public native short   getShort(Object o, long offset);
public native void    putShort(Object o, long offset, short x);
public native char    getChar(Object o, long offset);
public native void    putChar(Object o, long offset, char x);
public native long    getLong(Object o, long offset);
public native void    putLong(Object o, long offset, long x);
public native float   getFloat(Object o, long offset);
public native void    putFloat(Object o, long offset, float x);
public native double  getDouble(Object o, long offset);
public native void    putDouble(Object o, long offset, double x);

// 获取obj对象中offset地址对应的object型field的值为指定值。
// getObject(Object, long)的volatile版
public native Object getObjectVolatile(Object o, long offset);
// 设置obj对象中offset偏移地址对应的object型field的值为指定值。
// putObject(Object, long, Object)的volatile版
public native void    putObjectVolatile(Object o, long offset, Object x);
public native int     getIntVolatile(Object o, long offset);
public native void    putIntVolatile(Object o, long offset, int x);
public native boolean getBooleanVolatile(Object o, long offset);
public native void    putBooleanVolatile(Object o, long offset, boolean x);
public native byte    getByteVolatile(Object o, long offset);
public native void    putByteVolatile(Object o, long offset, byte x);
public native short   getShortVolatile(Object o, long offset);
public native void    putShortVolatile(Object o, long offset, short x);
public native char    getCharVolatile(Object o, long offset);
public native void    putCharVolatile(Object o, long offset, char x);
public native long    getLongVolatile(Object o, long offset);
public native void    putLongVolatile(Object o, long offset, long x);
public native float   getFloatVolatile(Object o, long offset);
public native void    putFloatVolatile(Object o, long offset, float x);
public native double  getDoubleVolatile(Object o, long offset);
public native void    putDoubleVolatile(Object o, long offset, double x);

// 设置obj对象中offset偏移地址对应的object型field的值为指定值。这是一个有序或者 
// 有延迟的&amp;lt;code&amp;gt;putObjectVolatile&amp;lt;/cdoe&amp;gt;方法，并且不保证值的改变被其他线程立 
// 即看到。只有在field被&amp;lt;code&amp;gt;volatile&amp;lt;/code&amp;gt;修饰并且期望被意外修改的时候 
// 使用才有用。 
// 这个方法在对低延迟代码是很有用的，它能够实现非堵塞的写入，这些写入不会被Java的JIT重新排序指令
// (instruction reordering)，这样它使用快速的存储-存储(store-store) barrier, 而不是较慢
// 的存储-加载(store-load) barrier, 后者总是用在volatile的写操作上，这种性能提升是有代价的，
// 虽然便宜，也就是写后结果并不会被其他线程看到，甚至是自己的线程，通常是几纳秒后被其他线程看到，
// 这个时间比较短，所以代价可以忍受。类似Unsafe.putOrderedObject还有unsafe.putOrderedLong
// 等方法，unsafe.putOrderedLong比使用 volatile long要快3倍左右。.
public native void    putOrderedObject(Object o, long offset, Object x);
public native void    putOrderedInt(Object o, long offset, int x);
public native void    putOrderedLong(Object o, long offset, long x);
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;获取内存指针地址&#34;&gt;获取内存指针地址&lt;/h4&gt;

&lt;p&gt;&lt;code&gt;objectFieldOffset&lt;/code&gt;获取到的是内存偏移量，并不是真正的内存指针地址，Unsafe类提供了&lt;code&gt;getAddress&lt;/code&gt;函数将该偏移量转换为真正的内存指针地址，有了该内存指针地址，就可以直接操作内存数据的读写了。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;// 根据给定的内存偏移量(objectFieldOffset的返回值)，获取真正的内存指针地址。
// 如果给定的内存偏移量为0或者并没有指向一个内存块，返回undefined。
// 如果返回的内存指针地址位宽小于64，用无符号整数进行扩展转换为Java long型。
public native long getAddress(long var1);
// 保存一个内存指针地址到给定的内存偏移量。
// 如过给定的内存偏移量为0或者并没有指向一个内存块，返回undefined。
public native void putAddress(long var1, long var3);

// 返回一个内存指针占用的字节数(bytes)
public native int addressSize();
// 返回一个内存页占用的字节数(bytes)
public native int pageSize();

&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;直接分配内存空间&#34;&gt;直接分配内存空间&lt;/h4&gt;

&lt;p&gt;&lt;code&gt;sun.mics.Unsafe&lt;/code&gt;类允许Java程序使用JVM堆外内存，即操作系统内存。&lt;code&gt;BufferBytes&lt;/code&gt;类也可以分配JVM堆外内存，但是只能使用最大2GB的JVM堆外内存空间，而&lt;code&gt;sun.mics.Unsafe&lt;/code&gt;类没有这个限制。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;// 分配一块大小为var1字节的JVM堆外内存。
// 新分配的内存空间中的内容处于未初始化状态。
// 新分配的内存空间的指针地址不为0，并对所有的值类型做内存对齐。
public native long allocateMemory(long var1);
// 调整JVM堆外内存空间大小。
// 参数var1是待调整的JVM堆外内存空间的指针地址。
// 参数var3是新的JVM堆外内存空间字节大小。
// 如果新空间大小var1=0，则返回指针地址为0.
public native long reallocateMemory(long var1, long var3);
// 释放指定内存指针地址的内存空间。
public native void freeMemory(long var1);
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;直接操作内存类型数据&#34;&gt;直接操作内存类型数据&lt;/h4&gt;

&lt;p&gt;有了&lt;code&gt;addAddress&lt;/code&gt;函数获取到的内存指针地址，就可以直接操作该内存指针地址处的数据了。Unsafe类提供了对所有Java基础数据类型和对象类型的直接内存操作函数。&lt;/p&gt;

&lt;p&gt;下面提供的这些函数，都是按照数据类型对内存数据进行读写。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;// var1: 内存指针地址
public native byte getByte(long var1);
// var1: 内存指针地址
// var3: 新的数据值
public native void putByte(long var1, byte var3);
public native short getShort(long var1);
public native void putShort(long var1, short var3);
public native char getChar(long var1);
public native void putChar(long var1, char var3);
public native int getInt(long var1);
public native void putInt(long var1, int var3);
public native long getLong(long var1);
public native void putLong(long var1, long var3);
public native float getFloat(long var1);
public native void putFloat(long var1, float var3);
public native double getDouble(long var1);
public native void putDouble(long var1, double var3);
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;直接操作内存字节数据&#34;&gt;直接操作内存字节数据&lt;/h4&gt;

&lt;p&gt;有了&lt;code&gt;addAddress&lt;/code&gt;函数获取到的内存指针地址，就可以直接操作该内存指针地址处的数据了。Unsafe类提供了直接按照字节为单位对指定的内存指针地址进行数据操作的函数。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public native void setMemory(Object o, long offset, long bytes, byte value);
public void setMemory(long address, long bytes, byte value) {
  	setMemory(null, address, bytes, value);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;直接复制内存数据&#34;&gt;直接复制内存数据&lt;/h4&gt;

&lt;p&gt;有了&lt;code&gt;addAddress&lt;/code&gt;函数获取到的内存指针地址，还可以直接将一个内存指针地址对应的数据块拷贝到另一个内存指针地址对应的位置。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public native void copyMemory(Object srcBase, long srcOffset,
                              Object destBase, long destOffset,
                              long bytes);
public void copyMemory(long srcAddress, long destAddress, long bytes) {
  	copyMemory(null, srcAddress, null, destAddress, bytes);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;数组操作&#34;&gt;数组操作&lt;/h3&gt;

&lt;p&gt;Unsafe类中有很多以BASE_OFFSET结尾的常量，比如ARRAY_INT_BASE_OFFSET，ARRAY_BYTE_BASE_OFFSET等，这些常量值是通过arrayBaseOffset方法得到的。arrayBaseOffset方法是一个本地方法，可以获取数组第一个元素的偏移地址。&lt;/p&gt;

&lt;p&gt;Unsafe类中还有很多以INDEX_SCALE结尾的常量，比如 ARRAY_INT_INDEX_SCALE ， ARRAY_BYTE_INDEX_SCALE等，这些常量值是通过arrayIndexScale方法得到的。arrayIndexScale方法也是一个本地方法，可以获取数组的转换因子，也就是数组中元素的增量地址。&lt;/p&gt;

&lt;p&gt;将arrayBaseOffset与arrayIndexScale配合使用，可以定位数组中每个元素在内存中的位置。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;// 返回给定数组的第一个元素的内存偏移量
public native int arrayBaseOffset(Class arrayClass);
// 返回给定数组的转换因子，也就是数组中元素的增量地址
public native int arrayIndexScale(Class arrayClass);
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;原子操作&#34;&gt;原子操作&lt;/h3&gt;

&lt;p&gt;&lt;code&gt;sun.misc.Unsafe&lt;/code&gt;类提供了CAS原子操作，能够实现高性能的线程安全的无锁数据结构。&lt;code&gt;sun.misc.Unsafe&lt;/code&gt;类的CAS操作是&lt;code&gt;java.util.concurrent&lt;/code&gt;包的基础，&lt;code&gt;LockSupport&lt;/code&gt;，&lt;code&gt;AbstractQueuedSynchronized&lt;/code&gt;，&lt;code&gt;AtomicInteger&lt;/code&gt;等原子变量和锁框架都基于CAS操作实现的。&lt;/p&gt;

&lt;p&gt;由于CAS操作在执行时当前线程不会被阻塞，所以通常使用自旋锁循环执行，直到操作成功时，表示获取到锁。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;// 当Java对象o的域偏移offset上的值为excepted时，原子地修改为x。
// 如果修改成功，返回true。否则，返回false。
// 操作过程中线程不会阻塞。
public final native boolean compareAndSwapObject(Object o, long offset,
                                                 Object expected,
                                                 Object x);
// 当Java对象o的域偏移offset上的值为int型的excepted时，原子地修改为x。
// 如果修改成功，返回true。否则，返回false。
// 操作过程中线程不会阻塞。
public final native boolean compareAndSwapInt(Object o, long offset,
                                              int expected,
                                              int x);
// 当Java对象o的域偏移offset上的值为int型的excepted时，原子地修改为x。
// 如果修改成功，返回true。否则，返回false。
// 操作过程中线程不会阻塞。
public final native boolean compareAndSwapLong(Object o, long offset,
                                               long expected,
                                               long x);
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;监视器锁&#34;&gt;监视器锁&lt;/h3&gt;

&lt;p&gt;&lt;code&gt;synchronized&lt;/code&gt;是JVM最早提供的锁，称为监视器锁，也称对象锁。获得锁的过程称为monitorEnter，释放锁的过程称为monitorExit，锁的信息保存在对象头里，同步语句会在编译成字节码后转换成监视器语法(monitorEnter和monitorExit)。&lt;code&gt;sun.misc.Unsafe&lt;/code&gt;类提供了监视器的相关操作。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;// 锁住对象
public native void monitorEnter(Object o);
// 尝试锁住对象
public native boolean tryMonitorEnter(Object o);
// 解锁对象
public native void monitorExit(Object o);
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;线程控制&#34;&gt;线程控制&lt;/h3&gt;

&lt;p&gt;在实现&lt;code&gt;java.util.concurrent.AbstractQueued&lt;/code&gt;类，并基于AQS实现整个JUC锁框架的过程中，一方面需要使用&lt;code&gt;sun.misc.Unsafe&lt;/code&gt;类的CAS操作进行锁的获取(标记位state的修改)，另一方在获取锁失败时要把当前线程放入等待队列，并阻塞当前线程。阻塞当前的线程的方法也是&lt;code&gt;sun.misc.Unsafe&lt;/code&gt;类提供的。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;// 阻塞当前线程。
// 直到通过unpark方法解除阻塞，或者线程被中断，或者指定的超时时间到期
// isAbsolute参数是指明时间是绝对的，还是相对的
// time单位是纳秒，如果为0则表示长期阻塞
public native void park(boolean isAbsolute, long time);
// 解除指定线程的阻塞状态。
public native void unpark(Object thread);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;park方法的两个参数里并没有指定要阻塞的线程引用，JVM怎么知道要将哪个线程阻塞？而unpark方法又是如何将一个线程的阻塞状态解除的呢？要真正理解park和unpark的工作原理，需要深入到HotSpot的源码。&lt;/p&gt;

&lt;p&gt;简单的讲，park和unpark本质上是通过HotSpot里的一个volatile共享变量(volatile int _counter)来通信的，当park时，这个变量设置为0，当unpark时，这个变量设置为1。&lt;/p&gt;

&lt;p&gt;由此，我们发现使用park和unpark来对线程进行同步控制非常灵活，unpark甚至可以在park之前调用。park/unpark模型真正实现了线程之间的同步，Java线程之间不再需要一个Object(synchronized代表的对象锁，用对象头存储锁信息)或者其他变量来存储状态(AQS中的state变量)来存储状态，不再需要关心对方的状态。&lt;/p&gt;

&lt;p&gt;对比Java5中提供的wait/notify/notifyAll同步体系。wait/notify机制有个很蛋疼的地方是，比如线程B要用notify通知线程A，那么线程B要确保线程A已经在wait调用上等待了，否则线程A可能永远都在等待。编程的时候就会很蛋疼。&lt;/p&gt;

&lt;p&gt;unpark函数为线程提供“许可(permit)”，线程调用park函数则等待“许可”。这个有点像信号量，但是这个“许可”是不能叠加的，“许可”是一次性的。&lt;/p&gt;

&lt;p&gt;比如线程B连续调用了三次unpark函数，当线程A调用park函数就使用掉这个“许可”，如果线程A再次调用park，则进入等待状态。&lt;/p&gt;

&lt;p&gt;在HotSpot的实现里，每个Java线程都有一个Parker实例，Parker类的定义如下：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;class Parker : public os::PlatformParker {  
private:  
  volatile int _counter ;  
  ...  
public:  
  void park(bool isAbsolute, jlong time);  
  void unpark();  
  ...  
}  
class PlatformParker : public CHeapObj&amp;lt;mtInternal&amp;gt; {  
  protected:  
    pthread_mutex_t _mutex [1] ;  
    pthread_cond_t  _cond  [1] ;  
    ...  
}  
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;异常处理&#34;&gt;异常处理&lt;/h3&gt;

&lt;p&gt;&lt;code&gt;sun.misc.Unsafe&lt;/code&gt;类还提供了抛出异常的能力。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;// 在不通知验证器(verifier)的情况下，抛出异常。
public native void throwException(Throwable ee);
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;对象增强&#34;&gt;对象增强&lt;/h3&gt;

&lt;p&gt;&lt;code&gt;sun.misc.Unsafe&lt;/code&gt;类还提供了一些对类和对象进行操作的函数。通过这些函数，用户可以在绕过虚拟机的情况下进行类的加载、初始化，或者对对象进行实例化。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;// 让虚拟机在不进行安全检查的情况下定义一个类。
// 默认情况下，该类的类加载器和保护域来自调用类。
public native Class defineClass(String name, byte[] b, int off, int len,
                                ClassLoader loader,
                                ProtectionDomain protectionDomain);
public native Class defineClass(String name, byte[] b, int off, int len);

// 在不调用构造函数的情况下，实例化类Class的一个对象
// 如果累Class还没有加载到JVM，则进行加载
public native Object allocateInstance(Class cls)
        throws InstantiationException;

// 定义一个匿名类，该类将不被classloader，或系统目录感知
public native Class defineAnonymousClass(Class hostClass, byte[] data, Object[] cpPatches);

// 确保指定的类已经被初始化(加载到JVM)
public native void ensureClassInitialized(Class c);
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;实例分析&#34;&gt;实例分析&lt;/h2&gt;

&lt;p&gt;本节记录了一些使用&lt;code&gt;sun.misc.Unsafe&lt;/code&gt;的实例，并对这些实例进行分析。&lt;/p&gt;

&lt;h3 id=&#34;实例化私有类&#34;&gt;实例化私有类&lt;/h3&gt;

&lt;p&gt;很多类为了封装的需要将构造函数声明成私有的，防止被实例化。在&lt;code&gt;sun.misc.Unsafe&lt;/code&gt;类面前，这中做法不堪一击。&lt;code&gt;allocateInstance&lt;/code&gt;方法可以在不调用构造函数的情况下，直接实例化类的一个对象。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;import sun.misc.Unsafe;

import java.lang.reflect.Field;

public class UnsafeUser {
    public static void main(String[] args) throws Exception {
        // 由于安全限制，只有系统class loader才能使用getUnsafe()方法
        // 普通用户只能通过反射实例化Unsafe
        Field field = Unsafe.class.getDeclaredField(&amp;quot;theUnsafe&amp;quot;);
        field.setAccessible(true);
        Unsafe unsafe = (Unsafe) field.get(null);

        // 实例化User，不调用构造函数
        User user = (User) unsafe.allocateInstance(User.class);
        user.setName(&amp;quot;liang&amp;quot;);
        System.out.println(user.getName());
    }
}

class User {
    private String name;
    private User() {}
    public String getName() { return name; }
    public void setName(String name) { this.name = name; }
}

// 执行后输出
liang
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;操作对象内存&#34;&gt;操作对象内存&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;import sun.misc.Unsafe;

import java.lang.reflect.Field;

public class UnsafeUser {

    public static void main(String[] args) throws Exception {
        // 由于安全限制，只有系统classloader才能使用getUnsafe()方法
        // 普通用户只能通过反射实例化Unsafe
        Field field = Unsafe.class.getDeclaredField(&amp;quot;theUnsafe&amp;quot;);
        field.setAccessible(true);
        Unsafe unsafe = (Unsafe) field.get(null);

        // 实例化User，不调用构造函数
        User user = (User) unsafe.allocateInstance(User.class);
        user.setName(&amp;quot;liang&amp;quot;);
        user.setAge(28);

        // 输出user对象中各个成员遍历的内存偏移值
        for (Field f : user.getClass().getDeclaredFields()) {
            System.out.println(f.getName() + &amp;quot; 对应的内存偏移地址: &amp;quot; + unsafe.objectFieldOffset(f));
        }

        System.out.println(&amp;quot;---------------------&amp;quot;);

      	// 获取age内存偏移量
        long ageOffset = 
          unsafe.objectFieldOffset(user.getClass().getDeclaredField(&amp;quot;age&amp;quot;));
       	// // 获取name内存偏移量
        long nameOffset = 
          unsafe.objectFieldOffset(user.getClass().getDeclaredField(&amp;quot;name&amp;quot;));

        // 修改age值
        unsafe.putInt(user, ageOffset, 29);
        // 修改name值
        unsafe.putObject(user, nameOffset, &amp;quot;zhang liang&amp;quot;);

        System.out.println(&amp;quot;age: &amp;quot; + user.getAge());
        System.out.println(&amp;quot;name: &amp;quot; + user.getName());
    }
}

class User {
    private int age;
    private String name;
    private User() {}
    public String getName() { return name; }
    public void setName(String name) { this.name = name; }
    public int getAge() { return age; }
    public void setAge(int age) { this.age = age; }
}

// 执行后输出：
age 对应的内存偏移地址: 12
name 对应的内存偏移地址: 16
---------------------
age: 29
name: zhang liang
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;创建超大数组&#34;&gt;创建超大数组&lt;/h3&gt;

&lt;p&gt;Java中数组的最大长度为Integer.MAX_VALUE，正常情况下如果想创建一个大于Integer.MAX_VALUE的数组是做不到的，但是Unsafe可以，通过对内存进行直接分配实现。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public class BigArray {
    public static void main(String[] arg) throws Exception {

        // 由于安全限制，只有系统classloader才能使用getUnsafe()方法
        // 普通用户只能通过反射实例化Unsafe
        Field field = Unsafe.class.getDeclaredField(&amp;quot;theUnsafe&amp;quot;);
        field.setAccessible(true);
        Unsafe unsafe = (Unsafe) field.get(null);

        //只要内存够大，可以把这个调大，大于Integer.MAX_VALUE
        long size = (long) Integer.MAX_VALUE * 2;
        long addr = unsafe.allocateMemory(size);
        System.out.println(&amp;quot;unsafe address :&amp;quot; + addr);

        for (int i = 0; i &amp;lt; size; i++) {
            unsafe.putByte(addr + i, (byte) 6);
            if (unsafe.getByte(addr + i) != 6) {
                System.out.println(&amp;quot;failed at offset&amp;quot;);
            }
        }
    }
}

// 运行结果
unsafe address :4754382848
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;线程挂起与恢复&#34;&gt;线程挂起与恢复&lt;/h3&gt;

&lt;p&gt;将一个线程进行挂起是通过park方法实现的，调用 park后，线程将一直阻塞直到超时或者中断等条件出现。unpark可以终止一个挂起的线程，使其恢复正常。&lt;/p&gt;

&lt;p&gt;整个并发框架中对线程的挂起操作被封装在 LockSupport类中，LockSupport类中有各种版本pack方法，但最终都调用了Unsafe.park()方法。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;import sun.misc.Unsafe;

import java.lang.reflect.Field;
import java.util.concurrent.TimeUnit;
import java.util.concurrent.locks.LockSupport;

public class Lock {
    public static void main(String[] args) throws Exception {

        // 由于安全限制，只有系统classloader才能使用getUnsafe()方法
        // 普通用户只能通过反射实例化Unsafe
        Field field = Unsafe.class.getDeclaredField(&amp;quot;theUnsafe&amp;quot;);
        field.setAccessible(true);
        Unsafe unsafe = (Unsafe) field.get(null);

        WaitThread waitThread = new WaitThread(unsafe);
        waitThread.start();
        WorkThread workThread = new WorkThread(unsafe, waitThread);
        workThread.start();

        workThread.join();

        System.out.println(&amp;quot;the end.&amp;quot;);
    }
}

/**
 * 工作线程
 */
class WorkThread extends Thread {
    private Thread waitThread;
    private Unsafe unsafe;

    public WorkThread(Unsafe unsafe, Thread waitThread) {
        this.waitThread = waitThread;
        this.unsafe = unsafe;
    }

    public void run() {
        int i = 0;
        while (true) {
            if (i == 5) {
                System.out.println(&amp;quot;WorkThread is now to wake WaitThread&amp;quot;);
                unsafe.unpark(waitThread);

                break;
            }

            System.out.println(&amp;quot;WorkThread is now working for &amp;quot; + (++i) + &amp;quot; s&amp;quot;);

            try {
                TimeUnit.SECONDS.sleep(1);
            } catch (Exception e) {
                e.printStackTrace();
            }
        }
    }
}

class WaitThread extends Thread {
    private Unsafe unsafe;

    public WaitThread(Unsafe unsafe) {
        this.unsafe = unsafe;
    }
  
    public void run() {
        System.out.println(&amp;quot;Wait Thread is now going to block!&amp;quot;);
        unsafe.park(false, 0);
        System.out.println(&amp;quot;WaitThread is now awake&amp;quot;);
    }
}

// 执行结果
Wait Thread is now going to block!
WorkThread is now working for 1 s
WorkThread is now working for 2 s
WorkThread is now working for 3 s
WorkThread is now working for 4 s
WorkThread is now working for 5 s
WorkThread is now to wake WaitThread
WaitThread is now awake
the end.
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;参考:&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;&lt;a href=&#34;http://hg.openjdk.java.net/jdk7/jdk7/jdk/file/9b8c96f96a0f/src/share/classes/sun/misc/Unsafe.java&#34;&gt;sun.misc.Unsafe基于JDK7的源码&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;a href=&#34;http://www.cnblogs.com/chenpi/p/5389254.html&#34;&gt;sun.misc.Unsafe的理解&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;a href=&#34;http://ifeve.com/sun-misc-unsafe/&#34;&gt;Java Magic. Part 4: sun.misc.Unsafe&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;a href=&#34;http://howtodoinjava.com/tag/java-hidden-features/&#34;&gt;java-hidden-features&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;a href=&#34;http://blog.csdn.net/fenglibing/article/details/17138079&#34;&gt;sun.misc.unsafe类的使用&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;a href=&#34;http://www.blogjava.net/xylz/archive/2010/07/04/325206.html&#34;&gt;深入浅出 Java Concurrency (5): 原子操作 part 4&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;a href=&#34;http://www.infoq.com/cn/articles/A-Post-Apocalyptic-sun.misc.Unsafe-World&#34;&gt;sun.misc.Unsafe的后启示录&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;a href=&#34;http://blog.csdn.net/aesop_wubo/article/details/7537278&#34;&gt;JAVA并发编程学习笔记之Unsafe类&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;a href=&#34;http://blog.csdn.net/dfdsggdgg/article/details/51538601&#34;&gt;sun.misc.Unsafe源码解析&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;a href=&#34;http://blog.csdn.net/dfdsggdgg/article/details/51543545&#34;&gt;sun.misc.Unsafe的各种神技&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;a href=&#34;http://blog.csdn.net/hengyunabc/article/details/28126139&#34;&gt;Java的LockSupport.park()实现分析&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;
</description>
    </item>
    
    <item>
      <title>AtomicLong源码分析</title>
      <link>http://nituchao.com/post/juc.atomic/atomic-long/</link>
      <pubDate>Thu, 23 Feb 2017 18:30:28 +0800</pubDate>
      
      <guid>http://nituchao.com/post/juc.atomic/atomic-long/</guid>
      <description>

&lt;h2 id=&#34;概述&#34;&gt;概述&lt;/h2&gt;

&lt;p&gt;在原子变量相关类中，AtomicBoolean, AtomicInteger, AtomicLong三个类是对于基本数据类型的操作，其原理和用法类似，区别在于Boolean, Integer, Long分别是8位，32位，64位的类型，本文重点研究AtomicLong。&lt;/p&gt;

&lt;p&gt;Boolean类型数据长度为8位，Integer类型数据是32位，在当前32位操作系统或者64位操作中都能够直接对其进行原子修改和读取。而Long类型数据是64位，在32位JVM上会当做两个分离的32位来进行操作，所以本身不具备原子性。&lt;/p&gt;

&lt;p&gt;还好我们现在的JDK基本都已经更新到64位，对long型数据的直接修改不存在原子性问题，但是当出现运算操作(比如++, —等)时还是会出现性问题，AtomicLong的目的是实现Long类型数据的各种原子操作。&lt;/p&gt;

&lt;p&gt;Java原子变量的实现依赖于&lt;code&gt;sun.misc.Unsafe&lt;/code&gt;的CAS操作和volatile的内存可见性语义。&lt;/p&gt;

&lt;p&gt;本文基于JDK1.7.0_67&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;java version &amp;ldquo;1.7.0&lt;em&gt;67&amp;rdquo;&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;_Java&amp;trade; SE Runtime Environment (build 1.7.0_67-b01)&lt;/p&gt;

&lt;p&gt;Java HotSpot&amp;trade; 64-Bit Server VM (build 24.65-b04, mixed mode)&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&#34;成员变量&#34;&gt;成员变量&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;// 成员变量unsafe是原子变量相关操作的基础
// 原子变量的修改操作最终有sun.misc.Unsafe类的CAS操作实现
private static final Unsafe unsafe = Unsafe.getUnsafe();
// 成员变量value的内存偏移值，在静态代码块中初始化
private static final long valueOffset;
// 通过volatile关键字保证可见性，用于保存值
private volatile long value;

static {
  try {
    valueOffset = unsafe.objectFieldOffset
      	(AtomicLong.class.getDeclaredField(&amp;quot;value&amp;quot;));
  } catch (Exception ex) { throw new Error(ex); }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;函数列表&#34;&gt;函数列表&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;// 构造函数，初始化值为0
public AtomicLong()
// 构造函数，指定初始化值
public AtomicLong(long initialValue)
// 以原子方式获取当前值
public final long get()
// 以原子方式设置当前值为newValue
// 赋值语句是单操作，所以本身具有原子性
public final void set(long newValue)
// 最后设置为给定值。延时设置变量值，这个等价于set()方法，
// 但是由于字段是volatile类型的，因此此字段的修改会比普通字段
//（非volatile字段）有稍微的性能延时（尽管可以忽略），所以如果
// 不是想立即读取设置的新值，允许在“后台”修改值，那么此方法就很
// 有用。如果还是难以理解，这里就类似于启动一个后台线程如执行修
// 改新值的任务，原线程就不等待修改结果立即返回。
public final void lazySet(long newValue)
// 以原子方式设置当前值为newValue，并返回旧值
public final long getAndSet(long newValue)
// 以原子方式设置当前值为update。
// 如果当前值等于expect，并设置成功，返回true
// 如果当前值不等于expect，则设置失败，返回false
// 该过程不阻塞
public final boolean compareAndSet(long expect, long update)
// 同compareAndSet
public final boolean weakCompareAndSet(long expect, long update)
// 以原子的方式将当前值加1
// 该过程以自旋锁的形似循环执行，直到操作成功
// 该过程不会阻塞
// 返回更新前的值
public final long getAndIncrement()
// 以原子的方式将当前值减1
// 该过程以自旋的形式循环执行，直到操作成功
// 该过程不会阻塞
// 返回更新前的值
public final long getAndDecrement()
// 以原子方式将原值加上给定的delta
// 该过程以自旋的形式循环执行，直到操作成功
// 该过程不会阻塞
// 返回更新前的值
public final long getAndAdd(long delta)
// 以原子方式将原值加1
// 该过程会议自旋的形式循环执行，直到操作成功
// 该过程不会阻塞
// 返回更新后的值
public final long incrementAndGet()
// 以原子方式将原值减1
// 该过程会议自旋的形式循环执行，直到操作成功
// 该过程不会阻塞
// 返回更新后的值
public final long decrementAndGet()
// 以原子方式将原值加上给定的delta
// 该过程以自旋的形式循环执行，直到操作成功
// 该过程不会阻塞
// 返回更新后的值
public final long addAndGet(long delta)
// 将当前值使用Long的静态方法转换成String类型，并返回
public String toString()
// 将当前值使用强制类型转换成int类型，并返回
public int intValue()
// 直接返回当前值
public long longValue()
// 将当前值使用强制类型转换成float类型，并返回
public float floatValue()
// 将当前值使用强制类型转换成double类型，并返回
public double doubleValue()
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;重点函数分析&#34;&gt;重点函数分析&lt;/h2&gt;

&lt;h3 id=&#34;set-long-newvalue&#34;&gt;set(long newValue)&lt;/h3&gt;

&lt;p&gt;以原子方式设置当前值为newValue，因为set方法只是一个但操作的赋值语句，因此是原子的。加上volatile的内存可见性保证，Set是原子操作无疑。&lt;/p&gt;

&lt;h3 id=&#34;lazyset-long-newvalue&#34;&gt;lazySet(long newValue)&lt;/h3&gt;

&lt;p&gt;简单点说，lazySet优先保证数据的修改操作，而降低对可见性的要求。&lt;/p&gt;

&lt;p&gt;lazySet是使用Unsafe.putOrderedObject方法，这个方法在对低延迟代码是很有用的，它能够实现非堵塞的写入，这些写入不会被Java的JIT重新排序指令(&lt;a href=&#34;http://stackoverflow.com/questions/14321212/java-instruction-reordering-cache-in-threads&#34;&gt;instruction reordering&lt;/a&gt;)，这样它使用快速的存储-存储(store-store) barrier, 而不是较慢的存储-加载(store-load) barrier, 后者总是用在volatile的写操作上，这种性能提升是有代价的，虽然便宜，也就是写后结果并不会被其他线程看到，甚至是自己的线程，通常是几纳秒后被其他线程看到，这个时间比较短，所以代价可以忍受。&lt;/p&gt;

&lt;p&gt;类似Unsafe.putOrderedObject还有unsafe.putOrderedLong等方法，unsafe.putOrderedLong比使用 volatile long要快3倍左右。&lt;/p&gt;

&lt;h2 id=&#34;compareandset-long-expect-long-update&#34;&gt;compareAndSet(long expect, long update)&lt;/h2&gt;

&lt;p&gt;以原子方式设置当前值为update。如果当前值等于expect，并设置成功，返回true。如果当前值不等于expect，则设置失败，返回false。该过程不阻塞。由于是使用了&lt;code&gt;sun.misc.Unsafe&lt;/code&gt;的CAS操作实现，它是原子操作无疑。&lt;/p&gt;

&lt;p&gt;_&lt;em&gt;set和compareAndSet都是原子操作，只是他们的目的不同，set只是单纯想设置一个新的值。而compareAndSet则是希望在满足一定条件的情况下(当前值等于except)再设置新的值。&lt;/em&gt;&lt;/p&gt;

&lt;h2 id=&#34;weakcompareandset-long-expect-long-update&#34;&gt;weakCompareAndSet(long expect, long update)&lt;/h2&gt;

&lt;p&gt;以原子方式设置当前值为update。它的实现与compareAndSet完全一致。JDK文档中说，weakCompareAndSet在更新变量时并不创建任何&lt;code&gt;happens-before&lt;/code&gt;顺序，因此即使要修改的值是volatile的，也不保证对该变量的读写操作的顺序（一般来讲，volatile的内存语义保证&lt;code&gt;happens-before&lt;/code&gt;顺序）。&lt;/p&gt;

&lt;p&gt;参考：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;&lt;a href=&#34;http://www.cnblogs.com/timlearn/p/4127616.html&#34;&gt;Java并发——原子变量和原子操作&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;a href=&#34;https://stackoverflow.com/questions/1468007/atomicinteger-lazyset-vs-set&#34;&gt;AtomicInteger lazySet vs set&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;a href=&#34;https://stackoverflow.com/questions/19238594/java-atomic-variable-set-vs-compareandset&#34;&gt;Java Atomic Variable set() vs compareAndSet()&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;
</description>
    </item>
    
    <item>
      <title>Java锁之CAS的原理</title>
      <link>http://nituchao.com/post/juc.lock/java-cas/</link>
      <pubDate>Thu, 23 Feb 2017 18:29:27 +0800</pubDate>
      
      <guid>http://nituchao.com/post/juc.lock/java-cas/</guid>
      <description>&lt;p&gt;参考:&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;a href=&#34;http://zl198751.iteye.com/blog/1848575&#34;&gt;JAVA CAS原理深度分析&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;
</description>
    </item>
    
    <item>
      <title>Java锁之自旋锁的原理</title>
      <link>http://nituchao.com/post/juc.lock/clh-spin-ticket-mcs-lock/</link>
      <pubDate>Thu, 23 Feb 2017 18:29:27 +0800</pubDate>
      
      <guid>http://nituchao.com/post/juc.lock/clh-spin-ticket-mcs-lock/</guid>
      <description>

&lt;h2 id=&#34;概述&#34;&gt;概述&lt;/h2&gt;

&lt;p&gt;锁作为数据同步工具，Java提供了两种实现：synchronized和AQS，这两种锁的实现根本不同，但是在加锁和解锁的过程中，也有很多共同点。它们在进行加锁/解锁时或多或少的用到自旋锁的设计思想。对于这几种自旋锁设计思想的研究，可以帮助我们更好的理解Java的Lock框架。&lt;/p&gt;

&lt;h2 id=&#34;spin锁&#34;&gt;SPIN锁&lt;/h2&gt;

&lt;p&gt;Spin锁即自旋锁。自旋锁是采用让当前线程不停地在循环体内&lt;code&gt;检测并设置临界资源的状态&lt;/code&gt;，直到状态满足条件并设置为指定的新状态。&lt;code&gt;检测并设置临界资源&lt;/code&gt;操作必须是原子的，这样即使多个线程在给定时间自旋，也只有一个线程可获得该锁。&lt;/p&gt;

&lt;p&gt;自旋锁的优点之一是自旋的线程不会被阻塞，一直处于活跃状态，对于锁保护的临界区较小的情况下，自旋获取锁和释放锁的成本都比较低，时间比较短。&lt;/p&gt;

&lt;h3 id=&#34;java中的自旋锁&#34;&gt;Java中的自旋锁&lt;/h3&gt;

&lt;p&gt;在JAVA中，我们可以使用原子变量和Unsafe类的CAS操作来实现自旋锁：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public class SpinLock {
  private AtomicReference&amp;lt;Thread&amp;gt; atomic = new AtomicReference&amp;lt;Thread&amp;gt;();
  
  public void lock() {
    Thread currentThread = Thread.currentThread();
    
    // 如果锁未被占用，则设置当前线程为锁的拥有者。
    while(!atomic.compareAndSet(null, currentThread)) {}
  }
  
  public void unlock() {
    Thread currentThread = Thread.currentThread();
    // 只有锁的拥有者能释放锁
    atomic.compareAndSet(currentThread, null);
  }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;缺点&#34;&gt;缺点&lt;/h4&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;CAS操作需要硬件的配合；&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;保证各个CPU的缓存（L1、L2、L3、跨CPU Socket、主存）的数据一致性，通讯开销很大，在多处理器系统上更严重；&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;没法保证公平性，不保证等待进程/线程按照FIFO顺序获得锁。&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;​&lt;/p&gt;

&lt;h3 id=&#34;linux中的自旋锁&#34;&gt;Linux中的自旋锁&lt;/h3&gt;

&lt;p&gt;自旋锁在Linux内核中广泛使用。在Linux操作系统中，自旋锁是一个互斥设备，它只有两个值&lt;code&gt;锁定&lt;/code&gt;和&lt;code&gt;解锁&lt;/code&gt;。&lt;/p&gt;

&lt;p&gt;由于操作系统和CPU直接打交道，自旋锁又可分为在单核处理器上和多核处理器上。&lt;/p&gt;

&lt;h4 id=&#34;单核处理器&#34;&gt;单核处理器&lt;/h4&gt;

&lt;p&gt;用在单核处理器上，有可分为两种：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;系统不支持内核抢占&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;此时自旋锁什么也不做，确实也不需要做什么，因为单核处理器只有一个线程在执行，又不支持内核抢占，因此资源不可能会被其他的线程访问到。&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;系统支持内核抢占&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;这种情况下，自旋锁加锁仅仅是禁止了内核抢占，解锁则是启用了内核抢占。&lt;/p&gt;

&lt;p&gt;在上述两种情况下，在获取自旋锁后可能会发生中断，若中断处理程序去访问自旋锁所保护的资源，则会发生死锁。因此，linux内核又提供了spin_lock_irq()和spin_lock_irqsave()，这两个函数会在获取自旋锁的同时（同时禁止内核抢占），禁止本地外部可屏蔽中断，从而保证自旋锁的原子操作。&lt;/p&gt;

&lt;h4 id=&#34;多核处理器&#34;&gt;多核处理器&lt;/h4&gt;

&lt;p&gt;多核处理器意味着有多个线程可以同时在不同的处理器上并行执行。&lt;/p&gt;

&lt;p&gt;举个例子：&lt;/p&gt;

&lt;p&gt;四核处理器，若A处理器上的线程1获取了锁,B、C两个处理器恰好这个时候也要访问这个锁保护的资源，因此他俩CPU就一直自旋忙等待。D并不需要这个资源，因此它可以正常处理其他事情。&lt;/p&gt;

&lt;p&gt;自旋锁的几个特点：&lt;/p&gt;

&lt;p&gt;1.被自旋锁保护的临界区代码执行时不能睡眠。单核处理器下，获取到锁的线程睡眠，若恰好此时CPU调度的另一个执行线程也需要获取这个锁，则会造成死锁；多核处理器下，若想获取锁的线程在同一个处理器下，同样会造成死锁，若位于另外的处理器，则会长时间占用CPU等待睡眠的线程释放锁，从而浪费CPU资源。&lt;/p&gt;

&lt;p&gt;2.被自旋锁保护的临界区代码执行时不能被其他中断打断。&lt;/p&gt;

&lt;p&gt;3.被自旋锁保护的临界区代码在执行时，内核不能被抢占。&lt;/p&gt;

&lt;h4 id=&#34;自旋锁函数&#34;&gt;自旋锁函数&lt;/h4&gt;

&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;// 最基本得自旋锁函数，它不失效本地中断。
void spin_lock(spinlock_t *lock);
// 在获得自旋锁之前禁用硬中断（只在本地处理器上），而先前的中断状态保存在flags中
void spin_lock_irqsave(spinlock_t *lock, unsigned long flags);
// 在获得自旋锁之前禁用硬中断（只在本地处理器上），不保存中断状态
void spin_lockirq(spinlock_t *lock);
// 在获得锁前禁用软中断，保持硬中断打开状态
void spin_lock_bh(spinlock_t *lock);
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;ticket锁&#34;&gt;TICKET锁&lt;/h2&gt;

&lt;p&gt;Ticket锁即排队自旋锁，Ticket锁是为了解决上面自旋锁的公平性问题，类似于现实中海底捞的排队叫号：锁拥有一个服务号，表示正在服务的线程，还有一个排队号；每个线程尝试获取锁之前先拿一个排队号，然后不断轮训锁的当前服务号是否是自己的排队号，如果是，则表示自己拥有了锁，不是则继续轮训。&lt;/p&gt;

&lt;p&gt;当前线程释放锁时，将服务号加1，这样下一个线程看到这个变化，就退出自旋，表示获取到锁。&lt;/p&gt;

&lt;h3 id=&#34;java中的自旋锁-1&#34;&gt;Java中的自旋锁&lt;/h3&gt;

&lt;p&gt;在JAVA中，我们可以使用原子变量和Unsafe类的CAS操作来实现Ticket自旋锁：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public class TicketLock {
   private AtomicInteger serviceNum = new AtomicInteger(); // 服务号
   private AtomicInteger ticketNum = new AtomicInteger(); // 排队号

   public int lock() {
         // 首先原子性地获得一个排队号
         int myTicketNum = ticketNum.getAndIncrement();

         // 只要当前服务号不是自己的就不断轮询
       	while (serviceNum.get() != myTicketNum) {}

       	return myTicketNum;
    }

    public void unlock(int myTicket) {
        // 只有当前线程拥有者才能释放锁
        int next = myTicket + 1;
        serviceNum.compareAndSet(myTicket, next);
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;缺点-1&#34;&gt;缺点&lt;/h4&gt;

&lt;p&gt;Ticket Lock 虽然解决了公平性的问题，但是多处理器系统上，每个进程/线程占用的处理器都在读写同一个变量&lt;code&gt;serviceNum&lt;/code&gt; ，每次读写操作都必须在多个处理器缓存之间进行缓存同步，这会导致繁重的系统总线和内存的流量，大大降低系统整体的性能。&lt;/p&gt;

&lt;h3 id=&#34;linux中的排队自旋锁&#34;&gt;Linux中的排队自旋锁&lt;/h3&gt;

&lt;p&gt;排队自旋锁(FIFO Ticket Spinlock)是Linux内核2.6.25版本引入的一种新型自旋锁，它解决了传统自旋锁由于无序竞争导致的&amp;rdquo;公平性&amp;rdquo;问题。但是由于排队自旋锁在一个共享变量上“自旋”，因此在锁竞争激烈的多核或 NUMA 系统上导致性能低下。&lt;/p&gt;

&lt;h2 id=&#34;mcs锁&#34;&gt;MCS锁&lt;/h2&gt;

&lt;p&gt;MCS自旋锁是一种基于链表的高性能、可扩展的自旋锁。申请线程之在本地变量上自旋，直接前驱负责通知其结束自旋，从而极大地减少了不必要的处理器缓存同步的次数，降低了总线和内存的开销。&lt;/p&gt;

&lt;p&gt;MCS锁的设计目标如下：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;保证自旋锁申请者以先进先出的顺序获取锁（FIFO Ordering）。&lt;/li&gt;
&lt;li&gt;只在本地可访问的标志变量上自旋。&lt;/li&gt;
&lt;li&gt;在处理器个数较少的系统中或锁竞争并不激烈的情况下，保持较高性能。&lt;/li&gt;
&lt;li&gt;自旋锁的空间复杂度（即锁数据结构和锁操作所需的空间开销）为常数。&lt;/li&gt;
&lt;li&gt;在没有处理器缓存一致性协议保证的系统中也能很好地工作。&lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&#34;java中的mcs锁&#34;&gt;Java中的MCS锁&lt;/h3&gt;

&lt;p&gt;在JAVA中，我们可以使用原子变量和Unsafe类的CAS操作来实现MCS自旋锁：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public class MCSLock {
    public static class MCSNode {
        volatile MCSNode next;
        volatile boolean isBlock = true; // 本地自旋变量，默认是在等待锁
    }

    volatile MCSNode queue;// 指向最后一个申请锁的MCSNode
    private static final AtomicReferenceFieldUpdater UPDATER = 
      AtomicReferenceFieldUpdater.newUpdater(MCSLock.class, MCSNode.class, &amp;quot;queue&amp;quot;);

    public void lock(MCSNode currentThread) {
        MCSNode predecessor = UPDATER.getAndSet(this, currentThread);// step 1
        if (predecessor != null) {
            predecessor.next = currentThread;// step 2

            while (currentThread.isBlock) {// step 3
            }
        }else { // 只有一个线程在使用锁，没有前驱来通知它，所以得自己标记自己为非阻塞
            currentThread.isBlock = false;
        }
    }

    public void unlock(MCSNode currentThread) {
        if (currentThread.isBlock) {// 锁拥有者进行释放锁才有意义
            return;
        }

        if (currentThread.next == null) {// 检查是否有人排在自己后面
            if (UPDATER.compareAndSet(this, currentThread, null)) {// step 4
                // compareAndSet返回true表示确实没有人排在自己后面
                return;
            } else {
                // 突然有人排在自己后面了，可能还不知道是谁，下面是等待后续者
                // 这里之所以要忙等是因为：step 1执行完后，step 2可能还没执行完
                while (currentThread.next == null) { // step 5
                }
            }
        }

        currentThread.next.isBlock = false;
        currentThread.next = null;// for GC
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;linux中的mcs锁&#34;&gt;Linux中的MCS锁&lt;/h3&gt;

&lt;p&gt;目前 Linux 内核尚未使用 MCS Spinlock。根据上节的算法描述，我们可以很容易地实现 MCS Spinlock。本文的实现针对x86 体系结构(包括 IA32 和 x86_64)。原子交换、比较-交换操作可以使用带 LOCK 前缀的 xchg(q)，cmpxchg(q)[3] 指令实现。&lt;/p&gt;

&lt;h2 id=&#34;clh锁&#34;&gt;CLH锁&lt;/h2&gt;

&lt;p&gt;CLH（Craig, Landin, and Hagersten）锁也是基于链表的可扩展、高性能、公平的自旋锁，申请线程旨在本地变量上自旋，它不断轮训前驱的状态，如果发现前驱释放了锁就结束自旋。&lt;/p&gt;

&lt;h3 id=&#34;java中的clh锁&#34;&gt;Java中的CLH锁&lt;/h3&gt;

&lt;p&gt;在Java中CLH的应用非常广泛，比如JUC包下的锁框架AbstractQueuedSynchronized就是基于CLH实现的，并进而实现了整个Lock框架体系。&lt;/p&gt;

&lt;p&gt;在JAVA中，我们可以使用原子变量和Unsafe类的CAS操作来实现CLH自旋锁：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public class CLHLock {
    public static class CLHNode {
        private volatile boolean isLocked = true; // 默认是在等待锁
    }

    @SuppressWarnings(&amp;quot;unused&amp;quot; )
    private volatile CLHNode tail ;
    private static final AtomicReferenceFieldUpdater&amp;lt;CLHLock, CLHNode&amp;gt; UPDATER = AtomicReferenceFieldUpdater
                  . newUpdater(CLHLock.class, CLHNode .class , &amp;quot;tail&amp;quot; );

    public void lock(CLHNode currentThread) {
        CLHNode preNode = UPDATER.getAndSet( this, currentThread);
        if(preNode != null) {//已有线程占用了锁，进入自旋
            while(preNode.isLocked ) {
            }
        }
    }

    public void unlock(CLHNode currentThread) {
        // 如果队列里只有当前线程，则释放对当前线程的引用（for GC）。
        if (!UPDATER .compareAndSet(this, currentThread, null)) {
            // 还有后续线程
            currentThread. isLocked = false ;// 改变状态，让后续线程结束自旋
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;clh锁与mcs锁的比较&#34;&gt;CLH锁与MCS锁的比较&lt;/h2&gt;

&lt;p&gt;下图是经典的CLH锁和MCS锁队列图示：&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://coderbee.net/wp-content/uploads/2013/11/CLH-MCS-SpinLock.png&#34; alt=&#34;CLH和MCS&#34; /&gt;&lt;/p&gt;

&lt;p&gt;差异：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;从代码实现来看，CLH比MCS要简单得多。&lt;/li&gt;
&lt;li&gt;从自旋的条件来看，CLH是在前驱节点的属性上自旋，而MCS是在本地属性变量上自旋。&lt;/li&gt;
&lt;li&gt;从链表队列来看，CLH的队列是隐式的，CLHNode并不实际持有下一个节点；MCS的队列是物理存在的。&lt;/li&gt;
&lt;li&gt;CLH锁释放时只需要改变自己的属性，MCS锁释放则需要改变后继节点的属性。&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;&lt;strong&gt;注意：这里实现的锁都是独占的，且不能重入的。&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;参考：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;a href=&#34;https://www.ibm.com/developerworks/cn/linux/l-cn-mcsspinlock/&#34;&gt;高性能自旋锁 MCS Spinlock 的设计与实现&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://www.cnblogs.com/hdflzh/p/3716156.html&#34;&gt;高效编程之互斥锁和自旋锁的一些知识&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://my.oschina.net/MinGKai/blog/188522&#34;&gt;基于队列的锁:mcs lock简介&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://blog.csdn.net/vividonly/article/details/6594195&#34;&gt;深入理解linux内核自旋锁&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;
</description>
    </item>
    
    <item>
      <title>Java锁之Lock框架概述</title>
      <link>http://nituchao.com/post/juc.lock/lock-summary/</link>
      <pubDate>Thu, 23 Feb 2017 18:28:27 +0800</pubDate>
      
      <guid>http://nituchao.com/post/juc.lock/lock-summary/</guid>
      <description>

&lt;p&gt;在Java中关于锁有两个体系，一个是synchronized代表的对象监视器同步锁，一个是以AQS为基础的锁框架，该框架位于java.uti.concurrent包下。&lt;/p&gt;

&lt;p&gt;本文基于JDK1.7.0_67&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;java version &amp;ldquo;1.7.0&lt;em&gt;67&amp;rdquo;&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;_Java&amp;trade; SE Runtime Environment (build 1.7.0_67-b01)&lt;/p&gt;

&lt;p&gt;Java HotSpot&amp;trade; 64-Bit Server VM (build 24.65-b04, mixed mode)&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&#34;aqs框架原理-aqs框架图-file-users-liang-library-group-20containers-ubf8t346g9-office-msoclip1-01-65cceb69-4317-8645-9279-f8aa33dad044-png&#34;&gt;AQS框架原理&lt;img src=&#34;file:////Users/liang/Library/Group%20Containers/UBF8T346G9.Office/msoclip1/01/65CCEB69-4317-8645-9279-F8AA33DAD044.png&#34; alt=&#34;AQS框架图&#34; /&gt;&lt;/h2&gt;

&lt;h2 id=&#34;juc包中的锁&#34;&gt;JUC包中的锁&lt;/h2&gt;

&lt;p&gt;相比同步锁，JUC包中的锁的功能更加强大，它为锁提供了一个框架，该框架允许更灵活地使用锁，只是它的用法更难罢了。&lt;/p&gt;

&lt;p&gt;JUC包中的锁，包括：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Lock接口&lt;/li&gt;
&lt;li&gt;ReadWriteLock接口&lt;/li&gt;
&lt;li&gt;Condition接口&lt;/li&gt;
&lt;li&gt;ReentrantLock独占锁&lt;/li&gt;
&lt;li&gt;ReentrantReadWriteLock读写锁&lt;/li&gt;
&lt;li&gt;CountDownLatch&lt;/li&gt;
&lt;li&gt;CyclicBarrier&lt;/li&gt;
&lt;li&gt;Semaphore&lt;/li&gt;
&lt;li&gt;AbstractOwnableSynchronizer抽象类&lt;/li&gt;
&lt;li&gt;AbstractQueuedSynchronizer抽象类&lt;/li&gt;
&lt;li&gt;AbstractQueuedLongSynchronizer抽象类&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>ConcurrentHashMap源码分析</title>
      <link>http://nituchao.com/post/juc.concurrent/concurrent-hasmap/</link>
      <pubDate>Thu, 23 Feb 2017 18:27:27 +0800</pubDate>
      
      <guid>http://nituchao.com/post/juc.concurrent/concurrent-hasmap/</guid>
      <description>

&lt;h2 id=&#34;一言&#34;&gt;一言&lt;/h2&gt;

&lt;p&gt;ConcurrentHashMap是线程安全的、高效的哈希表。默认支持16个并发级别，并发级别在初始化后不能扩展。&lt;/p&gt;

&lt;h2 id=&#34;概述&#34;&gt;概述&lt;/h2&gt;

&lt;p&gt;&lt;strong&gt;HashMap&lt;/strong&gt;是非线程安全的哈希表，常用于单线程程序中。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Hashtable&lt;/strong&gt;是线程安全的哈希表，它是通过synchronized来保证线程安全的；多线程通过同一个“对象的同步锁”来实现并发控制。Hashtable在线程竞争激烈时，效率比较低(此时建议使用ConcurrentHashMap)！因为当一个线程访问Hashtable的同步方法时，其它线程就访问Hashtable的同步方法时，可能会进入阻塞状态。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;ConcurrentHashMap&lt;/strong&gt;是线程安全的哈希表，它是通过“锁分段”来保证线程安全的。ConcurrentHashMap将哈希表分成许多片段(Segment)，每一个片段除了保存哈希表之外，本质上也是一个“可重入的互斥锁”(ReentrantLock)。多线程对同一个片段的访问，是互斥的；但是，对于不同片段的访问，却是可以同步进行的。&lt;/p&gt;

&lt;p&gt;本文基于JDK1.7.0_67&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;java version &amp;ldquo;1.7.0&lt;em&gt;67&amp;rdquo;&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;_Java&amp;trade; SE Runtime Environment (build 1.7.0_67-b01)&lt;/p&gt;

&lt;p&gt;Java HotSpot&amp;trade; 64-Bit Server VM (build 24.65-b04, mixed mode)&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&#34;concurrenthashmap数据结构&#34;&gt;ConcurrentHashMap数据结构&lt;/h2&gt;

&lt;p&gt;要想搞清ConcurrentHashMap，必须先弄清楚它的数据结构：&lt;/p&gt;

&lt;p&gt;&lt;code&gt;图&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;说明:&lt;/strong&gt;&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;ConcurrentHashMap继承于AbstractMap抽象类。&lt;/li&gt;
&lt;li&gt;Setment是ConcurrentHashMap的内部类，它就是ConcurrentHashMap中的&amp;rdquo;锁分段&amp;rdquo;对应的数据结构。ConcurrentHashMap与Segment是组合关系，1个ConcurrentHashMap对象包含若干个Segment对象。在代码中，这表现为ConcurrentHashMap类中存在&amp;rdquo;Segment数组&amp;rdquo;成员。&lt;/li&gt;
&lt;li&gt;Segment类继承于ReentrantLock类，所以Segment本质上是一个可重入的互斥锁。&lt;/li&gt;
&lt;li&gt;HashEntry也是ConcurrentHashMap的内部类，是单向链表节点，存储着key-value键值对。Segment与HashEntry是组合关系，Segment类中存在“HashEntry数组”成员，“HashEntry数组”中的每个HashEntry就是一个单向链表。&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;对于多线程访问对一个“哈希表对象”竞争资源，Hashtable是通过一把锁来控制并发；而ConcurrentHashMap则是将哈希表分成许多片段，对于每一个片段分别通过一个互斥锁来控制并发。ConcurrentHashMap对并发的控制更加细腻，它也更加适应于高并发场景！&lt;/p&gt;

&lt;h2 id=&#34;concurrenthashmap常量定义&#34;&gt;ConcurrentHashMap常量定义&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;// 默认初始容量(HashEntry的个数)
static final int DEFAULT_INITIAL_CAPACITY = 16;
// 默认负载因子
static final float DEFAULT_LOAD_FACTOR = 0.75f;
// 默认并发级别
static final int DEFAULT_CONCURRENCY_LEVEL = 16;
// 最大容量(HashEntry的个数)
static final int MAXIMUM_CAPACITY = 1 &amp;lt;&amp;lt; 30;
// 每个段(Segment)中HashEntry数组(table)的最小容量
// 设置最小为2，是为了防止构造完成后立即resize
static final int MIN_SEGMENT_TABLE_CAPACITY = 2;
// 段的最大个数
static final int MAX_SEGMENTS = 1 &amp;lt;&amp;lt; 16; // slightly conservative
// 在计算size时，先尝试不获取段锁计算，最多尝试RETRIES_BEFORE_LOCK次。
// 如果重试超过RETRIES_BEFORE_LOCK次，则获取段锁后进行计算。
static final int RETRIES_BEFORE_LOCK = 2;
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;concurrenthashmap成员变量&#34;&gt;ConcurrentHashMap成员变量&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;// 制造一个随机值，使得在计算key的hash值时不容易出现冲突。
// 该值通过sun.misc.Hashing.randomHashSeed(instance)生成。
private transient final int hashSeed = randomHashSeed(this);
// 段segment的掩码，用于计算key所在segments索引值。
final int segmentMask;
// 段segment的偏移，用于计算key所在segments索引值。
final int segmentShift;
// 段segment数组，其内部是由HashEntry数组实现。
final Segment&amp;lt;K,V&amp;gt;[] segments;
// 键集合，键不能重复
transient Set&amp;lt;K&amp;gt; keySet;
// 值集合，值可以重复
transient Collection&amp;lt;V&amp;gt; values;
// 元素HashEntry集合
transient Set&amp;lt;Map.Entry&amp;lt;K,V&amp;gt;&amp;gt; entrySet;
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;concurrenthashmap内部类&#34;&gt;ConcurrentHashMap内部类&lt;/h2&gt;

&lt;h3 id=&#34;holder&#34;&gt;Holder&lt;/h3&gt;

&lt;p&gt;静态内部类，存放一些在虚拟机启动后才能初始化的值。&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;容量阈值，初始化hashSeed的时候会用到该值。&lt;/li&gt;
&lt;/ol&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;static final boolean ALTERNATIVE_HASHING;
&lt;/code&gt;&lt;/pre&gt;

&lt;ol&gt;
&lt;li&gt;static静态块&lt;/li&gt;
&lt;/ol&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;static {
  // 获取系统变量jdk.map.althashing.threshold
  // 通过系统变量jdk.map.althashing.threshold来初始化threshold
  String altThreshold = java.security.AccessController.doPrivileged(
    new sun.security.action.GetPropertyAction(
      &amp;quot;jdk.map.althashing.threshold&amp;quot;));

  int threshold;
  try {
    threshold = (null != altThreshold)
      ? Integer.parseInt(altThreshold)
      : Integer.MAX_VALUE;

    // disable alternative hashing if -1
    if (threshold == -1) {
      threshold = Integer.MAX_VALUE;
    }

    if (threshold &amp;lt; 0) {
      throw new IllegalArgumentException(&amp;quot;value must be positive integer.&amp;quot;);
    }
  } catch(IllegalArgumentException failed) {
    throw new Error(&amp;quot;Illegal value for &#39;jdk.map.althashing.threshold&#39;&amp;quot;, failed);
  }
  // 根据系统变量jdk.map.althashing.threshold来初始化ALTERNATIVE_HASHING
  ALTERNATIVE_HASHING = threshold &amp;lt;= MAXIMUM_CAPACITY;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;Holder&lt;/code&gt;类是用来辅助生成hashSeed的。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;jdk.map.althashing.threshold&lt;/code&gt; —&amp;gt; &lt;code&gt;Holder.ALTERNATIVE_HASHING&lt;/code&gt; —&amp;gt; &lt;code&gt;hashSeed&lt;/code&gt;。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;private static int randomHashSeed(ConcurrentHashMap instance) {
  if (sun.misc.VM.isBooted() &amp;amp;&amp;amp; Holder.ALTERNATIVE_HASHING) {
    return sun.misc.Hashing.randomHashSeed(instance);
  }

  return 0;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;hashentry&#34;&gt;HashEntry&lt;/h3&gt;

&lt;p&gt;ConcurrentHashMap中的末端数据结构，用于存储键值信息。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;static final class HashEntry&amp;lt;K,V&amp;gt; {
  // hash和key都是final，保证了读操作时不用加锁。
  final int hash;
  final K key;
  // value设置成volatile，为了确保读操作能够看到最新的值。
  volatile V value;
  // 不再用final关键字，采用unsafe操作保证并发安全。
  volatile HashEntry&amp;lt;K,V&amp;gt; next;

  HashEntry(int hash, K key, V value, HashEntry&amp;lt;K,V&amp;gt; next) {
    this.hash = hash;
    this.key = key;
    this.value = value;
    this.next = next;
  }

  final void setNext(HashEntry&amp;lt;K,V&amp;gt; n) {
    UNSAFE.putOrderedObject(this, nextOffset, n);
  }

  // Unsafe mechanics
  static final sun.misc.Unsafe UNSAFE;
  static final long nextOffset;
  static {
    try {
      UNSAFE = sun.misc.Unsafe.getUnsafe();
      Class k = HashEntry.class;
      nextOffset = UNSAFE.objectFieldOffset
        (k.getDeclaredField(&amp;quot;next&amp;quot;));
    } catch (Exception e) {
      throw new Error(e);
    }
  }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;说明:&lt;/strong&gt;&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;HashEntry是个final类。在插入新的HashEntry节点时，只能采用头插法，因为HashEntry的next节点也是final的不可修改。final修饰的HashEntry可以提高并发性，读操作时不用加锁。&lt;/li&gt;
&lt;li&gt;HashEntry在设置next节点时，使用UNSAFE类保证线程安全。&lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&#34;segment&#34;&gt;Segment&lt;/h3&gt;

&lt;p&gt;Segment是ConcurrentHashMap的内部类，继承ReentrantLock，实现了Serializable接口。操作基本上都在Segment上，Segment中的table是一个HashEntry数组，数据就存放到这个数组中。看到这里对比下HashMap的存储结构，就大概能明白。具体方法在接下来的ConcurrentHashMap的具体方法中讲解。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;static final class Segment&amp;lt;K,V&amp;gt; extends ReentrantLock implements Serializable {
  private static final long serialVersionUID = 2249069246763182397L;

  static final int MAX_SCAN_RETRIES =
    Runtime.getRuntime().availableProcessors() &amp;gt; 1 ? 64 : 1;

  transient volatile HashEntry&amp;lt;K,V&amp;gt;[] table;
  
  transient int count;
  
  transient int modCount;

  transient int threshold;
  
  final float loadFactor;

  Segment(float lf, int threshold, HashEntry&amp;lt;K,V&amp;gt;[] tab);

  final V put(K key, int hash, V value, boolean onlyIfAbsent)

  private void rehash(HashEntry&amp;lt;K,V&amp;gt; node);

  private HashEntry&amp;lt;K,V&amp;gt; scanAndLockForPut(K key, int hash, V value);

  private void scanAndLock(Object key, int hash);

  final V remove(Object key, int hash, Object value);

  final boolean replace(K key, int hash, V oldValue, V newValue);
  final V replace(K key, int hash, V value);

  final void clear();
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;hashiterator&#34;&gt;HashIterator&lt;/h3&gt;

&lt;p&gt;ConcurrentHashMap使用了不同于传统集合的快速失败迭代器的另一种迭代方式，我们称为&lt;strong&gt;弱一致迭代器&lt;/strong&gt;。在这种迭代方式中，当iterator被创建后集合再发生改变就不再是抛出 ConcurrentModificationException，取而代之的是在改变时new新的数据从而不影响原有的数 据，iterator完成后再将头指针替换为新的数据，这样iterator线程可以使用原来老的数据，而写线程也可以并发的完成改变，更重要的，这保证了多个线程并发执行的连续性和扩展性，是性能提升的关键。&lt;/p&gt;

&lt;p&gt;HashIterator通过调用advance()遍历底层数组。在遍历过程中，如果已经遍历的数组上的内容变化了，迭代器不会抛出ConcurrentModificationException异常。如果未遍历的数组上的内容发生了变化，则有可能反映到迭代过程中。这就是ConcurrentHashMap迭代器若一致性的表现。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;HashIterator&lt;/code&gt;是个抽象类，它的子类有&lt;code&gt;EntryIterator&lt;/code&gt;，&lt;code&gt;KeyIterator&lt;/code&gt;和&lt;code&gt;ValueIterator&lt;/code&gt;。从名字上可以看出来，HashIterator为ConcurrentHashMap的遍历提供了键、值、HashEntry等不同维度的迭代器。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;EntryIterator&lt;/code&gt;、&lt;code&gt;KeyIterator&lt;/code&gt;、&lt;code&gt;ValueIterator&lt;/code&gt;事实上是为&lt;code&gt;EntrySet&lt;/code&gt;、&lt;code&gt;KeySet&lt;/code&gt;、&lt;code&gt;Values&lt;/code&gt;提供迭代服务。而所有的迭代操作在本质上都是调用HashIterator里的相关实现（如：nextEntry()，hasNext()，remove()等）。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;abstract class HashIterator {
  int nextSegmentIndex;
  int nextTableIndex;
  HashEntry&amp;lt;K,V&amp;gt;[] currentTable;
  HashEntry&amp;lt;K, V&amp;gt; nextEntry;
  HashEntry&amp;lt;K, V&amp;gt; lastReturned;

  HashIterator() {
    // 从segment的segment.length - 1开始向前遍历。
    nextSegmentIndex = segments.length - 1;
    nextTableIndex = -1;
    advance();
  }

  /**
  * Segment数组从后往前，找到第一个table数组不为null的Segment
  * 将nextSegmentIndex指向该Segment
  * 将nextTableIndex指向该table
  * 将currentTable指向该table
  * 将nextEntry指向该table中的第一个HashEntry元素
  * lastReturned在这里还没有初始化，只有在遍历(调用nextEntry())是才赋值
  */
  final void advance() {
    for (;;) {
      if (nextTableIndex &amp;gt;= 0) {
        if ((nextEntry = entryAt(currentTable, nextTableIndex--)) != null)
          break;
      }
      else if (nextSegmentIndex &amp;gt;= 0) {
        Segment&amp;lt;K,V&amp;gt; seg = segmentAt(segments, nextSegmentIndex--);
        if (seg != null &amp;amp;&amp;amp; (currentTable = seg.table) != null)
          nextTableIndex = currentTable.length - 1;
      }
      else
        break;
    }
  }

  /**
  * 获取当前nextEntry指向的HashEntry。
  * 修改lastReturned为nextEntry当前指向的HashEntry。
  * 调用advance()，向前寻找第一个table数组不为null的Segment
  */
  final HashEntry&amp;lt;K,V&amp;gt; nextEntry() {
    HashEntry&amp;lt;K,V&amp;gt; e = nextEntry;
    if (e == null)
      throw new NoSuchElementException();
    lastReturned = e; // cannot assign until after null check
    if ((nextEntry = e.next) == null)
      advance();
    return e;
  }

  // 根据nextEntry是否为空，判断是否还有下一个元素供遍历
  public final boolean hasNext() { return nextEntry != null; }
  
  // 根据nextEntry是否为空，判断是否还有下一个元素供遍历
  public final boolean hasMoreElements() { return nextEntry != null; }

  /**
  * 调用ConcurrentHashMap的remove方法，按key移除元素。
  * 将lastReturned置为空。
  * 此时nextEntry
  */
  public final void remove() {
    if (lastReturned == null)
      throw new IllegalStateException();
    ConcurrentHashMap.this.remove(lastReturned.key);
    lastReturned = null;
  }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;entryiterator&#34;&gt;EntryIterator&lt;/h3&gt;

&lt;p&gt;继承自&lt;code&gt;HashIterator&lt;/code&gt;，并实现了Iterator接口，用于HashEntry的迭代遍历。EntryIterator重写了next方法，返回了一个WriteThroughEntry对象，该对象继承自AbstractMap.SimpleEntry，本质上是个Map.Entry。&lt;/p&gt;

&lt;p&gt;EntryIterator将在ConcurrentHashMap.EntrySet中起作用，为EntrySet类型提供迭代能力。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;final class EntryIterator 
  		extends HashIterator 
  		implements Iterator&amp;lt;Entry&amp;lt;K,V&amp;gt;&amp;gt; {
  	public Map.Entry&amp;lt;K,V&amp;gt; next() {
      HashEntry&amp;lt;K,V&amp;gt; e = super.nextEntry();
      return new WriteThroughEntry(e.key, e.value);
	}
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;keyiterator&#34;&gt;KeyIterator&lt;/h3&gt;

&lt;p&gt;继承自&lt;code&gt;HashIterator&lt;/code&gt;，并实现了Iterator接口，用于HashEntry的key的迭代遍历。KeyIterator重写了next方法，返回了当前HashEntry的key值。&lt;/p&gt;

&lt;p&gt;KeyIterator将在ConcurrentHashMap.KeySet中起作用，为KeySet类型提供迭代能力。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;final class KeyIterator 
  		extends HashIterator
        implements Iterator&amp;lt;K&amp;gt;, Enumeration&amp;lt;K&amp;gt; {
  public final K next()        { return super.nextEntry().key; }
  public final K nextElement() { return super.nextEntry().key; }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;valueiterator&#34;&gt;ValueIterator&lt;/h3&gt;

&lt;p&gt;继承自HashIterator，并实现了Iterator接口，用于HashEntry的值的迭代遍历。ValueIterator重写了next方法，返回了当前HashEntry的值。&lt;/p&gt;

&lt;p&gt;ValueIterator将在ConcurrentHashMap.Values中起作用，为Values类型提供迭代能力。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;final class ValueIterator
  extends HashIterator
  implements Iterator&amp;lt;V&amp;gt;, Enumeration&amp;lt;V&amp;gt; {
  public final V next()        { return super.nextEntry().value; }
  public final V nextElement() { return super.nextEntry().value; }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;writethroughentry&#34;&gt;WriteThroughEntry&lt;/h3&gt;

&lt;p&gt;&lt;code&gt;WriteThroughEntry&lt;/code&gt;里只有一个public方法setValue，将值写入map中。注意由于并发情况，可能不会是实时修改数据，故不能用于跟踪数据。该方法可以用于遍历时修改数据。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;final class WriteThroughEntry extends AbstractMap.SimpleEntry&amp;lt;K,V&amp;gt; {
  
  WriteThroughEntry(K k, V v) {
  	super(k,v);
  }

  public V setValue(V value) {
    if (value == null) throw new NullPointerException();
    V v = super.setValue(value);
    ConcurrentHashMap.this.put(getKey(), value);
    return v;
  }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;keyset&#34;&gt;KeySet&lt;/h3&gt;

&lt;p&gt;ConcurrentHashMap的KeySet类型用于定义按Key进行遍历的相关操作。其中，iterator()会实例化一个KeyIterator()，进而提供相关的迭代操作。其他的方法，则是通过ConcurrentHashMap的原生方法实现。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;final class KeySet extends AbstractSet&amp;lt;K&amp;gt; {
  public Iterator&amp;lt;K&amp;gt; iterator() {
  	return new KeyIterator();
  }
  public int size() {
  	return ConcurrentHashMap.this.size();
  }
  public boolean isEmpty() {
  	return ConcurrentHashMap.this.isEmpty();
  }
  public boolean contains(Object o) {
  	return ConcurrentHashMap.this.containsKey(o);
  }
  public boolean remove(Object o) {
  	return ConcurrentHashMap.this.remove(o) != null;
  }
  public void clear() {
  	ConcurrentHashMap.this.clear();
  }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;entryset&#34;&gt;EntrySet&lt;/h3&gt;

&lt;p&gt;ConcurrentHashMap的EntrySet类型用于定义按Entry进行遍历的相关操作。其中，iterator()会实例化一个EntryIterator()，进而提供相关的迭代操作。其他的方法，则是通过ConcurrentHashMap的原生方法实现。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;final class EntrySet extends AbstractSet&amp;lt;Map.Entry&amp;lt;K,V&amp;gt;&amp;gt; {
  public Iterator&amp;lt;Map.Entry&amp;lt;K,V&amp;gt;&amp;gt; iterator() {
  	return new EntryIterator();
  }
  public boolean contains(Object o) {
    if (!(o instanceof Map.Entry))
    	return false;
    Map.Entry&amp;lt;?,?&amp;gt; e = (Map.Entry&amp;lt;?,?&amp;gt;)o;
    V v = ConcurrentHashMap.this.get(e.getKey());
    return v != null &amp;amp;&amp;amp; v.equals(e.getValue());
  }
  public boolean remove(Object o) {
  	if (!(o instanceof Map.Entry))
  		return false;
  	Map.Entry&amp;lt;?,?&amp;gt; e = (Map.Entry&amp;lt;?,?&amp;gt;)o;
  	return ConcurrentHashMap.this.remove(e.getKey(), e.getValue());
  }
  public int size() {
  	return ConcurrentHashMap.this.size();
  }
  public boolean isEmpty() {
  	return ConcurrentHashMap.this.isEmpty();
  }
  public void clear() {
  	ConcurrentHashMap.this.clear();
  }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;values&#34;&gt;Values&lt;/h3&gt;

&lt;p&gt;ConcurrentHashMap的Values类型用于定义按Value进行遍历的相关操作。其中，iterator()会实例化一个ValueIterator()，进而提供相关的迭代操作。其他的方法，则是通过ConcurrentHashMap的原生方法实现。&lt;/p&gt;

&lt;p&gt;由于ConcurrentHashMap的值可以重复，因此Values类型继承自AbstractCollection，而不是集合Set。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;final class Values extends AbstractCollection&amp;lt;V&amp;gt; {
  public Iterator&amp;lt;V&amp;gt; iterator() {
  	return new ValueIterator();
  }
  public int size() {
  	return ConcurrentHashMap.this.size();
  }
  public boolean isEmpty() {
  	return ConcurrentHashMap.this.isEmpty();
  }
  public boolean contains(Object o) {
  	return ConcurrentHashMap.this.containsValue(o);
  }
  public void clear() {
  	ConcurrentHashMap.this.clear();
  }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;concurrenthashmap函数列表&#34;&gt;ConcurrentHashMap函数列表&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;// 创建一个带有默认初始容量 (16)、加载因子 (0.75) 和 concurrencyLevel (16) 的新的空映射。
ConcurrentHashMap()
// 创建一个带有指定初始容量、默认加载因子 (0.75) 和 concurrencyLevel (16) 的新的空映射。
ConcurrentHashMap(int initialCapacity)
// 创建一个带有指定初始容量、加载因子和默认 concurrencyLevel (16) 的新的空映射。
ConcurrentHashMap(int initialCapacity, float loadFactor)
// 创建一个带有指定初始容量、加载因子和并发级别的新的空映射。
ConcurrentHashMap(int initialCapacity, float loadFactor, int concurrencyLevel)
// 构造一个与给定映射具有相同映射关系的新映射。
ConcurrentHashMap(Map&amp;lt;? extends K,? extends V&amp;gt; m)

// 从该映射中移除所有映射关系
void clear()
// 一种遗留方法，测试此表中是否有一些与指定值存在映射关系的键。
boolean contains(Object value)
// 测试指定对象是否为此表中的键。
boolean containsKey(Object key)
// 如果此映射将一个或多个键映射到指定值，则返回 true。
boolean containsValue(Object value)
// 返回此表中值的枚举。
Enumeration&amp;lt;V&amp;gt; elements()
// 返回此映射所包含的映射关系的 Set 视图。
Set&amp;lt;Map.Entry&amp;lt;K,V&amp;gt;&amp;gt; entrySet()
// 返回指定键所映射到的值，如果此映射不包含该键的映射关系，则返回 null。
V get(Object key)
// 如果此映射不包含键-值映射关系，则返回 true。
boolean isEmpty()
// 返回此表中键的枚举。
Enumeration&amp;lt;K&amp;gt; keys()
// 返回此映射中包含的键的 Set 视图。
Set&amp;lt;K&amp;gt; keySet()
// 将指定键映射到此表中的指定值。
V put(K key, V value)
// 将指定映射中所有映射关系复制到此映射中。
void putAll(Map&amp;lt;? extends K,? extends V&amp;gt; m)
// 如果指定键已经不再与某个值相关联，则将它与给定值关联。
V putIfAbsent(K key, V value)
// 从此映射中移除键（及其相应的值）。
V remove(Object key)
// 只有目前将键的条目映射到给定值时，才移除该键的条目。
boolean remove(Object key, Object value)
// 只有目前将键的条目映射到某一值时，才替换该键的条目。
V replace(K key, V value)
// 只有目前将键的条目映射到给定值时，才替换该键的条目。
boolean replace(K key, V oldValue, V newValue)
// 返回此映射中的键-值映射关系数。
int size()
// 返回此映射中包含的值的 Collection 视图。
Collection&amp;lt;V&amp;gt; values()
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;concurrenthashmap重点函数&#34;&gt;ConcurrentHashMap重点函数&lt;/h2&gt;

&lt;h3 id=&#34;构造函数&#34;&gt;构造函数&lt;/h3&gt;

&lt;p&gt;ConcurrentHashMap有五个构造函数，重点分析下面这个构造函数。&lt;/p&gt;

&lt;p&gt;ConcurrentHashMap初始化是通过initialCapacity，loadFactor，concurrentLevel等参数来初始化Segment数组，段偏移量segmentShift，段掩码segmentMask和每个segment里的HashEntry数组。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public ConcurrentHashMap(int initialCapacity, float loadFactor, int concurrencyLevel) {
  // 参数检查
  if (!(loadFactor &amp;gt; 0) || initialCapacity &amp;lt; 0 || concurrencyLevel &amp;lt;= 0)
    throw new IllegalArgumentException();
  // 并发级别不能超过段的最大数量
  if (concurrencyLevel &amp;gt; MAX_SEGMENTS)
    concurrencyLevel = MAX_SEGMENTS;
  // Find power-of-two sizes best matching arguments
  int sshift = 0;
  int ssize = 1;
  while (ssize &amp;lt; concurrencyLevel) {
    ++sshift;
    ssize &amp;lt;&amp;lt;= 1;
  }
  this.segmentShift = 32 - sshift;
  this.segmentMask = ssize - 1;
  if (initialCapacity &amp;gt; MAXIMUM_CAPACITY)
    initialCapacity = MAXIMUM_CAPACITY;
  int c = initialCapacity / ssize;
  if (c * ssize &amp;lt; initialCapacity)
    ++c;
  int cap = MIN_SEGMENT_TABLE_CAPACITY;
  while (cap &amp;lt; c)
    cap &amp;lt;&amp;lt;= 1;
  // create segments and segments[0]
  Segment&amp;lt;K,V&amp;gt; s0 =
    new Segment&amp;lt;K,V&amp;gt;(loadFactor, (int)(cap * loadFactor),
                     (HashEntry&amp;lt;K,V&amp;gt;[])new HashEntry[cap]);
  Segment&amp;lt;K,V&amp;gt;[] ss = (Segment&amp;lt;K,V&amp;gt;[])new Segment[ssize];
  UNSAFE.putOrderedObject(ss, SBASE, s0); // ordered write of segments[0]
  this.segments = ss;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;segments数组的长度ssize通过concurrencyLevel计算得出。&lt;/strong&gt;为了能通过按位与的哈希算法来定位segments数组的索引，必须保证segments数组的长度是2的N次方（power-of-two size），所以必须计算出一个是大于或等于concurrencyLevel的最小的2的N次方值来作为segments数组的长度。假如concurrencyLevel等于14，15或16，ssize都会等于16，即容器里锁的个数也是16。注意concurrencyLevel的最大大小是65535，意味着segments数组的长度最大为65536，对应的二进制是16位，对应全局常量MAX_SEGMENTS = 1 &amp;lt;&amp;lt; 16。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;初始化segmentShift和segmentMask。&lt;/strong&gt; 这两个全局变量在定位segment时的哈希算法里需要使用，sshift等于ssize从1向左移位的次数，在默认情况下concurrencyLevel等于16，1需要向左移位移动4次，所以sshift等于4。segmentShift用于定位参与hash运算的位数，segmentShift等于32减sshift，所以等于28，这里之所以用32是因为ConcurrentHashMap里的hash()方法输出的最大数是32位的，后面的测试中我们可以看到这点。segmentMask是哈希运算的掩码，等于ssize减1，即15，掩码的二进制各个位的值都是1。因为ssize的最大长度是65536，所以segmentShift最大值是16，segmentMask最大值是65535，对应的二进制是16位，每个位都是1。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;初始化每个Segment。&lt;/strong&gt;输入参数initialCapacity是ConcurrentHashMap的初始化容量，loadfactor是每个segment的负载因子，在构造方法里需要通过这两个参数来初始化数组中的每个segment。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;初始化每个segment里HashEntry数组的长度cap&lt;/strong&gt;。cap等于initialCapacity除以ssize的倍数c，如果c大于1，就会取大于等于c的2的N次方值，所以cap不是1，就是2的N次方。segment的容量threshold＝(int)cap*loadFactor，默认情况下initialCapacity等于16，loadfactor等于0.75，通过运算cap等于1，threshold等于零。&lt;/p&gt;

&lt;h3 id=&#34;put-k-key-v-value&#34;&gt;put(K key, V value)&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public V put(K key, V value) {
  Segment&amp;lt;K,V&amp;gt; s;
  if (value == null)
  	throw new NullPointerException();
  int hash = hash(key);
  int j = (hash &amp;gt;&amp;gt;&amp;gt; segmentShift) &amp;amp; segmentMask;
  if ((s = (Segment&amp;lt;K,V&amp;gt;)UNSAFE.getObject          // nonvolatile; recheck
  	(segments, (j &amp;lt;&amp;lt; SSHIFT) + SBASE)) == null) //  in ensureSegment
  s = ensureSegment(j);
  return s.put(key, hash, value, false);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Segment内部类中的put方法：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;final V put(K key, int hash, V value, boolean onlyIfAbsent) {
	// tryLock(): 如果锁可用，则获取锁，并立即返回true，否则返回false。
	// scanAndLockForPut扫描指定key的节点，并获取锁，如果不存在就新建一个HashEntry。
	// 在scanAndLockForPut方法里，会循环执行MAX_SCAN_RETRIES次tryLock。
	// 如果还是没有获取到锁，则调用lock()方法使用CAS获取锁。
	// 总之，在node返回时，当前线程一定已经取到了当前segment的锁。
	HashEntry&amp;lt;K,V&amp;gt; node = tryLock() ? null : 
		scanAndLockForPut(key, hash, value);
	V oldValue;
	try {
        HashEntry&amp;lt;K,V&amp;gt;[] tab = table;
        int index = (tab.length - 1) &amp;amp; hash;
        HashEntry&amp;lt;K,V&amp;gt; first = entryAt(tab, index);
        for (HashEntry&amp;lt;K,V&amp;gt; e = first;;) {
        	if (e != null) {
        		K k;
        		if ((k = e.key) == key ||
        			(e.hash == hash &amp;amp;&amp;amp; key.equals(k))) {
        			oldValue = e.value;
        			if (!onlyIfAbsent) {
        				e.value = value;
        				++modCount;
                  }
                  break;
              }
              e = e.next;
            }
            else {
                if (node != null)
                    node.setNext(first);
                else
                    node = new HashEntry&amp;lt;K,V&amp;gt;(hash, key, value, first);
                int c = count + 1;
                if (c &amp;gt; threshold &amp;amp;&amp;amp; tab.length &amp;lt; MAXIMUM_CAPACITY)
                    rehash(node);
                else
                    setEntryAt(tab, index, node);
                ++modCount;
                count = c;
                oldValue = null;
                break;
            }
		}
    } finally {
    unlock();
    }
    return oldValue;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;put操作开始，首先定位到Segment，为了线程安全，锁定当前Segment；然后在Segment里进行插入操作，首先判断是否需要扩容，然后在定位添加元素的位置放在HashEntry数组里。&lt;/p&gt;

&lt;p&gt;扩容：在插入元素前会先判断Segment里的HashEntry数组是否超过容量（threshold），如果超过阀值，数组进行扩容。值得一提的是，Segment的扩容判断比HashMap更恰当，因为HashMap是在插入元素后判断元素是否已经到达容量的，如果到达了就进行扩容，但是很有可能扩容之后没有新元素插入，这时HashMap就进行了一次无效的扩容。&lt;/p&gt;

&lt;p&gt;扩容的时候首先会创建一个两倍于原容量的数组，然后将原数组里的元素进行再hash后插入到新的数组里。为了高效ConcurrentHashMap不会对整个容器进行扩容，而只对某个segment进行扩容。&lt;/p&gt;

&lt;h3 id=&#34;get-k-key&#34;&gt;get(K key)&lt;/h3&gt;

&lt;p&gt;在ConcurrentHashMap中get(K key)方法没有加锁，因此可能会读到其他线程put的新数据。这也是ConcurrentHashMap弱一致性的体现。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public V get(Object key) {
    Segment&amp;lt;K,V&amp;gt; s; // manually integrate access methods to reduce overhead
    HashEntry&amp;lt;K,V&amp;gt;[] tab;
    int h = hash(key);
    long u = (((h &amp;gt;&amp;gt;&amp;gt; segmentShift) &amp;amp; segmentMask) &amp;lt;&amp;lt; SSHIFT) + SBASE;
    if ((s = (Segment&amp;lt;K,V&amp;gt;)UNSAFE.getObjectVolatile(segments, u)) != null &amp;amp;&amp;amp;
        (tab = s.table) != null) {
        for (HashEntry&amp;lt;K,V&amp;gt; e = (HashEntry&amp;lt;K,V&amp;gt;) UNSAFE.getObjectVolatile
                 (tab, ((long)(((tab.length - 1) &amp;amp; h)) &amp;lt;&amp;lt; TSHIFT) + TBASE);
             e != null; e = e.next) {
            K k;
            if ((k = e.key) == key || (e.hash == h &amp;amp;&amp;amp; key.equals(k)))
                return e.value;
        }
    }
    return null;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;size&#34;&gt;size()&lt;/h3&gt;

&lt;p&gt;要统计整个ConcurrentHashMap里元素的大小，就必须统计所有Segment里元素的大小后求和。Segment里的全局变量count是一个volatile变量，那么在多线程场景下，我们是不是直接把所有Segment的count相加就可以得到整个ConcurrentHashMap大小了呢？不是的，虽然相加时可以获取每个Segment的count的最新值，但是拿到之后可能累加前使用的count发生了变化，那么统计结果就不准了。所以最安全的做法，是在统计size的时候把所有Segment的put，remove和clean方法全部锁住，但是这种做法显然非常低效。&lt;/p&gt;

&lt;p&gt;因为在累加count操作过程中，之前累加过的count发生变化的几率非常小，所以ConcurrentHashMap的做法是先尝试2次通过不锁住Segment的方式来统计各个Segment大小，如果统计的过程中，容器的count发生了变化，则再采用加锁的方式来统计所有Segment的大小。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public int size() {
  // Try a few times to get accurate count. On failure due to
  // continuous async changes in table, resort to locking.
  final Segment&amp;lt;K,V&amp;gt;[] segments = this.segments;
  int size;
  boolean overflow; // true if size overflows 32 bits
  long sum;         // sum of modCounts
  long last = 0L;   // previous sum
  int retries = -1; // first iteration isn&#39;t retry
  try {
    for (;;) {
        if (retries++ == RETRIES_BEFORE_LOCK) {
            for (int j = 0; j &amp;lt; segments.length; ++j)
                ensureSegment(j).lock(); // force creation
        }
        sum = 0L;
        size = 0;
        overflow = false;
        for (int j = 0; j &amp;lt; segments.length; ++j) {
            Segment&amp;lt;K,V&amp;gt; seg = segmentAt(segments, j);
            if (seg != null) {
            sum += seg.modCount;
            int c = seg.count;
            if (c &amp;lt; 0 || (size += c) &amp;lt; 0)
            overflow = true;
            }
        }
        if (sum == last)
          break;
      	last = sum;
    }
  } finally {
      if (retries &amp;gt; RETRIES_BEFORE_LOCK) {
          for (int j = 0; j &amp;lt; segments.length; ++j)
              segmentAt(segments, j).unlock();
      }
  }
  return overflow ? Integer.MAX_VALUE : size;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;putifabsent-k-key-v-value&#34;&gt;putIfAbsent(K key, V value)&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;// 如果key在容器中不存在则将其放入其中，否则donothing.
// 返回 null,表示确实不存在，并且value被成功放入
// 返回非 null, 表示 key 存在，返回值是key在容器中的当前值 。
public V putIfAbsent(K key, V value) {
  Segment&amp;lt;K,V&amp;gt; s;
  if (value == null)
    throw new NullPointerException();
  int hash = hash(key);
  int j = (hash &amp;gt;&amp;gt;&amp;gt; segmentShift) &amp;amp; segmentMask;
  if ((s = (Segment&amp;lt;K,V&amp;gt;)UNSAFE.getObject
       (segments, (j &amp;lt;&amp;lt; SSHIFT) + SBASE)) == null)
    s = ensureSegment(j);
  return s.put(key, hash, value, true);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;参考：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;a href=&#34;http://ifeve.com/concurrenthashmap-weakly-consistent/&#34;&gt;为什么ConcurrentHashMap是弱一致的&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://www.cnblogs.com/skywang12345/p/3498537.html&#34;&gt;JUC集合之ConcurrentHashMap&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://a-ray-of-sunshine.github.io/2016/08/01/%E5%B9%B6%E5%8F%91%E5%AE%B9%E5%99%A8-ConcurrentMap/&#34;&gt;并发容器-ConcurrentMap&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://cxis.me/2016/05/26/ConcurrentHashMap%E7%AE%80%E4%BB%8B/&#34;&gt;ConcurrentHashMap简介&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;
</description>
    </item>
    
    <item>
      <title>CopyOnWriteArraySet源码分析</title>
      <link>http://nituchao.com/post/juc.concurrent/copy-on-write-array-set/</link>
      <pubDate>Thu, 23 Feb 2017 18:26:27 +0800</pubDate>
      
      <guid>http://nituchao.com/post/juc.concurrent/copy-on-write-array-set/</guid>
      <description>

&lt;h2 id=&#34;一言&#34;&gt;一言&lt;/h2&gt;

&lt;p&gt;&lt;code&gt;CopyOnWriteArraySet&lt;/code&gt;是线程安全的无序集合，它是通过聚合了一个&lt;code&gt;CopyOnWriteArray&lt;/code&gt;成员变量来实现的。&lt;/p&gt;

&lt;h2 id=&#34;概要&#34;&gt;概要&lt;/h2&gt;

&lt;p&gt;&lt;code&gt;CopyOnWriteArraySet&lt;/code&gt;是线程安全的无序集合，可以将它理解成线程安全的HashSet。有意思的是，&lt;code&gt;CopyOnWriteArraySet&lt;/code&gt;和HashSet虽然都继承于共同的父类AbstractSet；但是，HashSet是通过&amp;rdquo;散列表(HashSet)&amp;ldquo;实现的，而CopyConWriteArraySet则是通过&amp;rdquo;动态数组(CopyOnWriteArrayList)&amp;ldquo;实现的，并不是散列表。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;CopyOnWriteArraySet&lt;/code&gt;具有以下特性：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;它最适合于具有以下特征的应用程序：Set 大小通常保持很小，只读操作远多于可变操作，需要在遍历期间防止线程间的冲突。&lt;/li&gt;
&lt;li&gt;它是线程安全的。它的线程安全通过volatile、互斥锁来实现。&lt;/li&gt;
&lt;li&gt;因为通常需要复制整个基础数组，所以可变操作（add()、set() 和 remove() 等等）的开销很大。&lt;/li&gt;
&lt;li&gt;迭代器支持hasNext(), next()等不可变操作，但不支持可变 remove()等 操作。&lt;/li&gt;
&lt;li&gt;使用迭代器进行遍历的速度很快，并且不会与其他线程发生冲突。在构造迭代器时，迭代器依赖于不变的数组快照。&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;本文基于JDK1.7.0_67&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;java version &amp;ldquo;1.7.0&lt;em&gt;67&amp;rdquo;&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;_Java&amp;trade; SE Runtime Environment (build 1.7.0_67-b01)&lt;/p&gt;

&lt;p&gt;Java HotSpot&amp;trade; 64-Bit Server VM (build 24.65-b04, mixed mode)&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&#34;copyonwritearrayset原理&#34;&gt;CopyOnWriteArraySet原理&lt;/h2&gt;

&lt;p&gt;CopyOnWriteArraySet的数据结构，如下图所示：&lt;/p&gt;

&lt;p&gt;&lt;code&gt;图&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;说明&lt;/strong&gt;&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;CopyOnWriteArraySet继承于AbstractSet，这就意味着它是一个集合。&lt;/li&gt;
&lt;li&gt;CopyOnWriteArraySet聚合了一个CopyOnWriteArrayList对象，它是通过CopyOnWriteArrayList实现的。而CopyOnWriteArrayList本质是个动态数组队列，所以CopyOnWriteArraySet相当于通过动态数组实现的&amp;rdquo;集合&amp;rdquo;！&lt;/li&gt;
&lt;li&gt;CopyOnWriteArraySet不允许有重复元素。因此，CopyOnWriteArrayList额外提供了addIfAbsent()和addAllAbsent()这两个添加元素的API，通过这些API来添加元素时，只有当元素不存在时才执行添加操作。&lt;/li&gt;
&lt;li&gt;CopyOnWriteArraySet的&amp;rdquo;线程安全&amp;rdquo;机制是通过volatile和互斥锁来实现的。而它本身没有volatile变量和互斥锁，都是借由CopyOnWriteArrayList实现。&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&#34;copyonwritearrayset成员变量&#34;&gt;CopyOnWriteArraySet成员变量&lt;/h2&gt;

&lt;p&gt;CopyOnWriteArraySet只有下面一个成员变量&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;private final CopyOnWriteArrayList&amp;lt;E&amp;gt; al;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;说明:&lt;/strong&gt;&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;成员变量al是&lt;code&gt;final&lt;/code&gt;类型的，通过构造函数进行初始化后将不能再修改。&lt;/li&gt;
&lt;li&gt;成员变量al里的&lt;code&gt;添加/修改/删除&lt;/code&gt;操作都是通过互斥锁和volatile变量来保证现场安全的，因此，成员变量al不再用&lt;code&gt;volatile&lt;/code&gt;修饰，也不再额外声明可重入锁lock。&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&#34;copyonwritearrayset函数列表&#34;&gt;CopyOnWriteArraySet函数列表&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;// 创建一个空 set。
CopyOnWriteArraySet()
// 创建一个包含指定 collection 所有元素的 set。
CopyOnWriteArraySet(Collection&amp;lt;? extends E&amp;gt; c)

// 如果指定元素并不存在于此 set 中，则添加它。
boolean add(E e)
// 如果此 set 中没有指定 collection 中的所有元素，则将它们都添加到此 set 中。
boolean addAll(Collection&amp;lt;? extends E&amp;gt; c)
// 移除此 set 中的所有元素。
void clear()
// 如果此 set 包含指定元素，则返回 true。
boolean contains(Object o)
// 如果此 set 包含指定 collection 的所有元素，则返回 true。
boolean containsAll(Collection&amp;lt;?&amp;gt; c)
// 比较指定对象与此 set 的相等性。
boolean equals(Object o)
// 如果此 set 不包含任何元素，则返回 true。
boolean isEmpty()
// 返回按照元素添加顺序在此 set 中包含的元素上进行迭代的迭代器。
Iterator&amp;lt;E&amp;gt; iterator()
// 如果指定元素存在于此 set 中，则将其移除。
boolean remove(Object o)
// 移除此 set 中包含在指定 collection 中的所有元素。
boolean removeAll(Collection&amp;lt;?&amp;gt; c)
// 仅保留此 set 中那些包含在指定 collection 中的元素。
boolean retainAll(Collection&amp;lt;?&amp;gt; c)
// 返回此 set 中的元素数目。
int size()
// 返回一个包含此 set 所有元素的数组。
Object[] toArray()
// 返回一个包含此 set 所有元素的数组；返回数组的运行时类型是指定数组的类型。
&amp;lt;T&amp;gt; T[] toArray(T[] a)
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;copyonwritearrayset重点函数&#34;&gt;CopyOnWriteArraySet重点函数&lt;/h2&gt;

&lt;h3 id=&#34;构造函数&#34;&gt;构造函数&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public CopyOnWriteArraySet() {
        al = new CopyOnWriteArrayList&amp;lt;E&amp;gt;();
}
public CopyOnWriteArraySet(Collection&amp;lt;? extends E&amp;gt; c) {
        al = new CopyOnWriteArrayList&amp;lt;E&amp;gt;();
        al.addAllAbsent(c);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;CopyOnWriteArraySet允许初始化一个空的集合，也允许通过复制一个集合里的元素来进行初始化。本质上将，CopyOnWriteArraySet的初始化是通过初始化成员变量CopyOnWriteArrayList al来实现的。&lt;/p&gt;

&lt;h3 id=&#34;添加&#34;&gt;添加&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public boolean add(E e) {
        return al.addIfAbsent(e);
}

public boolean addAll(Collection&amp;lt;? extends E&amp;gt; c) {
        return al.addAllAbsent(c) &amp;gt; 0;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;CopyOnWriteArraySet不允许重复元素。因此，添加操作都是调用CopyOnWriteArrayList的&lt;code&gt;addIfAbsent&lt;/code&gt;方法或者&lt;code&gt;addAllAbsent&lt;/code&gt;方法实现的。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>CopyOnWriteArrayList源码分析</title>
      <link>http://nituchao.com/post/juc.concurrent/copy-on-write-array-list/</link>
      <pubDate>Thu, 23 Feb 2017 18:25:27 +0800</pubDate>
      
      <guid>http://nituchao.com/post/juc.concurrent/copy-on-write-array-list/</guid>
      <description>

&lt;h2 id=&#34;概述&#34;&gt;概述&lt;/h2&gt;

&lt;p&gt;CopyOnWriteArrayList相当于线程安全的ArrayList。和ArrayList一样，它是个可变数组；但是和ArrayList不同的是，它具有以下特性：
1. 它最适合于具有以下特征的应用程序：List大小通常保持很小，只读操作远多于可变操作，需要在遍历期间防止线程间的冲突。
2. 它是线程安全的。它的线程安全表现在两个方面，修改时使用锁进行同步，读取时使用数据快照。
3. 因为通常要复制整个基础数组，所以可变操作（add()、set()和remove()等操作）的开销很大。
4. 迭代器支持hasNext()、next等不可变操作，但不支持可变remove()等操作。
5. 使用迭代器进行遍历的速度很快，并且不会与其他线程发生冲突。在构造迭代器时，迭代器依赖于不变的数组快照。&lt;/p&gt;

&lt;p&gt;本文基于JDK1.7.0_67&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;java version &amp;ldquo;1.7.0&lt;em&gt;67&amp;rdquo;&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;_Java&amp;trade; SE Runtime Environment (build 1.7.0_67-b01)&lt;/p&gt;

&lt;p&gt;Java HotSpot&amp;trade; 64-Bit Server VM (build 24.65-b04, mixed mode)&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&#34;copyonwritearraylist原理和数据结构&#34;&gt;CopyOnWriteArrayList原理和数据结构&lt;/h2&gt;

&lt;p&gt;CopyOnWriteArrayList的数据结构，如下图所示：&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;CopyOnWriteArrayList UML图&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;说明：
1. CopyOnWriteArrayList实现了List接口，因此可以认为它是一个有序的集合。
2. CopyOnWriteArrayList实现了RandomAccess接口，因此可以认为它的元素可以随机访问。
3. CopyOnWriteArrayList包含一个可重入锁Lock。每一个CopyOnWriteArrayList都和一个互斥锁lock绑定，通过lock，实现了对CopyOnWriteArrayList的互斥访问。
4. CopyOnWriteArrayList包含了成员array数组，这说明CopyOnWriteArrayList本质上通过数组实现的。而且，可存储的元素个数没有上限。&lt;/p&gt;

&lt;p&gt;下面从&amp;rdquo;动态数组&amp;rdquo;和&amp;rdquo;线程安全&amp;rdquo;两个方面进一步对CopyOnWriteArrayList的原理进行说明。
1. &lt;strong&gt;CopyOnWriteArrayList的&amp;rdquo;动态数组&amp;rdquo;机制&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;它内部有个&amp;rdquo;volatile数组&amp;rdquo;(array)来保持数据。在&amp;rdquo;添加/修改/删除&amp;rdquo;数据时，都会新建一个数组，并将更新后的数据拷贝到新建的数组中，最后再将该数组赋值给&amp;rdquo;volatile数组&amp;rdquo;。这就是它叫做CopyOnWriteArrayList的原因！&lt;/p&gt;

&lt;p&gt;CopyOnWriteArrayList就是通过这种方式实现的动态数组；不过正由于它在&amp;rdquo;添加/修改/删除&amp;rdquo;数据时，都会新建数组，所以涉及到修改数据的操作，CopyOnWriteArrayList效率很低。但是单单只是进行遍历的话，效率比较高。&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;CopyOnWriteArrayList的&amp;rdquo;线程安全&amp;rdquo;机制&lt;/strong&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;是通过volatile和互斥锁来实现的。
 a. CopyOnWriteArrayList是通过&amp;rdquo;volatile数组&amp;rdquo;来保存数据的。&lt;/p&gt;

&lt;p&gt;一个线程读取volatile数组时，总能看到其他线程对该volatile变量最后的写入。就这样，通过volatile提供了&amp;rdquo;读取到的数据总是最新的&amp;rdquo;这个机制的保证。
 b. CopyOnWriteArrayList通过互斥锁来保护数据。&lt;/p&gt;

&lt;p&gt;在&amp;rdquo;添加/修改/删除&amp;rdquo;数据时，会先&amp;rdquo;获取互斥锁&amp;rdquo;，在修改完毕后，先将数据更新到&amp;rdquo;volatile数组&amp;rdquo;中，然后再&amp;rdquo;释放互斥锁&amp;rdquo;；这样，就达到了保护数据的目的。&lt;/p&gt;

&lt;h2 id=&#34;copyonwritearraylist成员变量&#34;&gt;CopyOnWriteArrayList成员变量&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;/** 可重入锁，对数组进行添加/修改/删除操作时，通过lock来进行同步操作 */
transient final ReentrantLock lock = new ReentrantLock();

/** 数组，保存数据的地方。对数组array的操作都要通过getArray和setArray进行操作 */
private volatile transient Object[] array;
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;copyonwritearraylist函数列表&#34;&gt;CopyOnWriteArrayList函数列表&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;// 创建一个空列表，默认大小为0。
CopyOnWriteArrayList()
// 创建一个按 collection 的迭代器返回元素的顺序包含指定 collection 元素的列表。
CopyOnWriteArrayList(Collection&amp;lt;? extends E&amp;gt; c)
// 创建一个保存给定数组的副本的列表。 
CopyOnWriteArrayList(E[] toCopyIn)
// 将指定元素添加到此列表的尾部。
boolean add(E e)
// 在此列表的指定位置上插入指定元素。
void add(int index, E element)
// 按照指定 collection 的迭代器返回元素的顺序，将指定 collection 中的所有元素添加此列表的尾部。
boolean addAll(Collection&amp;lt;? extends E&amp;gt; c)
// 从指定位置开始，将指定 collection 的所有元素插入此列表。
boolean addAll(int index, Collection&amp;lt;? extends E&amp;gt; c)
// 按照指定 collection 的迭代器返回元素的顺序，将指定 collection 中尚未包含在此列表中的所有元素添加列表的尾部。
int addAllAbsent(Collection&amp;lt;? extends E&amp;gt; c)
// 添加元素（如果不存在）。
boolean addIfAbsent(E e)
// 从此列表移除所有元素。
void clear()
// 返回此列表的浅表副本。
Object clone()
// 如果此列表包含指定的元素，则返回 true。
boolean contains(Object o)
// 如果此列表包含指定 collection 的所有元素，则返回 true。
boolean containsAll(Collection&amp;lt;?&amp;gt; c)
// 比较指定对象与此列表的相等性。
boolean equals(Object o)
// 返回列表中指定位置的元素。
E get(int index)
// 返回此列表的哈希码值。
int hashCode()
// 返回第一次出现的指定元素在此列表中的索引，从 index 开始向前搜索，如果没有找到该元素，则返回 -1。
int indexOf(E e, int index)
// 返回此列表中第一次出现的指定元素的索引；如果此列表不包含该元素，则返回 -1。
int indexOf(Object o)
// 如果此列表不包含任何元素，则返回 true。
boolean isEmpty()
// 返回以恰当顺序在此列表元素上进行迭代的迭代器。
Iterator&amp;lt;E&amp;gt; iterator()
// 返回最后一次出现的指定元素在此列表中的索引，从 index 开始向后搜索，如果没有找到该元素，则返回 -1。
int lastIndexOf(E e, int index)
// 返回此列表中最后出现的指定元素的索引；如果列表不包含此元素，则返回 -1。
int lastIndexOf(Object o)
// 返回此列表元素的列表迭代器（按适当顺序）。
ListIterator&amp;lt;E&amp;gt; listIterator()
// 返回列表中元素的列表迭代器（按适当顺序），从列表的指定位置开始。
ListIterator&amp;lt;E&amp;gt; listIterator(int index)
// 移除此列表指定位置上的元素。
E remove(int index)
// 从此列表移除第一次出现的指定元素（如果存在）。
boolean remove(Object o)
// 从此列表移除所有包含在指定 collection 中的元素。
boolean removeAll(Collection&amp;lt;?&amp;gt; c)
// 只保留此列表中包含在指定 collection 中的元素。
boolean retainAll(Collection&amp;lt;?&amp;gt; c)
// 用指定的元素替代此列表指定位置上的元素。
E set(int index, E element)
// 返回此列表中的元素数。
int size()
// 返回此列表中 fromIndex（包括）和 toIndex（不包括）之间部分的视图。
List&amp;lt;E&amp;gt; subList(int fromIndex, int toIndex)
// 返回一个按恰当顺序（从第一个元素到最后一个元素）包含此列表中所有元素的数组。
Object[] toArray()
// 返回以恰当顺序（从第一个元素到最后一个元素）包含列表所有元素的数组；
// 返回数组的运行时类型是指定数组的运行时类型。
&amp;lt;T&amp;gt; T[] toArray(T[] a)
// 返回此列表的字符串表示形式。
String toString()
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;copyonwritearraylist重点函数&#34;&gt;CopyOnWriteArrayList重点函数&lt;/h2&gt;

&lt;h3 id=&#34;构造函数&#34;&gt;构造函数&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;// 初始化一个大小为0的对象数组
public CopyOnWriteArrayList() {
    setArray(new Object[0]);
}

// 使用一个集合里的元素来初始化一个对象数组
public CopyOnWriteArrayList(Collection&amp;lt;? extends E&amp;gt; c) {
    Object[] elements = c.toArray();
    if (elements.getClass() != Object[].class)
        elements = Arrays.copyOf(elements, elements.length, Object[].class);
    setArray(elements);
}

// 使用一个数组里元素来初始化一个对象数组
public CopyOnWriteArrayList(E[] toCopyIn) {
    setArray(Arrays.copyOf(toCopyIn, toCopyIn.length, Object[].class));
}

final Object[] getArray() {
    return array;
}

final void setArray(Object[] a) {
    array = a;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;CopyOnWriteArrayList的三个构造函数都调用了setArray()，将新创建的数组赋值给CopyOnWriteArrayList的成员变量array。&lt;/p&gt;

&lt;h3 id=&#34;添加&#34;&gt;添加&lt;/h3&gt;

&lt;h4 id=&#34;直接添加&#34;&gt;直接添加&lt;/h4&gt;

&lt;p&gt;以add(E e)为例来分析&lt;code&gt;CopyOnWriteArrayList&lt;/code&gt;的添加操作。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public boolean add(E e) {
    final ReentrantLock lock = this.lock;
    // 获取“锁”
    lock.lock();
    try {
        // 获取原始”volatile数组“中的数据和数据长度。
        Object[] elements = getArray();
        int len = elements.length;
        // 新建一个数组newElements，并将原始数据拷贝到newElements中；
        // newElements数组的长度=“原始数组的长度”+1
        Object[] newElements = Arrays.copyOf(elements, len + 1);
        // 将“新增加的元素”保存到newElements中。
        newElements[len] = e;
        // 将newElements赋值给”volatile数组“。
        setArray(newElements);
        return true;
    } finally {
        // 释放“锁”
        lock.unlock();
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;说明&lt;/strong&gt;：&lt;/p&gt;

&lt;p&gt;add(E e)的作用就是将数据e添加到”volatile数组“中。它的实现方式是，新建一个数组，接着将原始的”volatile数组“的数据拷贝到新数组中，然后将新增数据也添加到新数组中；最后，将新数组赋值给”volatile数组“。&lt;/p&gt;

&lt;p&gt;在add(E e)中有两点需要关注。&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;在”添加操作“开始前，获取独占锁(lock)，若此时有需要线程要获取锁，则必须等待；在操作完毕后，释放独占锁(lock)，此时其它线程才能获取锁。通过独占锁，来防止多线程同时修改数据！lock的定义如下：&lt;/li&gt;
&lt;/ol&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;transient final ReentrantLock lock = new ReentrantLock();
&lt;/code&gt;&lt;/pre&gt;

&lt;ol&gt;
&lt;li&gt;操作完毕时，会通过setArray()来更新”volatile数组“。而且，前面我们提过”即对一个volatile变量的读，总是能看到（任意线程）对这个volatile变量最后的写入“；这样，每次添加元素之后，其它线程都能看到新添加的元素。&lt;/li&gt;
&lt;/ol&gt;

&lt;h4 id=&#34;不重复添加&#34;&gt;不重复添加&lt;/h4&gt;

&lt;p&gt;由于CopyOnWriteArraySet是通过聚合了一个CopyOnWriteArrayList实现的，而CopyOnWriteArraySet是不包含重复元素的，因此CopyOnWriteArrayList提供了一个不添加重复元素的方法&lt;code&gt;addIfAbsent&lt;/code&gt;，该方法每次从头遍历数组，如果发现元素已经存在，则直接返回false，如果遍历后待添加元素不存在，则添加到新数组的末尾，然后将新数组设置为成员数组。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public boolean addIfAbsent(E e) {
        final ReentrantLock lock = this.lock;
        lock.lock();
        try {
            // Copy while checking if already present.
            // This wins in the most common case where it is not present
            Object[] elements = getArray();
            int len = elements.length;
            Object[] newElements = new Object[len + 1];
            for (int i = 0; i &amp;lt; len; ++i) {
                if (eq(e, elements[i]))
                    return false; // exit, throwing away copy
                else
                    newElements[i] = elements[i];
            }
            newElements[len] = e;
            setArray(newElements);
            return true;
        } finally {
            lock.unlock();
        }
    }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;有在检查待添加元素是否已经存在时要从头遍历数组，因此随着元素个数递增，该方法的效率线性下降。&lt;/p&gt;

&lt;h3 id=&#34;获取&#34;&gt;获取&lt;/h3&gt;

&lt;p&gt;以get(int index)为例，来对&lt;code&gt;CopyOnWriteArrayList&lt;/code&gt;的删除操作进行说明。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public E get(int index) {
    return get(getArray(), index);
}

private E get(Object[] a, int index) {
    return (E) a[index];
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;说明:&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;get(int index)的实现非常简单，就是返回&amp;rdquo;volatile数组&amp;rdquo;中的第index个元素。读取元素的过程不需要加锁，是读取时array的镜像。&lt;/p&gt;

&lt;h3 id=&#34;删除&#34;&gt;删除&lt;/h3&gt;

&lt;p&gt;以remove(int index)为例，来说明&lt;code&gt;CopyOnWriteArrayList&lt;/code&gt;的删除操作。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public E remove(int index) {
    final ReentrantLock lock = this.lock;
    // 获取“锁”
    lock.lock();
    try {
        // 获取原始”volatile数组“中的数据和数据长度。
        Object[] elements = getArray();
        int len = elements.length;
        // 获取elements数组中的第index个数据。
        E oldValue = get(elements, index);
        int numMoved = len - index - 1;
        // 如果被删除的是最后一个元素，则直接通过Arrays.copyOf()进行处理，而不需要新建数组。
        // 否则，新建数组，然后将”volatile数组中被删除元素之外的其它元素“拷贝到新数组中。
        // 最后，将新数组赋值给”volatile数组“。
        if (numMoved == 0)
            setArray(Arrays.copyOf(elements, len - 1));
        else {
            Object[] newElements = new Object[len - 1];
            System.arraycopy(elements, 0, newElements, 0, index);
            System.arraycopy(elements, index + 1, newElements, index,
                             numMoved);
            setArray(newElements);
        }
        return oldValue;
    } finally {
        // 释放“锁”
        lock.unlock();
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;说明&lt;/strong&gt;：&lt;/p&gt;

&lt;p&gt;remove(int index)的作用就是将”volatile数组“中第index个元素删除。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;em&gt;它的实现方式是，如果被删除的是最后一个元素，则直接通过Arrays.copyOf()进行处理，而不需要新建数组。&lt;/em&gt;&lt;/strong&gt;否则，新建数组，然后将”volatile数组中被删除元素之外的其它元素“拷贝到新数组中。最后，将新数组赋值给”volatile数组“。
和add(E e)一样，remove(int index)也是”在操作之前，获取独占锁；操作完成之后，释放独占是“；并且”在操作完成时，会通过将数据更新到volatile数组中“。&lt;/p&gt;

&lt;p&gt;remove操作没有检查index的合法性，有可能会抛出IndexOutOfBoundsExceptions&lt;/p&gt;

&lt;h3 id=&#34;遍历&#34;&gt;遍历&lt;/h3&gt;

&lt;p&gt;以&lt;code&gt;iterator()&lt;/code&gt;为例，来说明&lt;code&gt;CopyOnWriteArrayList&lt;/code&gt;的遍历操作。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public Iterator&amp;lt;E&amp;gt; iterator() {
  return new COWIterator&amp;lt;E&amp;gt; (getArray(), 0);
}

private static class COWIterator&amp;lt;E&amp;gt; implements ListIterator&amp;lt;E&amp;gt; {
    private final Object[] snapshot;
    private int cursor;

    private COWIterator(Object[] elements, int initialCursor) {
        cursor = initialCursor;
        snapshot = elements;
    }

    public boolean hasNext() {
        return cursor &amp;lt; snapshot.length;
    }

    public boolean hasPrevious() {
        return cursor &amp;gt; 0;
    }

    // 获取下一个元素
    @SuppressWarnings(&amp;quot;unchecked&amp;quot;)
    public E next() {
        if (!hasNext())
            throw new NoSuchElementException();
        return (E) snapshot[cursor++];
    }

    // 获取上一个元素
    @SuppressWarnings(&amp;quot;unchecked&amp;quot;)
    public E previous() {
        if (!hasPrevious())
            throw new NoSuchElementException();
        return (E) snapshot[--cursor];
    }

    public int nextIndex() {
        return cursor;
    }

    public int previousIndex() {
        return cursor-1;
    }

    public void remove() {
        throw new UnsupportedOperationException();
    }

    public void set(E e) {
        throw new UnsupportedOperationException();
    }

    public void add(E e) {
        throw new UnsupportedOperationException();
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;说明&lt;/strong&gt;：&lt;/p&gt;

&lt;p&gt;COWIterator不支持修改元素的操作。例如，对于&lt;code&gt;remove()&lt;/code&gt;,&lt;code&gt;set()&lt;/code&gt;,&lt;code&gt;add()&lt;/code&gt;等操作，&lt;code&gt;COWIterator&lt;/code&gt;都会抛出异常！
另外，需要提到的一点是，CopyOnWriteArrayList返回迭代器不会抛出&lt;code&gt;ConcurrentModificationException&lt;/code&gt;异常，即它不是fail-fast机制的！&lt;/p&gt;

&lt;p&gt;参考：&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;http://www.cnblogs.com/skywang12345/p/3498483.html&#34;&gt;Java多线程系列之CopyOnWriteArrayList&lt;/a&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Linux网络I/O模型整理</title>
      <link>http://nituchao.com/post/2017/linux-io-mode/</link>
      <pubDate>Wed, 22 Feb 2017 18:25:27 +0800</pubDate>
      
      <guid>http://nituchao.com/post/2017/linux-io-mode/</guid>
      <description>

&lt;p&gt;Linux的内核将所有外部设备都看做一个文件来操作，对一个文件的读写操作会调用内核提供的系统命令，返回一个file description(fd，文件描述符)。而对一个socket的读写也会有相应的描述符，称为socketfd(socket描述符)，描述符就是一个数字，它指向内核中的一个结构体(文件路径，数据区等一些属性)。&lt;/p&gt;

&lt;h2 id=&#34;linux文件类型&#34;&gt;Linux文件类型&lt;/h2&gt;

&lt;p&gt;Linux操作系统定义了七种文件，对这些文件的操作都属于I/O操作。其中，操作TCP套接字文件时会产生网络I/O。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;d: 目录文件(directory file)&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;这种文件包含了其他文件的名字以及指向与这些文件有关信息的指针。对一个目录文件具有读权限的任一进程都可以读该目录的内容，但只有内核可以直接写目录文件。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;l: 符号链接文件(symbolic link)&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;这种类型的文件指向另一个文件。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;s: 套接字文件(socket)&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;这种类型的文件用于进程间的网络通信。套接字也可用于在一台宿主机上进程之间的非网络通信。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;b: 块设备文件，二进制文件(block special file)&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;这种为类型的文件提供对设备(如磁盘)带缓冲的访问，每次访问以固定长度为单位进行。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;c: 字符设备文件(character special file)&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;这种类型的文件提供对设备不带缓冲的访问，每次访问长度可变。系统中的所有设备要么是字符特殊文件，要么是块特殊文件。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;p: 命名管道文件(FIFO)&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;这种类型的文件用于进程间通信，有时被称为命名管道(named pipe)。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;-: 普通文件(regular file)&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;这是最常用的文件类型，这种文件包含了某种形式的数据。至于这种数据是文本还是二进制数据，对于UNIX内核而言并无区别。对普通文件内容的解释由处理该文件的应用程序进行。&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;一个值得注意的例外是二进制可执行文件。为了执行程序，内核必须理解其格式。所有二进制可执行文件都遵循一种标准化的格式，这种格式使内核能够确定程序文本和数据的加载位置。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&#34;linux网络i-o模型&#34;&gt;Linux网络I/O模型&lt;/h2&gt;

&lt;p&gt;根据UNIX网络编程对I/O模型的分类，UNIX提供了五种I/O模型，服务器会根据自己的类型定位，使用其中一种或者多种I/O模型来处理网络请求。&lt;/p&gt;

&lt;h3 id=&#34;阻塞i-o模型&#34;&gt;阻塞I/O模型&lt;/h3&gt;

&lt;p&gt;最常用的I/O模型就是阻塞I/O模型，缺省情形下，所有文件操作都是阻塞的。我们以套接字借口为例来讲解此模型：在进程空间中调用recvfrom，其系统调用直到数据包到达且被复制到应用进程的缓冲区中或者发生错误时才返回，在此期间一直会等待，进程在从调用recvfrom开始到它返回的整段时间内都是被阻塞的，因此被称为阻塞I/O模型，如图1-1所示：&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://olno3yiqc.bkt.clouddn.com/blog/img/block-io.png&#34; alt=&#34;阻塞I/O模型&#34; /&gt;&lt;/p&gt;

&lt;h3 id=&#34;非阻塞i-o模型&#34;&gt;非阻塞I/O模型&lt;/h3&gt;

&lt;p&gt;recvfrom从应用层到内核的时候，如果该缓冲区没有数据的话，就直接返回一个EWORLDBLOCK错误，一般都对非阻塞I/O模型进行轮询检查这个状态，看内核是不是有数据到来，如图1-2所示：&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://olno3yiqc.bkt.clouddn.com/blog/img/non-block-io.png&#34; alt=&#34;非阻塞I/O模型&#34; /&gt;&lt;/p&gt;

&lt;h3 id=&#34;i-o复用模型&#34;&gt;I/O复用模型&lt;/h3&gt;

&lt;p&gt;Linux提供select/poll，进程通过将一个或者多个fd传递给select或者poll系统调用，阻塞在select操作上，这样select/poll可以帮我们侦测多个fd是否处于就绪状态。select/poll是顺序扫描fd是否就绪，而且支持的fd数量有限，因此它的使用受到了一些制约。&lt;/p&gt;

&lt;p&gt;Linux还提供了一个epoll系统调用，epoll使用基于事件驱动方法代替顺序扫描，因此性能更高。当有fd就绪时，立即回调函数rollback，如图1-3所示：&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://olno3yiqc.bkt.clouddn.com/blog/img/selector-io.png&#34; alt=&#34;I/O复用模型&#34; /&gt;&lt;/p&gt;

&lt;h3 id=&#34;信号驱动i-o模型&#34;&gt;信号驱动I/O模型&lt;/h3&gt;

&lt;p&gt;首先开启套接字接口信号驱动I/O功能，并通过系统调用sigaction执行一个信号处理函数(此系统调用立即返回，进程继续工作，它是非阻塞的)。当数据准备就绪时，就为该进程生成一个SIGIO信号，通过信号回调通知应用程序调用recvfrom来读取数据，并通知主循环函数处理数据，如图1-4所示：&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://olno3yiqc.bkt.clouddn.com/blog/img/signal-io.png&#34; alt=&#34;信号驱动I/O模型&#34; /&gt;&lt;/p&gt;

&lt;h3 id=&#34;异步i-o模型&#34;&gt;异步I/O模型&lt;/h3&gt;

&lt;p&gt;告知内核启动某个操作，并让内核在整个操作完成后（包括将数据从内核复制到用户自己的缓冲区）通知我们。这种模型与信号驱动模型的主要区别是：信号驱动I/O由内核通过我们何时可以开始一个I/O操作；异步I/O模型由内核通知我们I/O操作何时已经完成，如图1-5所示：&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://olno3yiqc.bkt.clouddn.com/blog/img/aio-io.png&#34; alt=&#34;异步I/O模型&#34; /&gt;&lt;/p&gt;

&lt;h2 id=&#34;常用服务器&#34;&gt;常用服务器&lt;/h2&gt;

&lt;p&gt;目前流行的服务器大致分为普通应用服务器和高性能服务器两种。&lt;/p&gt;

&lt;p&gt;应用服务器通常会运行具体的业务代码，比如：订单交易，网站管理等。这些业务通常使用基于MVC模式的框架，并进行数据库操作。应用服务器往往跟编程语言和应用框架绑定，提供上下文管理能力，单次业务的处理时间比较长，业务逻辑比较复杂。因此，应用服务器往往采用阻塞式I/O模型或者非阻塞I/O模型。基于请求/响应的方式工作。&lt;/p&gt;

&lt;p&gt;高性能服务器往往需要面对极高的并发网络连接，并对内存分配、CPU使用提出更加苛刻的要求，比如：适用于反向代理的负载均衡服务器Nignx。因此，高性能服务器往往采用I/O复用模型或信号驱动I/O模型，有些对性能要求更高得服务器会采用纯异步I/O模型。相比较请求/响应的工作方式，使用后面三种I/O模型的服务器的处理方式更多样，也更复杂。&lt;/p&gt;

&lt;h3 id=&#34;使用阻塞i-o模型或非阻塞i-o模型的服务器&#34;&gt;使用阻塞I/O模型或非阻塞I/O模型的服务器&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;Apache&lt;/li&gt;
&lt;li&gt;Tomcat&lt;/li&gt;
&lt;li&gt;Resin&lt;/li&gt;
&lt;li&gt;Caddy&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;使用多路复用i-o模型的服务器&#34;&gt;使用多路复用I/O模型的服务器&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;Nginx&lt;/li&gt;
&lt;li&gt;Netty&lt;/li&gt;
&lt;li&gt;Mina&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;参考资料&#34;&gt;参考资料&lt;/h2&gt;

&lt;p&gt;1, 《Netty权威指南 第二版》，李林峰&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Paxos协议整理</title>
      <link>http://nituchao.com/post/2017/paxos-protocol/</link>
      <pubDate>Wed, 15 Feb 2017 10:13:27 +0800</pubDate>
      
      <guid>http://nituchao.com/post/2017/paxos-protocol/</guid>
      <description>

&lt;p&gt;Paxos是一种提高分布式系统容错性的一致性算法。&lt;/p&gt;

&lt;p&gt;其算法描述如下：&lt;/p&gt;

&lt;h2 id=&#34;阶段一&#34;&gt;阶段一&lt;/h2&gt;

&lt;p&gt;1，Proposer选择一个提案编号Mn，然后向Acceptor的某个超过半数的子集成员发送编号为Mn的Prepare请求。&lt;/p&gt;

&lt;p&gt;2，如果一个Acceptor收到一个编号为Mn的Prepare请求，且编号Mn大于该Acctpor已经响应的所有Prepare请求的编号，那么它就会将它已经批准过的最大编号的提案作为响应反馈给Proposer，同时该Acceptor会承诺不会再批准任何编号小于Mn的提案。&lt;/p&gt;

&lt;p&gt;举个例子来说，假定一个Acceptor已经响应过的所有Prepare请求对应的提案编号分别为1、2、&amp;hellip;、5和7，那么该Acceptor在接收一个编号为8的Prepare请求后，就会将编号为7的提案作为响应反馈给Proposer。&lt;/p&gt;

&lt;h2 id=&#34;阶段二&#34;&gt;阶段二&lt;/h2&gt;

&lt;p&gt;1，如果Proposer收到来自半数以上的Acceptor对于其发出的编号为Mn的Prepare请求的响应，那么它就会发送一个针对[Mn, Vn]提案的Accept请求给Acceptor。注意，Vn的值就是收到的响应中编号最大的提案的值，如果响应中不包含任何提案，那么它就是任意值。&lt;/p&gt;

&lt;p&gt;2，如果Acceptor收到这个针对[Mn, Vn]提案的Accept请求，只要改Acceptor尚未对编号大于Mn的Prepare请求作出响应，它就可以通过这个提案。&lt;/p&gt;

&lt;p&gt;当然，在实际运行过程中，每一个Proposer都有可能会产生多个提案，但只要每个Proposer都遵循如何所述的算法运行，就一定能够保证算法执行的正确性。值得一提的是，每个Proposer都可以在任意时刻丢弃一个提案，哪怕针对该提案的请求和响应在提案被丢弃后会到达，但根据Paxos算法的一系列规约，依然可以保证其在提案选定上的正确性。事实上，如果某个Proposer已经在视图生成编号更大的提案，那么丢弃一些就的提案未尝不是一个好的选择。因此，如果一个Acceptor因为已经收到过更大编号的Prepare请求而忽略某个编号更小的Prepare或者Accept请求，那么它也应当通知其对应的Proposer，以便该Proposer也能够将该提案进行丢弃&amp;ndash;这和上面&amp;rdquo;算法优化&amp;rdquo;部分中提到的提案丢弃是一致的。&lt;/p&gt;

&lt;h2 id=&#34;提案的获取&#34;&gt;提案的获取&lt;/h2&gt;

&lt;p&gt;现在，我们再来看看如何让Learner获取提案，大体可以有以下几种方案。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;方案一&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;Learner获取一个已经被选定的提案的前提是，该提案已经被半数以上的Acceptor批准。因此，最简单的做法就是一旦Acceptor批准了一个提案，就将该提案发送给所有的Leaner。&lt;/p&gt;

&lt;p&gt;很显然，这种做法虽然可以让Leaner尽快地获取被选定的提案，但是却需要让每个Acceptor与所有的Leaner逐个进行一次通信，通信的次数至少为二者个数的乘积。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;方案二&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;另一种可行的方案是，我们可以让所有的Acceptor将他们对提案的批准情况，统一发送给一个特定的Leaner(下文中我们将这样的Leaner称为&amp;rdquo;主Leaner&amp;rdquo;)，在不考虑拜占庭将军问题的前提下，我们假定Leaner之间可以通过消息通信来相互感知提案的选定情况。基于这样的前提，当主Leaner被通知一个提案已经被选定时，它会负责通知其他的Leaner。&lt;/p&gt;

&lt;p&gt;这种方案中，Acceptor首先会将得到批准的提案发送给主Learner，再由其同步给其他Leaner，因此较方案一而言，方案二虽然需要多一个步骤才能将提案通知到所有的Leaner，但其通信次数却大大减少了，通常只是Acceptor和Learner的个数总和。但同时，该方案引入了一个新的不稳定因素：主Learner随时可能出现故障。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;方案三&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;在讲解方案二的时候，我们提到，方案二最大的问题在于主Learner存在单点问题，即主Learner随时可能出现故障。因此，对方案二进行改进，可以将主Learner的范围扩大，即Acceptor可以将批准的提案发送给一个特定的Learner集合，该集合中的每个Learner都可以在一个提案被选定后通知所有其他的Learner。这个Learner集合中的Learner个数越多，可靠性就越好，但同时网络通信的复杂度也就越高。&lt;/p&gt;
</description>
    </item>
    
  </channel>
</rss>