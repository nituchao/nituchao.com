<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Abc_concurrent on 泥土巢</title>
    <link>http://nituchao.com/categories/abc_concurrent/</link>
    <description>Recent content in Abc_concurrent on 泥土巢</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh-CN</language>
    <copyright>Copyright (c) 2017, nituchao | All rights reserved.</copyright>
    <lastBuildDate>Thu, 23 Feb 2017 18:27:27 +0800</lastBuildDate>
    
	<atom:link href="http://nituchao.com/categories/abc_concurrent/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>ConcurrentHashMap源码分析</title>
      <link>http://nituchao.com/post/juc.concurrent/concurrent-hasmap/</link>
      <pubDate>Thu, 23 Feb 2017 18:27:27 +0800</pubDate>
      
      <guid>http://nituchao.com/post/juc.concurrent/concurrent-hasmap/</guid>
      <description>一言 ConcurrentHashMap是线程安全的、高效的哈希表。默认支持16个并发级别，并发级别在初始化后不能扩展。
概述 HashMap是非线程安全的哈希表，常用于单线程程序中。
Hashtable是线程安全的哈希表，它是通过synchronized来保证线程安全的；多线程通过同一个“对象的同步锁”来实现并发控制。Hashtable在线程竞争激烈时，效率比较低(此时建议使用ConcurrentHashMap)！因为当一个线程访问Hashtable的同步方法时，其它线程就访问Hashtable的同步方法时，可能会进入阻塞状态。
ConcurrentHashMap是线程安全的哈希表，它是通过“锁分段”来保证线程安全的。ConcurrentHashMap将哈希表分成许多片段(Segment)，每一个片段除了保存哈希表之外，本质上也是一个“可重入的互斥锁”(ReentrantLock)。多线程对同一个片段的访问，是互斥的；但是，对于不同片段的访问，却是可以同步进行的。
本文基于JDK1.7.0_67
 java version &amp;ldquo;1.7.067&amp;rdquo;
_Java&amp;trade; SE Runtime Environment (build 1.7.0_67-b01)
Java HotSpot&amp;trade; 64-Bit Server VM (build 24.65-b04, mixed mode)
 ConcurrentHashMap数据结构 要想搞清ConcurrentHashMap，必须先弄清楚它的数据结构：
图
说明:
 ConcurrentHashMap继承于AbstractMap抽象类。 Setment是ConcurrentHashMap的内部类，它就是ConcurrentHashMap中的&amp;rdquo;锁分段&amp;rdquo;对应的数据结构。ConcurrentHashMap与Segment是组合关系，1个ConcurrentHashMap对象包含若干个Segment对象。在代码中，这表现为ConcurrentHashMap类中存在&amp;rdquo;Segment数组&amp;rdquo;成员。 Segment类继承于ReentrantLock类，所以Segment本质上是一个可重入的互斥锁。 HashEntry也是ConcurrentHashMap的内部类，是单向链表节点，存储着key-value键值对。Segment与HashEntry是组合关系，Segment类中存在“HashEntry数组”成员，“HashEntry数组”中的每个HashEntry就是一个单向链表。  对于多线程访问对一个“哈希表对象”竞争资源，Hashtable是通过一把锁来控制并发；而ConcurrentHashMap则是将哈希表分成许多片段，对于每一个片段分别通过一个互斥锁来控制并发。ConcurrentHashMap对并发的控制更加细腻，它也更加适应于高并发场景！
ConcurrentHashMap常量定义 // 默认初始容量(HashEntry的个数) static final int DEFAULT_INITIAL_CAPACITY = 16; // 默认负载因子 static final float DEFAULT_LOAD_FACTOR = 0.75f; // 默认并发级别 static final int DEFAULT_CONCURRENCY_LEVEL = 16; // 最大容量(HashEntry的个数) static final int MAXIMUM_CAPACITY = 1 &amp;lt;&amp;lt; 30; // 每个段(Segment)中HashEntry数组(table)的最小容量 // 设置最小为2，是为了防止构造完成后立即resize static final int MIN_SEGMENT_TABLE_CAPACITY = 2; // 段的最大个数 static final int MAX_SEGMENTS = 1 &amp;lt;&amp;lt; 16; // slightly conservative // 在计算size时，先尝试不获取段锁计算，最多尝试RETRIES_BEFORE_LOCK次。 // 如果重试超过RETRIES_BEFORE_LOCK次，则获取段锁后进行计算。 static final int RETRIES_BEFORE_LOCK = 2;  ConcurrentHashMap成员变量 // 制造一个随机值，使得在计算key的hash值时不容易出现冲突。 // 该值通过sun.</description>
    </item>
    
    <item>
      <title>CopyOnWriteArraySet源码分析</title>
      <link>http://nituchao.com/post/juc.concurrent/copy-on-write-array-set/</link>
      <pubDate>Thu, 23 Feb 2017 18:26:27 +0800</pubDate>
      
      <guid>http://nituchao.com/post/juc.concurrent/copy-on-write-array-set/</guid>
      <description>一言 CopyOnWriteArraySet是线程安全的无序集合，它是通过聚合了一个CopyOnWriteArray成员变量来实现的。
概要 CopyOnWriteArraySet是线程安全的无序集合，可以将它理解成线程安全的HashSet。有意思的是，CopyOnWriteArraySet和HashSet虽然都继承于共同的父类AbstractSet；但是，HashSet是通过&amp;rdquo;散列表(HashSet)&amp;ldquo;实现的，而CopyConWriteArraySet则是通过&amp;rdquo;动态数组(CopyOnWriteArrayList)&amp;ldquo;实现的，并不是散列表。
CopyOnWriteArraySet具有以下特性：
 它最适合于具有以下特征的应用程序：Set 大小通常保持很小，只读操作远多于可变操作，需要在遍历期间防止线程间的冲突。 它是线程安全的。它的线程安全通过volatile、互斥锁来实现。 因为通常需要复制整个基础数组，所以可变操作（add()、set() 和 remove() 等等）的开销很大。 迭代器支持hasNext(), next()等不可变操作，但不支持可变 remove()等 操作。 使用迭代器进行遍历的速度很快，并且不会与其他线程发生冲突。在构造迭代器时，迭代器依赖于不变的数组快照。  本文基于JDK1.7.0_67
 java version &amp;ldquo;1.7.067&amp;rdquo;
_Java&amp;trade; SE Runtime Environment (build 1.7.0_67-b01)
Java HotSpot&amp;trade; 64-Bit Server VM (build 24.65-b04, mixed mode)
 CopyOnWriteArraySet原理 CopyOnWriteArraySet的数据结构，如下图所示：
图
说明
 CopyOnWriteArraySet继承于AbstractSet，这就意味着它是一个集合。 CopyOnWriteArraySet聚合了一个CopyOnWriteArrayList对象，它是通过CopyOnWriteArrayList实现的。而CopyOnWriteArrayList本质是个动态数组队列，所以CopyOnWriteArraySet相当于通过动态数组实现的&amp;rdquo;集合&amp;rdquo;！ CopyOnWriteArraySet不允许有重复元素。因此，CopyOnWriteArrayList额外提供了addIfAbsent()和addAllAbsent()这两个添加元素的API，通过这些API来添加元素时，只有当元素不存在时才执行添加操作。 CopyOnWriteArraySet的&amp;rdquo;线程安全&amp;rdquo;机制是通过volatile和互斥锁来实现的。而它本身没有volatile变量和互斥锁，都是借由CopyOnWriteArrayList实现。  CopyOnWriteArraySet成员变量 CopyOnWriteArraySet只有下面一个成员变量
private final CopyOnWriteArrayList&amp;lt;E&amp;gt; al;  说明:
 成员变量al是final类型的，通过构造函数进行初始化后将不能再修改。 成员变量al里的添加/修改/删除操作都是通过互斥锁和volatile变量来保证现场安全的，因此，成员变量al不再用volatile修饰，也不再额外声明可重入锁lock。  CopyOnWriteArraySet函数列表 // 创建一个空 set。 CopyOnWriteArraySet() // 创建一个包含指定 collection 所有元素的 set。 CopyOnWriteArraySet(Collection&amp;lt;?</description>
    </item>
    
    <item>
      <title>CopyOnWriteArrayList源码分析</title>
      <link>http://nituchao.com/post/juc.concurrent/copy-on-write-array-list/</link>
      <pubDate>Thu, 23 Feb 2017 18:25:27 +0800</pubDate>
      
      <guid>http://nituchao.com/post/juc.concurrent/copy-on-write-array-list/</guid>
      <description>概述 CopyOnWriteArrayList相当于线程安全的ArrayList。和ArrayList一样，它是个可变数组；但是和ArrayList不同的是，它具有以下特性： 1. 它最适合于具有以下特征的应用程序：List大小通常保持很小，只读操作远多于可变操作，需要在遍历期间防止线程间的冲突。 2. 它是线程安全的。它的线程安全表现在两个方面，修改时使用锁进行同步，读取时使用数据快照。 3. 因为通常要复制整个基础数组，所以可变操作（add()、set()和remove()等操作）的开销很大。 4. 迭代器支持hasNext()、next等不可变操作，但不支持可变remove()等操作。 5. 使用迭代器进行遍历的速度很快，并且不会与其他线程发生冲突。在构造迭代器时，迭代器依赖于不变的数组快照。
本文基于JDK1.7.0_67
 java version &amp;ldquo;1.7.067&amp;rdquo;
_Java&amp;trade; SE Runtime Environment (build 1.7.0_67-b01)
Java HotSpot&amp;trade; 64-Bit Server VM (build 24.65-b04, mixed mode)
 CopyOnWriteArrayList原理和数据结构 CopyOnWriteArrayList的数据结构，如下图所示：
CopyOnWriteArrayList UML图
说明： 1. CopyOnWriteArrayList实现了List接口，因此可以认为它是一个有序的集合。 2. CopyOnWriteArrayList实现了RandomAccess接口，因此可以认为它的元素可以随机访问。 3. CopyOnWriteArrayList包含一个可重入锁Lock。每一个CopyOnWriteArrayList都和一个互斥锁lock绑定，通过lock，实现了对CopyOnWriteArrayList的互斥访问。 4. CopyOnWriteArrayList包含了成员array数组，这说明CopyOnWriteArrayList本质上通过数组实现的。而且，可存储的元素个数没有上限。
下面从&amp;rdquo;动态数组&amp;rdquo;和&amp;rdquo;线程安全&amp;rdquo;两个方面进一步对CopyOnWriteArrayList的原理进行说明。 1. CopyOnWriteArrayList的&amp;rdquo;动态数组&amp;rdquo;机制
它内部有个&amp;rdquo;volatile数组&amp;rdquo;(array)来保持数据。在&amp;rdquo;添加/修改/删除&amp;rdquo;数据时，都会新建一个数组，并将更新后的数据拷贝到新建的数组中，最后再将该数组赋值给&amp;rdquo;volatile数组&amp;rdquo;。这就是它叫做CopyOnWriteArrayList的原因！
CopyOnWriteArrayList就是通过这种方式实现的动态数组；不过正由于它在&amp;rdquo;添加/修改/删除&amp;rdquo;数据时，都会新建数组，所以涉及到修改数据的操作，CopyOnWriteArrayList效率很低。但是单单只是进行遍历的话，效率比较高。
 CopyOnWriteArrayList的&amp;rdquo;线程安全&amp;rdquo;机制  是通过volatile和互斥锁来实现的。 a. CopyOnWriteArrayList是通过&amp;rdquo;volatile数组&amp;rdquo;来保存数据的。
一个线程读取volatile数组时，总能看到其他线程对该volatile变量最后的写入。就这样，通过volatile提供了&amp;rdquo;读取到的数据总是最新的&amp;rdquo;这个机制的保证。 b. CopyOnWriteArrayList通过互斥锁来保护数据。
在&amp;rdquo;添加/修改/删除&amp;rdquo;数据时，会先&amp;rdquo;获取互斥锁&amp;rdquo;，在修改完毕后，先将数据更新到&amp;rdquo;volatile数组&amp;rdquo;中，然后再&amp;rdquo;释放互斥锁&amp;rdquo;；这样，就达到了保护数据的目的。
CopyOnWriteArrayList成员变量 /** 可重入锁，对数组进行添加/修改/删除操作时，通过lock来进行同步操作 */ transient final ReentrantLock lock = new ReentrantLock(); /** 数组，保存数据的地方。对数组array的操作都要通过getArray和setArray进行操作 */ private volatile transient Object[] array;  CopyOnWriteArrayList函数列表 // 创建一个空列表，默认大小为0。 CopyOnWriteArrayList() // 创建一个按 collection 的迭代器返回元素的顺序包含指定 collection 元素的列表。 CopyOnWriteArrayList(Collection&amp;lt;?</description>
    </item>
    
  </channel>
</rss>