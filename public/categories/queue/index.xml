<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Queue on 泥土巢</title>
    <link>http://nituchao.com/categories/queue/</link>
    <description>Recent content in Queue on 泥土巢</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh-CN</language>
    <copyright>Copyright (c) 2017, nituchao | All rights reserved.</copyright>
    <lastBuildDate>Tue, 27 Dec 2016 16:12:12 +0800</lastBuildDate>
    
	<atom:link href="http://nituchao.com/categories/queue/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>Java通过信号量机制实现生产者消费者</title>
      <link>http://nituchao.com/post/2016/java-xin-hao-liang-ji-zhi-shi-xian-sheng-chan-zhe-xiao-fei-zhe/</link>
      <pubDate>Tue, 27 Dec 2016 16:12:12 +0800</pubDate>
      
      <guid>http://nituchao.com/post/2016/java-xin-hao-liang-ji-zhi-shi-xian-sheng-chan-zhe-xiao-fei-zhe/</guid>
      <description>信号量是一种计数器，用来保护一个或者多个共享资源的访问。Java提供了Semaphore类来实现信号量机制。
如果线程要访问一个共享资源，它必须先获得信号量。如果信号量的内部计数器大于0，信号量将减1，然后允许访问这个共享资源。计数器大于0意味着有可以使用的资源，因此线程将被允许使用其中一个资源。
否则，如果信号量的计数器等于0，信号量将会把线程置入休眠直至计数器大于0.计数器等于0的时候意味着所有的共享资源已经被其他线程使用了，所以需要访问这个共享资源的线程必须等待。
当线程使用完某个共享资源时，信号量必须被释放，以便其他线程能够访问共享资源。释放操作将使信号量的内部计数器增加1。
设计思想 为了使用信号量机制来实现生产者VS消费者模型，我们需要实例化一个二进制信号量对象，即内部计数器只有0和1两个值。多个生产者线程和多个消费者线程竞争这个信号量来互斥访问共享缓冲区。
另外，由于共享缓冲区是有空间限制的，生产者在生产前要判断共享缓冲区空间是否充足。消费者在消费前要判断共享缓冲区内的元素是否足够消费。
代码实现 基于上面的设计思想，我们需要实现共享缓冲区，生产者线程，消费者线程和主程序四部分。
共享缓冲区
package com.nituchao.jvm.prosumer.semaphore; import java.util.ArrayList; import java.util.List; import java.util.concurrent.Semaphore; /** * 缓冲区 * Created by liang on 2016/12/29. */ public class Buffer { private int MAX_SIZE = 100; private final List&amp;lt;String&amp;gt; list; private final Semaphore semaphore; public Buffer() { this.list = new ArrayList&amp;lt;&amp;gt;(); this.semaphore = new Semaphore(1); } /** * 生产Buffer元素 * * @param num */ public boolean BufferProduct(int num) { boolean result = true; try { // 获取信号量 semaphore.</description>
    </item>
    
    <item>
      <title>Java通过重入锁实现生产者消费者</title>
      <link>http://nituchao.com/post/2016/java-chong-ru-suo-shi-xian-sheng-chan-zhe-xiao-fei-zhe/</link>
      <pubDate>Tue, 27 Dec 2016 16:12:12 +0800</pubDate>
      
      <guid>http://nituchao.com/post/2016/java-chong-ru-suo-shi-xian-sheng-chan-zhe-xiao-fei-zhe/</guid>
      <description>ReentrantLock是一个可重入的互斥锁，又被称为&amp;rdquo;独占锁&amp;rdquo;，ReentrantLock锁在同一个时间点只能被一个线程锁持有，而可重入的意思是，ReentrantLock可以被单个线程多次获取，ReentrantLock的性能并不高，优点是比价灵活。ReentrantLock比Synchronized关键词更加灵活，并且能支持条件变量，后面我还会单独介绍使用条件变量实现生产者消费者模型的方法。
设计思想 本文希望同ReentrantLock来实现一个共享缓冲区，生产者线程和消费者线程通过该共享缓冲区来实现相关的生产和消费操作，每个线程对共享缓冲区的访问是互斥的。
另外，由于共享缓冲区是有空间限制的，生产者在生产前要判断共享缓冲区空间是否充足。消费者在消费前要判断共享缓冲区内的元素是否足够消费。
代码实现 根据上面的设计思想，我们需要实现共享缓冲区，生产者线程，消费者线程，主程序等四个部分。
共享缓冲区
package com.nituchao.jvm.prosumer.reentrant; import java.util.ArrayList; import java.util.List; import java.util.concurrent.locks.Lock; import java.util.concurrent.locks.ReentrantLock; /** * 共享缓冲区 * Created by liang on 2016/12/30. */ public class Buffer { private final List&amp;lt;String&amp;gt; list; private int MAX_SIZE = 10; private final Lock lock; public Buffer() { this.list = new ArrayList&amp;lt;String&amp;gt;(); this.lock = new ReentrantLock(); } /** * 生产num个元素 * * @param num * @return */ public boolean bufferProduct(int num) { boolean result = true; try { lock.</description>
    </item>
    
    <item>
      <title>Java通过阻塞队列实现生产者消费者</title>
      <link>http://nituchao.com/post/2016/java-zu-se-dui-lie-shi-xian-sheng-chan-xiao-fei-zhe/</link>
      <pubDate>Tue, 27 Dec 2016 16:10:12 +0800</pubDate>
      
      <guid>http://nituchao.com/post/2016/java-zu-se-dui-lie-shi-xian-sheng-chan-xiao-fei-zhe/</guid>
      <description>Java通过阻塞队列实现生产者消费者。</description>
    </item>
    
    <item>
      <title>Java通过条件变量实现生产者消费者</title>
      <link>http://nituchao.com/post/2016/java-tiao-jian-bian-liang-shi-xian-sheng-chan-zhe-xiao-fei-zhe/</link>
      <pubDate>Tue, 27 Dec 2016 16:00:12 +0800</pubDate>
      
      <guid>http://nituchao.com/post/2016/java-tiao-jian-bian-liang-shi-xian-sheng-chan-zhe-xiao-fei-zhe/</guid>
      <description>Java通过条件变量来实现生产者消费者。</description>
    </item>
    
    <item>
      <title>Java通过读写锁实现生产者消费者</title>
      <link>http://nituchao.com/post/2016/java-du-xie-suo-shi-xian-sheng-chan-zhe-xiao-fei-zhe/</link>
      <pubDate>Tue, 27 Dec 2016 15:12:12 +0800</pubDate>
      
      <guid>http://nituchao.com/post/2016/java-du-xie-suo-shi-xian-sheng-chan-zhe-xiao-fei-zhe/</guid>
      <description>Java通过读写锁实现生产者消费者。</description>
    </item>
    
    <item>
      <title>Java通过对象同步机制实现生产者消费者</title>
      <link>http://nituchao.com/post/2016/java-dui-xiang-suo-shi-xian-sheng-chan-zhe-xiao-fei-zhe/</link>
      <pubDate>Tue, 27 Dec 2016 12:54:28 +0800</pubDate>
      
      <guid>http://nituchao.com/post/2016/java-dui-xiang-suo-shi-xian-sheng-chan-zhe-xiao-fei-zhe/</guid>
      <description>每个Java类都是从Object类派生出来的，Object类原生提供了wait(),notify(),notifyAll()等方法来实现线程间的同步控制。
进一步讲，每个对象都能当做一个锁，每个对象也能当做一个条件队列，对象中的wait(), notify(), notifyAll()方法构成了内部条件队列的API，而队列正是生产者消费者模型的一个关键元素。当对象调用wait()方法时，当前线程会释放获得的对象锁，同时，当前对象会请求操作系统挂起当前线程，此时对象的对象锁就可用了，允许其他等待线程进入。当对象调用notify()或者notifyAll()方法时，当前线程也会释放获得的对象锁，同时，操作系统会结束当前线程的执行，并从阻塞在该对象上的线程列表中选择一个进行唤醒，该线程会获得对线锁并被让操作系统调度。
设计思想 为了设计基于Java对象同步机制的生产者消费者程序，并且是多个生产者线程VS多个消费者线程，可以从以下三点出发。
首先，我们需要有一个缓冲区来充当生产者和消费者之间交换数据的媒介，这个缓冲区可以是一个普通的列表对象，我们在该列表对象上进行生产者和消费者的互斥访问控制。本质上讲，这个缓冲器就相当于一个队列，一方面允许生产者往里面添加数据，一方面允许消费者从里面取走数据。这个列表对象非常重要，所有的wait()和notify()操作以及对象锁的控制都是针对该对象的。因此，这是一个共享对象，在各个生产者线程和消费者线程之间充当媒介。
其次，我们需要有若干个生产者线程。生产者线程要争夺缓冲区对象锁，如果未得到锁则wait()进入阻塞等待被唤醒。如果得到了对象锁，还要判断缓冲区是否已满。如果缓冲区已满，则要wait()进入阻塞等待被唤醒，并释放缓冲区对象锁。如果缓冲区未满，则可以进行生产活动，结束后释放缓冲区对象锁，并唤醒一个阻塞的线程。
最后，我们需要有若干个消费者线程。消费者线程要争夺缓冲区对象锁，如果未得到锁则wait()进行阻塞等待被唤醒。如果得到了对象锁，还要判断缓冲区里的元素是否满足自己的需要。如果缓冲区里的元素不够自己消费，则要wait()进入阻塞等待被唤醒，并释放缓冲区对象锁。如果缓冲区里的元素满足自己的需要，则进行消费操作，结束后释放缓冲区对象锁，并唤醒一个阻塞的线程。
代码实现 基于上面的设计，我们需要实现共享缓冲区，生产者线程，消费者线程和主程序四部分。
共享缓冲区
package com.nituchao.jvm.prosumer.objectsync; import java.util.Date; import java.util.LinkedList; /** * 共享缓冲区 * Created by liang on 2016/12/15. */ public class Buffer { private static final int MAX_SIZE = 100; private LinkedList&amp;lt;String&amp;gt; list; public Buffer(LinkedList&amp;lt;String&amp;gt; list) { this.list = list; } /** * 生产n个产品 * * @param num * @throws InterruptedException */ public void BufferProduce(int num) throws InterruptedException { synchronized (list) { while (list.</description>
    </item>
    
    <item>
      <title>Java通过Exchange机制实现生产者消费者</title>
      <link>http://nituchao.com/post/2016/java-exchange-shi-xian-sheng-chan-zhe-xiao-fei-zhe/</link>
      <pubDate>Sat, 26 Nov 2016 22:17:12 +0800</pubDate>
      
      <guid>http://nituchao.com/post/2016/java-exchange-shi-xian-sheng-chan-zhe-xiao-fei-zhe/</guid>
      <description>Java并发API提供了一个同步辅助类&amp;mdash;Exchanger，它允许并发线程之间交换数据。具体来说，Exchanger类允许在两个线程之间定义同步点(Synchronization Point)。当两个线程都达到同步点时，它们交换数据结构，因此第一个线程的数据结构进入到第二个线程中，同时第二个线程的数据结构进入到第一个线程。
生产者VS消费者模型本质上就是两个线程交换数据。因此，对于只有一个生产者和一个消费者的场景，就可以使用Exchanger类。
设计思想 为了通过Exchanger类实现生产者VS消费者模型，我们在设计的时候需要考虑以下三点：
1, 生产者线程和消费者线程需要各自持有一个自己的缓冲区对象。
2, 生产者线程和消费者线程需要持有一个共同的Exchanger对象，通过该对象实现两个线程的同步和数据结构交换。
3, 消费者每次交换前，需要清空自己的数据结构，因为消费者不需要给生产者传递数据。
代码实现 基于上面的设计，分别实现了生产者线程，消费者线程，主程序。
生产者线程
package com.nituchao.jvm.prosumer.exchanger; import java.util.List; import java.util.concurrent.Exchanger; /** * 生产者 * Created by liang on 2016/11/26. */ public class BufferProducer implements Runnable { private List&amp;lt;String&amp;gt; buffer; private final Exchanger&amp;lt;List&amp;lt;String&amp;gt;&amp;gt; exchanger; public BufferProducer(List&amp;lt;String&amp;gt; buffer, Exchanger&amp;lt;List&amp;lt;String&amp;gt;&amp;gt; exchanger) { this.buffer = buffer; this.exchanger = exchanger; } @Override public void run() { // 循环10次数据交换 int cycle = 1; for (int i = 0; i &amp;lt; 10; i++) { System.</description>
    </item>
    
  </channel>
</rss>