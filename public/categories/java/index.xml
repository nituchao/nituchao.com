<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Java on 泥土巢</title>
    <link>http://nituchao.com/categories/java/</link>
    <description>Recent content in Java on 泥土巢</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh-CN</language>
    <copyright>Copyright (c) 2017, nituchao | All rights reserved.</copyright>
    <lastBuildDate>Sat, 12 Jul 2014 19:19:00 +0800</lastBuildDate>
    
	<atom:link href="http://nituchao.com/categories/java/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>服务器端与客户端加密通信设计</title>
      <link>http://nituchao.com/post/2014/fu-wu-duan-yu-ke-hu-duan-jia-mi-tong-xin-she-ji/</link>
      <pubDate>Sat, 12 Jul 2014 19:19:00 +0800</pubDate>
      
      <guid>http://nituchao.com/post/2014/fu-wu-duan-yu-ke-hu-duan-jia-mi-tong-xin-she-ji/</guid>
      <description>最近的一个项目涉及到服务器与Android客户端交换一些敏感数据，这部分数据必须要经过安全加密后才能在Android与服务器间传递，然后再解密后进行相关的业务操作，而且要做到，即使客户端被恶意反编译，已经发送的数据也不会被破解。
我们首先想到的是对称加密算法AES和DES,但是，如果客户端被恶意反编译，客户端写死的密钥就会被拿到，已经发送的数据就很容易被破解了，因此，安全上，对称加密不满足我们的需求。
我们很快想到了非对称加密算法RSA，即使黑客拿到了客户端的公钥，没有私钥还是无法破解已经发送的数据包，但是，RSA算法速度非常慢，而且一次最多加密128位的数据，虽然安全上满足需求，速度和操作复杂度上还是存在一些硬伤。
于是，我们的解决办法是联合使用RSA和AES算法，具体的做法是，客户端提交的正文内容使用AES加密，AES加密时的密钥由客户端随机生成，然后把随机生成的密钥使用RSA算法加密后与正文内容加密后的密文一起提交给服务器端，服务器端先用自己的RSA私钥解密AES算法的密钥，然后用AES算法配合解密出的密钥解密正文内容。
交互过程 客户端提交内容如下:
 { msgkey: &amp;quot;f7l1mKVA3TVUf9F/lUIM30bzHG+PxXEOoO3vZ0N8ulsyPu8IaO/wmKAlOqUyIHwLtQnCOU2&amp;quot;, msgtxt: &amp;quot;MuoJ+HrOJzneiFwvBcOV8loBhRS0LjbmRyWkvSs0C2w=&amp;quot; }  其中：
 msgtxt是客户端提交的正文内容经过AES算法加密后的密文，AES加密时的密钥key由客户端随机生成。 msgkey是AES算法加密时用到的密钥key经过客户端RSA算法加密后的密文，RSA加密时的公钥由服务器端提供并固定内置的客户端。  以下是交互图:
RSA工具类 以下是我们用到的RSA加密/解密算法，该算法服务器端和客户端必须同时使用:
package com.xiaomi.miui.sec.common; import java.io.FileInputStream; import java.io.FileOutputStream; import java.io.ObjectInputStream; import java.io.ObjectOutputStream; import java.math.BigInteger; import java.security.KeyFactory; import java.security.KeyPair; import java.security.KeyPairGenerator; import java.security.NoSuchAlgorithmException; import java.security.interfaces.RSAPrivateKey; import java.security.interfaces.RSAPublicKey; import java.security.spec.RSAPrivateKeySpec; import java.security.spec.RSAPublicKeySpec; import java.util.HashMap; import javax.crypto.Cipher; /** * RSA工具类 * Created by liang on 7/9/14. */ public class RSAUtils { /** * 生成公钥和私钥 * * @throws NoSuchAlgorithmException */ public static HashMap&amp;lt;String, Object&amp;gt; getKeys() throws NoSuchAlgorithmException { HashMap&amp;lt;String, Object&amp;gt; map = new HashMap&amp;lt;String, Object&amp;gt;(); KeyPairGenerator keyPairGen = KeyPairGenerator.</description>
    </item>
    
    <item>
      <title>Apache CXF解析Map/HashMap</title>
      <link>http://nituchao.com/post/2013/apache-cxf-parse-hash-map/</link>
      <pubDate>Wed, 11 Dec 2013 14:06:00 +0800</pubDate>
      
      <guid>http://nituchao.com/post/2013/apache-cxf-parse-hash-map/</guid>
      <description>项目中WebService框架用的是Apache CXF，但是在使用中发现Apache CXF不支持解析Map和HashMap，而且SOAP报文(XML)和JavaBean的转化是通过JAXB实现的，没办法，自己写了个Map到XML的适配器，来实现两者的转化。
Map适配器 MapAdapter用来完成Java的Map类型与XML中对应节点的转换。
以MapAdatper为中心，一边是XML类型的SOAP报文，一边是以HashMap为元素的list列表。通过以下两个方法完成双向转换:
 unmarshal: 完成XML到JAVA的转换。 marshal: 完成JAVA到XML的转换。  该适配器会通过注解在具体的实体类上指定。
import java.util.HashMap; import java.util.Map; import javax.xml.bind.annotation.adapters.XmlAdapter; /** * Map适配器，完成Java中map与XML中对应节点的转换 * * &amp;lt;p&amp;gt; * detailed comment * @author zWX184091 2013-8-15 * @see * @since 1.0 */ public class MapAdapter extends XmlAdapter&amp;lt;MapConvertor, HashMap&amp;lt;String, String&amp;gt;&amp;gt; { /** * XML to JAVA * * @param map * @return HashMap&amp;lt;String, String&amp;gt; * @throws Exception */ @Override public HashMap&amp;lt;String, String&amp;gt; unmarshal(MapConvertor map) throws Exception { // TODO Auto-generated method stub HashMap&amp;lt;String, String&amp;gt; result = new HashMap&amp;lt;String, String&amp;gt;(); // 遍历MapConvertor，将XML节点内容写入JavaBean Map对象 for (MapConvertor.</description>
    </item>
    
  </channel>
</rss>