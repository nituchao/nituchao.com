<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>泥土巢</title>
    <link>http://nituchao.com/index.xml</link>
    <description>Recent content on 泥土巢</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh-CN</language>
    <copyright>Copyright (c) 2017, nituchao | All rights reserved.</copyright>
    <lastBuildDate>Tue, 28 Feb 2017 19:01:58 +0800</lastBuildDate>
    <atom:link href="http://nituchao.com/index.xml" rel="self" type="application/rss+xml" />
    
    <item>
      <title>jstack命令</title>
      <link>http://nituchao.com/post/2017/tong-guo-jstack-fen-xi/</link>
      <pubDate>Tue, 28 Feb 2017 19:01:58 +0800</pubDate>
      
      <guid>http://nituchao.com/post/2017/tong-guo-jstack-fen-xi/</guid>
      <description>

&lt;p&gt;Java程序在操作系统上是以单进程、多线程的形式运行。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;[work@zc-stage1-miui-sec02 ~]$ jstack
Usage:
    jstack [-l] &amp;lt;pid&amp;gt;
        (to connect to running process)
    jstack -F [-m] [-l] &amp;lt;pid&amp;gt;
        (to connect to a hung process)
    jstack [-m] [-l] &amp;lt;executable&amp;gt; &amp;lt;core&amp;gt;
        (to connect to a core file)
    jstack [-m] [-l] [server_id@]&amp;lt;remote server IP or hostname&amp;gt;
        (to connect to a remote debug server)

Options:
    -F  to force a thread dump. Use when jstack &amp;lt;pid&amp;gt; does not respond (process is hung)
    -m  to print both java and native frames (mixed mode)
    -l  long listing. Prints additional information about locks
    -h or -help to print this help message
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;jstack参数说明&#34;&gt;jstack参数说明&lt;/h2&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;连接到运行中的进程&lt;/p&gt;

&lt;p&gt;&amp;ldquo;jstack pid&amp;rdquo;，pid为进程号，可以通过jps或者top命令查到。&lt;/p&gt;

&lt;p&gt;命令执行成功则堆栈信息打印在控制台，可以通过&amp;rdquo;jstack 7023 &amp;gt; stack.log&amp;rdquo;这种方式将内容输出文件。&lt;/p&gt;

&lt;p&gt;导出的文本中包含线程号，线程号状态，线程调用栈等信息，结合ps命令中查询出的线程号，可以分析出CPU使用率比较高的线程，以及该线程中的调用堆栈，进而可以定位到项目代码。&lt;/p&gt;

&lt;p&gt;```
Thread 1091: (state = BLOCKED)&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;sun.misc.Unsafe.park(boolean, long) @bci=0 (Compiled frame; information may be imprecise)&lt;/li&gt;
&lt;li&gt;java.util.concurrent.locks.LockSupport.park() @bci=5, line=315 (Interpreted frame)&lt;/li&gt;
&lt;li&gt;com.caucho.env.thread2.ResinThread2.park() @bci=29, line=196 (Compiled frame)&lt;/li&gt;
&lt;li&gt;com.caucho.env.thread2.ResinThread2.runTasks() @bci=65, line=147 (Compiled frame)&lt;/li&gt;
&lt;li&gt;com.caucho.env.thread2.ResinThread2.run() @bci=15, line=118 (Interpreted frame)
```&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;Thread 1089: (state = BLOCKED)
    - sun.misc.Unsafe.park(boolean, long) @bci=0 (Compiled frame; information may be imprecise)
    - java.util.concurrent.locks.LockSupport.park() @bci=5, line=315 (Interpreted frame)
    - com.caucho.env.thread2.ResinThread2.park() @bci=29, line=196 (Compiled frame)
    - com.caucho.env.thread2.ResinThread2.runTasks() @bci=65, line=147 (Compiled frame)
    - com.caucho.env.thread2.ResinThread2.run() @bci=15, line=118 (Interpreted frame)&lt;/p&gt;

&lt;p&gt;Thread 1088: (state = IN_NATIVE)
    - java.net.SocketInputStream.socketRead0(java.io.FileDescriptor, byte[], int, int, int) @bci=0 (Compiled frame; information may be imprecise)
    - java.net.SocketInputStream.read(byte[], int, int, int) @bci=79, line=150 (Compiled frame)
    - java.net.SocketInputStream.read(byte[], int, int) @bci=11, line=121 (Compiled frame)
    - java.net.SocketInputStream.read(byte[]) @bci=5, line=107 (Compiled frame)
    - redis.clients.util.RedisInputStream.ensureFill() @bci=20, line=195 (Compiled frame)
    - redis.clients.util.RedisInputStream.readByte() @bci=1, line=40 (Compiled frame)
    - redis.clients.jedis.Protocol.process(redis.clients.util.RedisInputStream) @bci=1, line=141 (Compiled frame)
    - redis.clients.jedis.Protocol.read(redis.clients.util.RedisInputStream) @bci=1, line=205 (Compiled frame)
    - redis.clients.jedis.Connection.readProtocolWithCheckingBroken() @bci=4, line=297 (Compiled frame)
    - redis.clients.jedis.Connection.getBinaryBulkReply() @bci=15, line=216 (Compiled frame)
    - redis.clients.jedis.Connection.getBulkReply() @bci=1, line=205 (Compiled frame)
    - redis.clients.jedis.Jedis.get(java.lang.String) @bci=27, line=101 (Compiled frame)
    - redis.clients.jedis.JedisCluster$3.execute(redis.clients.jedis.Jedis) @bci=5, line=79 (Compiled frame)
    - redis.clients.jedis.JedisCluster$3.execute(redis.clients.jedis.Jedis) @bci=2, line=76 (Compiled frame)
    - redis.clients.jedis.JedisClusterCommand.runWithRetries(byte[], int, boolean, boolean) @bci=78, line=119 (Compiled frame)
    - redis.clients.jedis.JedisClusterCommand.run(java.lang.String) @bci=25, line=30 (Compiled frame)
    - redis.clients.jedis.JedisCluster.get(java.lang.String) @bci=18, line=81 (Compiled frame)
    - com.xiaomi.miui.sec.service.RedisCacheService$14.call(redis.clients.jedis.RedisCluster) @bci=5, line=667 (Compiled frame)
    - com.xiaomi.miui.sec.service.RedisCacheService$14.call(java.lang.Object) @bci=5, line=663 (Compiled frame)
    - com.xiaomi.miui.cache.rediscluster.DefaultRedisClusterCache.get(java.lang.Object, com.xiaomi.miui.cache.rediscluster.RedisClusterCallable) @bci=22, line=68 (Compiled frame)
    - com.xiaomi.miui.sec.service.RedisCacheService.getSettingAdv(java.lang.String, java.lang.String, java.lang.String) @bci=49, line=663 (Compiled frame)
    - com.xiaomi.miui.sec.service.CacheService.getSettingAdv(java.lang.String, java.lang.String, java.lang.String) @bci=7, line=113 (Compiled frame)
    - com.xiaomi.miui.sec.bizLogic.SettingBiz.postHandlerMiCom(net.sf.json.JSONObject, com.xiaomi.miui.sec.thrift.Device, net.paoding.rose.web.Invocation) @bci=55, line=119 (Compiled frame)
    - com.xiaomi.miui.sec.bizLogic.SettingBiz.postHandler(net.sf.json.JSONObject, com.xiaomi.miui.sec.thrift.Device, net.paoding.rose.web.Invocation) @bci=118, line=65 (Compiled frame)
    - com.xiaomi.miui.sec.bizLogic.BasicBiz.mainHandler(net.paoding.rose.web.Invocation) @bci=29, line=59 (Compiled frame)
    - com.xiaomi.miui.sec.controllers.InfoController.setting(net.paoding.rose.web.Invocation, java.lang.String) @bci=73, line=252 (Compiled frame)
    - sun.reflect.GeneratedMethodAccessor31.invoke(java.lang.Object, java.lang.Object[]) @bci=48 (Compiled frame)
    - sun.reflect.DelegatingMethodAccessorImpl.invoke(java.lang.Object, java.lang.Object[]) @bci=6, line=43 (Compiled frame)
    - java.lang.reflect.Method.invoke(java.lang.Object, java.lang.Object[]) @bci=57, line=606 (Compiled frame)&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;
   ​

## jstack分析java线程的CPU使用率和使用时长



## jstack分析分析已有的javacore文件



## jstack连接到远程调试服务器进行分析
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>解决Java进程占用CPU过高的问题</title>
      <link>http://nituchao.com/post/2017/ji-lu-yi-ci-cpu-guo-gao-chu-li/</link>
      <pubDate>Tue, 28 Feb 2017 09:16:18 +0800</pubDate>
      
      <guid>http://nituchao.com/post/2017/ji-lu-yi-ci-cpu-guo-gao-chu-li/</guid>
      <description></description>
    </item>
    
    <item>
      <title>Linux网络I/O模型整理</title>
      <link>http://nituchao.com/post/2017/linux-io-mode/</link>
      <pubDate>Wed, 22 Feb 2017 18:25:27 +0800</pubDate>
      
      <guid>http://nituchao.com/post/2017/linux-io-mode/</guid>
      <description>

&lt;p&gt;Linux的内核将所有外部设备都看做一个文件来操作，对一个文件的读写操作会调用内核提供的系统命令，返回一个file description(fd，文件描述符)。而对一个socket的读写也会有相应的描述符，称为socketfd(socket描述符)，描述符就是一个数字，它指向内核中的一个结构体(文件路径，数据区等一些属性)。&lt;/p&gt;

&lt;h2 id=&#34;linux文件类型&#34;&gt;Linux文件类型&lt;/h2&gt;

&lt;p&gt;Linux操作系统定义了七种文件，对这些文件的操作都属于I/O操作。其中，操作TCP套接字文件时会产生网络I/O。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;d: 目录文件&lt;/li&gt;
&lt;li&gt;l: 符号链接文件&lt;/li&gt;
&lt;li&gt;s: 套接字文件&lt;/li&gt;
&lt;li&gt;b: 块设备文件，二进制文件&lt;/li&gt;
&lt;li&gt;c: 字符设备文件&lt;/li&gt;
&lt;li&gt;p: 命名管道文件&lt;/li&gt;
&lt;li&gt;-: 普通文件&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;linux网络i-o模型&#34;&gt;Linux网络I/O模型&lt;/h2&gt;

&lt;p&gt;根据UNIX网络编程对I/O模型的分类，UNIX提供了五种I/O模型，服务器会根据自己的类型定位，使用其中一种或者多种I/O模型来处理网络请求。&lt;/p&gt;

&lt;h3 id=&#34;阻塞i-o模型&#34;&gt;阻塞I/O模型&lt;/h3&gt;

&lt;p&gt;最常用的I/O模型就是阻塞I/O模型，缺省情形下，所有文件操作都是阻塞的。我们以套接字借口为例来讲解此模型：在进程空间中调用recvfrom，其系统调用直到数据包到达且被复制到应用进程的缓冲区中或者发生错误时才返回，在此期间一直会等待，进程在从调用recvfrom开始到它返回的整段时间内都是被阻塞的，因此被称为阻塞I/O模型，如图1-1所示：&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://olno3yiqc.bkt.clouddn.com/blog/img/block-io.png&#34; alt=&#34;阻塞I/O模型&#34; /&gt;&lt;/p&gt;

&lt;h3 id=&#34;非阻塞i-o模型&#34;&gt;非阻塞I/O模型&lt;/h3&gt;

&lt;p&gt;recvfrom从应用层到内核的时候，如果该缓冲区没有数据的话，就直接返回一个EWORLDBLOCK错误，一般都对非阻塞I/O模型进行轮询检查这个状态，看内核是不是有数据到来，如图1-2所示：&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://olno3yiqc.bkt.clouddn.com/blog/img/non-block-io.png&#34; alt=&#34;非阻塞I/O模型&#34; /&gt;&lt;/p&gt;

&lt;h3 id=&#34;i-o复用模型&#34;&gt;I/O复用模型&lt;/h3&gt;

&lt;p&gt;Linux提供select/poll，进程通过将一个或者多个fd传递给select或者poll系统调用，阻塞在select操作上，这样select/poll可以帮我们侦测多个fd是否处于就绪状态。select/poll是顺序扫描fd是否就绪，而且支持的fd数量有限，因此它的使用受到了一些制约。&lt;/p&gt;

&lt;p&gt;Linux还提供了一个epoll系统调用，epoll使用基于事件驱动方法代替顺序扫描，因此性能更高。当有fd就绪时，立即回调函数rollback，如图1-3所示：&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://olno3yiqc.bkt.clouddn.com/blog/img/selector-io.png&#34; alt=&#34;I/O复用模型&#34; /&gt;&lt;/p&gt;

&lt;h3 id=&#34;信号驱动i-o模型&#34;&gt;信号驱动I/O模型&lt;/h3&gt;

&lt;p&gt;首先开启套接字接口信号驱动I/O功能，并通过系统调用sigaction执行一个信号处理函数(此系统调用立即返回，进程继续工作，它是非阻塞的)。当数据准备就绪时，就为该进程生成一个SIGIO信号，通过信号回调通知应用程序调用recvfrom来读取数据，并通知主循环函数处理数据，如图1-4所示：&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://olno3yiqc.bkt.clouddn.com/blog/img/signal-io.png&#34; alt=&#34;信号驱动I/O模型&#34; /&gt;&lt;/p&gt;

&lt;h3 id=&#34;异步i-o模型&#34;&gt;异步I/O模型&lt;/h3&gt;

&lt;p&gt;告知内核启动某个操作，并让内核在整个操作完成后（包括将数据从内核复制到用户自己的缓冲区）通知我们。这种模型与信号驱动模型的主要区别是：信号驱动I/O由内核通过我们何时可以开始一个I/O操作；异步I/O模型由内核通知我们I/O操作何时已经完成，如图1-5所示：&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://olno3yiqc.bkt.clouddn.com/blog/img/aio-io.png&#34; alt=&#34;异步I/O模型&#34; /&gt;&lt;/p&gt;

&lt;h2 id=&#34;常用服务器&#34;&gt;常用服务器&lt;/h2&gt;

&lt;p&gt;目前流行的服务器大致分为普通应用服务器和高性能服务器两种。&lt;/p&gt;

&lt;p&gt;应用服务器通常会运行具体的业务代码，比如：订单交易，网站管理等。这些业务通常使用基于MVC模式的框架，并进行数据库操作。应用服务器往往跟编程语言和应用框架绑定，提供上下文管理能力，单次业务的处理时间比较长，业务逻辑比较复杂。因此，应用服务器往往采用阻塞式I/O模型或者非阻塞I/O模型。基于请求/响应的方式工作。&lt;/p&gt;

&lt;p&gt;高性能服务器往往需要面对极高的并发网络连接，并对内存分配、CPU使用提出更加苛刻的要求，比如：适用于反向代理的负载均衡服务器Nignx。因此，高性能服务器往往采用I/O复用模型或信号驱动I/O模型，有些对性能要求更高得服务器会采用纯异步I/O模型。相比较请求/响应的工作方式，使用后面三种I/O模型的服务器的处理方式更多样，也更复杂。&lt;/p&gt;

&lt;h3 id=&#34;使用阻塞i-o模型或非阻塞i-o模型的服务器&#34;&gt;使用阻塞I/O模型或非阻塞I/O模型的服务器&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;Apache&lt;/li&gt;
&lt;li&gt;Tomcat&lt;/li&gt;
&lt;li&gt;Resin&lt;/li&gt;
&lt;li&gt;Caddy&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;使用多路复用i-o模型的服务器&#34;&gt;使用多路复用I/O模型的服务器&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;Nginx&lt;/li&gt;
&lt;li&gt;Netty&lt;/li&gt;
&lt;li&gt;Mina&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;参考资料&#34;&gt;参考资料&lt;/h2&gt;

&lt;p&gt;1, 《Netty权威指南 第二版》，李林峰&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>经济学人</title>
      <link>http://nituchao.com/te/</link>
      <pubDate>Mon, 20 Feb 2017 12:34:23 +0800</pubDate>
      
      <guid>http://nituchao.com/te/</guid>
      <description>

&lt;h2 id=&#34;2017年2月&#34;&gt;2017年2月&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://olno3yiqc.bkt.clouddn.com/blog/economist/2017/02/TE_2017.02.04.pdf&#34;&gt;TE_2017.02.04.pdf&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://olno3yiqc.bkt.clouddn.com/blog/economist/2017/02/TE_2017.02.04.epub&#34;&gt;TE_2017.02.04.epub&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://olno3yiqc.bkt.clouddn.com/blog/economist/2017/02/TE_2017.02.04.mobi&#34;&gt;TE_2017.02.04.mobi&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;br/&gt;&lt;/p&gt;

&lt;h2 id=&#34;2017年1月&#34;&gt;2017年1月&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://olno3yiqc.bkt.clouddn.com/blog/economist/2017/01/TE_2017.01.07.pdf&#34;&gt;TE_2017.01.07.pdf&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://olno3yiqc.bkt.clouddn.com/blog/economist/2017/01/TE_2017.01.07.epub&#34;&gt;TE_2017.01.07.epub&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://olno3yiqc.bkt.clouddn.com/blog/economist/2017/01/TE_2017.01.07.mobi&#34;&gt;TE_2017.01.07.mobi&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;br/&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://olno3yiqc.bkt.clouddn.com/blog/economist/2017/01/TE_2017.01.14.pdf&#34;&gt;TE_2017.01.14.pdf&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://olno3yiqc.bkt.clouddn.com/blog/economist/2017/01/TE_2017.01.14.epub&#34;&gt;TE_2017.01.14.epub&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://olno3yiqc.bkt.clouddn.com/blog/economist/2017/01/TE_2017.01.14.mobi&#34;&gt;TE_2017.01.14.mobi&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;br/&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://olno3yiqc.bkt.clouddn.com/blog/economist/2017/01/TE_2017.01.21.pdf&#34;&gt;TE_2017.01.21.pdf&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://olno3yiqc.bkt.clouddn.com/blog/economist/2017/01/TE_2017.01.21.epub&#34;&gt;TE_2017.01.21.epub&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://olno3yiqc.bkt.clouddn.com/blog/economist/2017/01/TE_2017.01.21.mobi&#34;&gt;TE_2017.01.21.mobi&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;br/&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://olno3yiqc.bkt.clouddn.com/blog/economist/2017/01/TE_2017.01.28.pdf&#34;&gt;TE_2017.01.28.pdf&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://olno3yiqc.bkt.clouddn.com/blog/economist/2017/01/TE_2017.01.28.epub&#34;&gt;TE_2017.01.28.epub&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://olno3yiqc.bkt.clouddn.com/blog/economist/2017/01/TE_2017.01.28.mobi&#34;&gt;TE_2017.01.28.mobi&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>设备</title>
      <link>http://nituchao.com/device/</link>
      <pubDate>Sat, 18 Feb 2017 12:34:23 +0800</pubDate>
      
      <guid>http://nituchao.com/device/</guid>
      <description>

&lt;p&gt;工作以后，每年都会给自己买几件称心的电子设备，它们总是会给生活带来各种惊喜。&lt;/p&gt;

&lt;h2 id=&#34;boox-max&#34;&gt;BOOX MAX&lt;/h2&gt;

&lt;p&gt;2016年底入手，13.3寸的电子墨水屏，Android系统，看PDF版的专业书的利器，另外它也支持MOBI，EPUB, TXT, DOC等常见文档格式。&lt;/p&gt;

&lt;h2 id=&#34;garmin-fenix-3hr&#34;&gt;Garmin Fenix 3HR&lt;/h2&gt;

&lt;p&gt;2016年初入手，当时是为了督促自己减肥，咬了咬牙买的，非常专业的运动手表，蓝宝石镜面，支持心率检测，支持GPS定位，做工精良。&lt;/p&gt;

&lt;h2 id=&#34;kindle-paperwhite-2&#34;&gt;Kindle Paperwhite 2&lt;/h2&gt;

&lt;p&gt;2015年初入手，6寸高分辨率电子墨水屏，自带背光灯，亚马逊原厂出品，看文史哲类的图书非常方便。&lt;/p&gt;

&lt;p&gt;记得当时多看部门有个编辑工位在我边上，她手上有各种型号的Kindle设备，我看了非常喜欢，就果断入手了这款。中间还找多看的朋友给刷了多看系统。后来发现多看系统虽然方便，但是很多图书不能更改字体，于是又刷回来Kindle原生系统，而且Kindle原生系统经过几次大版本更新后，也越来越好用。希望这个设备能多用几年。&lt;/p&gt;

&lt;h2 id=&#34;u-nas-home-nas&#34;&gt;U-NAS Home NAS&lt;/h2&gt;

&lt;p&gt;2016年底入手，4盘位的家用NAS，自己配了一块西数4T红盘，运行的是群辉操作系统，整体还算稳定。现在，我把自己所有的照片，视频，文档，电子书等资料都保存在这台NAS上。&lt;/p&gt;

&lt;h2 id=&#34;aoc-u2879vf-display&#34;&gt;AOC U2879VF Display&lt;/h2&gt;

&lt;p&gt;2016年中入手，28寸4K显示器。当时自己DIY了一台基于华擎Z170-ITX小主板的机器，该主板有DP接口可以支持4K显示器，于是入手了这款显示器。电脑上安装了Mac OS X和Windows 10两个系统。Mac OS X对4K显示器的支持非常赞，文字和图片显示效果非常优秀。Windows 10对高分屏的支持一般，很多软件在使用过程中会出现很多显示问题。&lt;/p&gt;

&lt;h2 id=&#34;miwifi-mini&#34;&gt;MIWIFI MINI&lt;/h2&gt;

&lt;p&gt;小米路由器MINI，年会中的奖品，留着自用了。小米路由器给我最大的感受就是设置界面简洁易用，设计感很强。而且，能实时查看当前连接的设备信息，以及设备的网速状况。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Paxos协议整理</title>
      <link>http://nituchao.com/post/2017/paxos-protocol/</link>
      <pubDate>Wed, 15 Feb 2017 10:13:27 +0800</pubDate>
      
      <guid>http://nituchao.com/post/2017/paxos-protocol/</guid>
      <description>

&lt;p&gt;Paxos是一种提高分布式系统容错性的一致性算法。&lt;/p&gt;

&lt;p&gt;其算法描述如下：&lt;/p&gt;

&lt;h2 id=&#34;阶段一&#34;&gt;阶段一&lt;/h2&gt;

&lt;p&gt;1，Proposer选择一个提案编号Mn，然后向Acceptor的某个超过半数的子集成员发送编号为Mn的Prepare请求。&lt;/p&gt;

&lt;p&gt;2，如果一个Acceptor收到一个编号为Mn的Prepare请求，且编号Mn大于该Acctpor已经响应的所有Prepare请求的编号，那么它就会将它已经批准过的最大编号的提案作为响应反馈给Proposer，同时该Acceptor会承诺不会再批准任何编号小于Mn的提案。&lt;/p&gt;

&lt;p&gt;举个例子来说，假定一个Acceptor已经响应过的所有Prepare请求对应的提案编号分别为1、2、&amp;hellip;、5和7，那么该Acceptor在接收一个编号为8的Prepare请求后，就会将编号为7的提案作为响应反馈给Proposer。&lt;/p&gt;

&lt;h2 id=&#34;阶段二&#34;&gt;阶段二&lt;/h2&gt;

&lt;p&gt;1，如果Proposer收到来自半数以上的Acceptor对于其发出的编号为Mn的Prepare请求的响应，那么它就会发送一个针对[Mn, Vn]提案的Accept请求给Acceptor。注意，Vn的值就是收到的响应中编号最大的提案的值，如果响应中不包含任何提案，那么它就是任意值。&lt;/p&gt;

&lt;p&gt;2，如果Acceptor收到这个针对[Mn, Vn]提案的Accept请求，只要改Acceptor尚未对编号大于Mn的Prepare请求作出响应，它就可以通过这个提案。&lt;/p&gt;

&lt;p&gt;当然，在实际运行过程中，每一个Proposer都有可能会产生多个提案，但只要每个Proposer都遵循如何所述的算法运行，就一定能够保证算法执行的正确性。值得一提的是，每个Proposer都可以在任意时刻丢弃一个提案，哪怕针对该提案的请求和响应在提案被丢弃后会到达，但根据Paxos算法的一系列规约，依然可以保证其在提案选定上的正确性。事实上，如果某个Proposer已经在视图生成编号更大的提案，那么丢弃一些就的提案未尝不是一个好的选择。因此，如果一个Acceptor因为已经收到过更大编号的Prepare请求而忽略某个编号更小的Prepare或者Accept请求，那么它也应当通知其对应的Proposer，以便该Proposer也能够将该提案进行丢弃&amp;ndash;这和上面&amp;rdquo;算法优化&amp;rdquo;部分中提到的提案丢弃是一致的。&lt;/p&gt;

&lt;h2 id=&#34;提案的获取&#34;&gt;提案的获取&lt;/h2&gt;

&lt;p&gt;现在，我们再来看看如何让Learner获取提案，大体可以有以下几种方案。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;方案一&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;Learner获取一个已经被选定的提案的前提是，该提案已经被半数以上的Acceptor批准。因此，最简单的做法就是一旦Acceptor批准了一个提案，就将该提案发送给所有的Leaner。&lt;/p&gt;

&lt;p&gt;很显然，这种做法虽然可以让Leaner尽快地获取被选定的提案，但是却需要让每个Acceptor与所有的Leaner逐个进行一次通信，通信的次数至少为二者个数的乘积。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;方案二&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;另一种可行的方案是，我们可以让所有的Acceptor将他们对提案的批准情况，统一发送给一个特定的Leaner(下文中我们将这样的Leaner称为&amp;rdquo;主Leaner&amp;rdquo;)，在不考虑拜占庭将军问题的前提下，我们假定Leaner之间可以通过消息通信来相互感知提案的选定情况。基于这样的前提，当主Leaner被通知一个提案已经被选定时，它会负责通知其他的Leaner。&lt;/p&gt;

&lt;p&gt;这种方案中，Acceptor首先会将得到批准的提案发送给主Learner，再由其同步给其他Leaner，因此较方案一而言，方案二虽然需要多一个步骤才能将提案通知到所有的Leaner，但其通信次数却大大减少了，通常只是Acceptor和Learner的个数总和。但同时，该方案引入了一个新的不稳定因素：主Learner随时可能出现故障。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;方案三&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;在讲解方案二的时候，我们提到，方案二最大的问题在于主Learner存在单点问题，即主Learner随时可能出现故障。因此，对方案二进行改进，可以将主Learner的范围扩大，即Acceptor可以将批准的提案发送给一个特定的Learner集合，该集合中的每个Learner都可以在一个提案被选定后通知所有其他的Learner。这个Learner集合中的Learner个数越多，可靠性就越好，但同时网络通信的复杂度也就越高。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>3PC协议整理</title>
      <link>http://nituchao.com/post/2017/three-phase-commit-protocol/</link>
      <pubDate>Wed, 15 Feb 2017 10:12:58 +0800</pubDate>
      
      <guid>http://nituchao.com/post/2017/three-phase-commit-protocol/</guid>
      <description>

&lt;p&gt;3PC，是Three-Phase Commit的缩写，即三阶段提交，是2PC的改进版，其将二阶段提交协议的&amp;rdquo;提交事务请求&amp;rdquo;过程一分为二，形成了由CanCommit、PreCommit和doCommit三个阶段组成的事务处理协议。&lt;/p&gt;

&lt;h2 id=&#34;阶段一-cancommit&#34;&gt;阶段一：CanCommit&lt;/h2&gt;

&lt;p&gt;1，事务询问&lt;/p&gt;

&lt;p&gt;协调者向所有的参与者发送一个包含事务内容的canCommit请求，询问是否可以执行事务提交操作，并开始等待个参与者的响应。&lt;/p&gt;

&lt;p&gt;2，各参与者向协调者反馈事务询问的响应&lt;/p&gt;

&lt;p&gt;参与者在接收到来自协调者的canCommit请求后，正常情况下，如果其自身认为可以顺利执行事务，那么会反馈Yes响应，并进入预备状态，否则反馈No响应。&lt;/p&gt;

&lt;h2 id=&#34;阶段二-precommit&#34;&gt;阶段二：PreCommit&lt;/h2&gt;

&lt;p&gt;在阶段二中，协调者会根据各参与者的反馈情况来决定是否可以进行事务的PreCommit操作，正常情况下，包含两种可能。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;执行事务预提交&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;假设协调者从所有的参与者获得的反馈都是Yes响应，那么就会执行事务预提交。&lt;/p&gt;

&lt;p&gt;1，发送预提交请求&lt;/p&gt;

&lt;p&gt;协调者向所有参与者节点发出preCommit的请求，并进入Prepared阶段。&lt;/p&gt;

&lt;p&gt;2，事务预提交&lt;/p&gt;

&lt;p&gt;参与者接收到preCommit请求后，会执行事务操作，并将Undo和Redo信息记录到事务日志中。&lt;/p&gt;

&lt;p&gt;3，各参与者向协调者反馈事务执行的响应&lt;/p&gt;

&lt;p&gt;如果参与者成功执行事务操作，那么就会反馈给协调者Ack响应，同时等待最终的指令：提交(commit)或终止(abort)。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;中断事务&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;假如任何一个参与者向协调者反馈了No响应，或者在等待超时之后，协调者尚无法接收到所有参与者的反馈响应，那么就会中断事务。&lt;/p&gt;

&lt;p&gt;1，发送中断请求&lt;/p&gt;

&lt;p&gt;协调者向所有参与者节点发出abort请求。&lt;/p&gt;

&lt;p&gt;2，中断事务&lt;/p&gt;

&lt;p&gt;无论是收到来自协调者的abort请求，或者是在等待协调者过程中出现超时，参与者都会中断事务。&lt;/p&gt;

&lt;h2 id=&#34;阶段三-docommit&#34;&gt;阶段三：doCommit&lt;/h2&gt;

&lt;p&gt;该阶段将进行真正的事务提交，会存在以下两种可能的情况。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;执行提交&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;1，发送提交请求&lt;/p&gt;

&lt;p&gt;进入这一阶段，假设协调者处于正常工作状态，并且它接收到了来自所有参与者的Ack响应，那么它将从&amp;rdquo;预提交&amp;rdquo;状态转换到&amp;rdquo;提交&amp;rdquo;状态，并向所有的参与者发送doCommit请求。&lt;/p&gt;

&lt;p&gt;2，事务提交&lt;/p&gt;

&lt;p&gt;参与者接收到doCommit请求后，会正式执行事务提交操作，并在完成提交之后释放在整个事务执行期间占用的事务资源。&lt;/p&gt;

&lt;p&gt;3，反馈事务提交结果&lt;/p&gt;

&lt;p&gt;参与者在完成事务提交之后，相协调者发送Ack消息。&lt;/p&gt;

&lt;p&gt;4，完成事务&lt;/p&gt;

&lt;p&gt;协调者接收到所有参与者反馈的Ack消息后，完成事务。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;中断事务&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;进入这一阶段，假设协调者处于正常工作状态，并且有任意一个参与者向协调者反馈了No响应，或者在等待超时之后，协调者尚无法接收到所有参与者的反馈响应，那么就会中断事务。&lt;/p&gt;

&lt;p&gt;1，发送中断请求。&lt;/p&gt;

&lt;p&gt;协调者向所有的参与者节点发送abort请求。&lt;/p&gt;

&lt;p&gt;2，事务回滚。&lt;/p&gt;

&lt;p&gt;参与者接收到abort请求后，会利用其在阶段二中记录的Undo信息来执行事务回滚操作，并在完成回滚之后释放在整个事务执行期间占用的资源。&lt;/p&gt;

&lt;p&gt;3，反馈事务回滚结果。&lt;/p&gt;

&lt;p&gt;参与者在完成事务回滚之后，向协调者发送Ack消息。&lt;/p&gt;

&lt;p&gt;4，中断事务。&lt;/p&gt;

&lt;p&gt;协调者接收到所有参与者反馈的Ack消息后，中断事务。&lt;/p&gt;

&lt;p&gt;需要注意的是，一旦进入阶段三，可能会存在以下两种故障：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;协调者出现问题&lt;/li&gt;
&lt;li&gt;协调者和参与者之间的网络出现故障。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;无论出现哪种情况，最终都会导致参与者无法及时接收老子协调者的doCommit或者abort请求，针对这样的异常情况，&lt;code&gt;参与者都会在等待超时之后，继续进行事务提交。&lt;/code&gt;&lt;/p&gt;

&lt;h2 id=&#34;优缺点&#34;&gt;优缺点&lt;/h2&gt;

&lt;p&gt;三阶段提交协议的优点：相较于二阶段提交协议，三阶段提交协议最大的优点就是降低了参与者的阻塞范围，并且能够出现单点故障后继续达成一致。&lt;/p&gt;

&lt;p&gt;三阶段提交协议的缺点：三阶段提交协议在去除阻塞的同时也引入了新的问题，那就是在参与者接收到preCommit消息后，如果网络出现分区，此时协调者所在的节点和参与者无法进行正常的网络通信，在这种情况下，该参与者依然会进行事务的提交，这必然出现数据不一致性。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>2PC协议整理</title>
      <link>http://nituchao.com/post/2017/two-phase-commit-protocol/</link>
      <pubDate>Wed, 15 Feb 2017 10:12:41 +0800</pubDate>
      
      <guid>http://nituchao.com/post/2017/two-phase-commit-protocol/</guid>
      <description>

&lt;p&gt;2PC，是Two-Phase Commit的缩写，即二阶段提交，是计算机网络尤其是在数据库领域内，为了使基于分布式系统架构下的所有节点在进行事务处理的过程中能够保持原子性和一致性而设计的一种算法。通常，二阶段提交协议也被认为是一种一致性协议，用来保证分布式系统数据的一致性。目前，绝大部分的关系型数据库都是采用二阶段提交协议来完成分布式事务处理的，利用该协议能够非常方便地完成所有分布式事务参与者的协调，统一决定事务的提交或回滚，从而能够有效地保证分布式数据一致性，因此二阶段提交协议被广泛地应用在许多分布式系统中。&lt;/p&gt;

&lt;h2 id=&#34;协议说明&#34;&gt;协议说明&lt;/h2&gt;

&lt;p&gt;顾名思义，二阶段提交协议是将事务的提交过程分成了两个阶段来进行处理，其执行流程如下：&lt;/p&gt;

&lt;h3 id=&#34;阶段一-提交事务请求&#34;&gt;阶段一：提交事务请求&lt;/h3&gt;

&lt;p&gt;1，事务询问&lt;/p&gt;

&lt;p&gt;协调者向所有的参与者发送事务内容，询问是否可以执行事务提交操作，并开始等待各参与者的响应。&lt;/p&gt;

&lt;p&gt;2，执行事务&lt;/p&gt;

&lt;p&gt;各参与者节点执行事务操作，并将Undo和Redo信息记入事务日志中。&lt;/p&gt;

&lt;p&gt;3，各参与者向协调者反馈事务询问的响应。&lt;/p&gt;

&lt;p&gt;如果参与者成功执行了事务操作，那么就反馈给协调者Yes响应，表示事务可以执行；如果参与者没有成功执行事务，那么就反馈给协调者No响应，表示事务不可以执行。&lt;/p&gt;

&lt;p&gt;由于上面讲述的内容在形式上近似是协调者组织各参与者对一次事务操作的投标表态过程，因此二阶段提交协议的阶段一也被称为&amp;rdquo;投票阶段&amp;rdquo;，即各参与者投票表明是否要继续执行接下去的事务操作。&lt;/p&gt;

&lt;h3 id=&#34;阶段二-执行事务提交&#34;&gt;阶段二：执行事务提交&lt;/h3&gt;

&lt;p&gt;在阶段二，协调者会根据各参与者的反馈情况来决定最终是否可以进行事务提交操作，正常情况下，包含以下两种可能。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;执行事务提交&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;加入协调者从所有的参与者获得的反馈都是Yes响应，那么就会执行事务提交。&lt;/p&gt;

&lt;p&gt;1，发送提交请求。&lt;/p&gt;

&lt;p&gt;协调者向所有参与者节点发出Commit请求。&lt;/p&gt;

&lt;p&gt;2，事务提交。&lt;/p&gt;

&lt;p&gt;参与者接收到Commit请求后，会正式执行事务提交操作，并在完成提交之后释放在整个事务执行期间占用的事务资源。&lt;/p&gt;

&lt;p&gt;3，反馈事务提交结果。&lt;/p&gt;

&lt;p&gt;参与者在完成事务提交之后，向协调者发送Ack消息。&lt;/p&gt;

&lt;p&gt;4，完成事务。&lt;/p&gt;

&lt;p&gt;协调者收到所有参与者反馈的Ack消息后，完成事务。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;中断事务&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;假如任何一个参与者向协调者反馈了No响应，或者在等待超时之后，协调者尚无法接收到所有参与者的反馈响应，那么就会中断事务。&lt;/p&gt;

&lt;p&gt;1，发送回滚请求&lt;/p&gt;

&lt;p&gt;协调者向所有参与者节点发出Rollback请求。&lt;/p&gt;

&lt;p&gt;2，事务回滚&lt;/p&gt;

&lt;p&gt;参与者接收到Rollback请求后，会利用其在阶段一中记录的Undo信息来执行事务回滚操作，并在完成回滚后释放在整个事务执行期间占用的资源。&lt;/p&gt;

&lt;p&gt;3，反馈事务回滚结果。&lt;/p&gt;

&lt;p&gt;参与者在完成事务回滚之后，向协调者发送Ack消息。&lt;/p&gt;

&lt;p&gt;4，中断事务&lt;/p&gt;

&lt;p&gt;协调者接收到所有参与者反馈的Ack消息后，完成事务中断。&lt;/p&gt;

&lt;p&gt;以上就是二阶段提交过程，前后两个阶段分别进行的处理逻辑。简单地讲，二阶段提交讲一个事务的处理过程分为了投票和执行两个阶段，其核心是对每个事务都采用先尝试后提交的处理方式，因此也可以将二阶段提交看做一个强一致性的算法。&lt;/p&gt;

&lt;h3 id=&#34;优缺点&#34;&gt;优缺点&lt;/h3&gt;

&lt;p&gt;二阶段提交协议的优点：原理简单，实现方便。&lt;/p&gt;

&lt;p&gt;二阶段提交协议的缺点：同步阻塞，单点问题，脑裂，太过保守。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;同步阻塞&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;二阶段提交协议的最明显也是最大的一个问题就是同步阻塞，这会极大地限制分布式系统的性能。在二阶段提交的执行过程中，所有参与该事务操作的逻辑都处于阻塞状态，也就是说，各个参与者在等待其他参与者相应的额过程中，将无法进行其他任何操作。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;单点问题&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;在上面的讲解过程中，相信读者可以看出，协调者的角色在整个二阶段提交协议中起到了非常重要的作用。一旦协调者出现问题，那么整个二阶段提交流程将无法运转，更为严重的是，如果协调者是在阶段二中出现问题的话，那么其他参与者将会一直处于锁定事务资源的状态中，而无法继续完成事务操作。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;数据不一致&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;在二阶段提交协议的阶段二，即执行事务提交的时候，当协调者向所有的参与者发送Commit请求之后，发生了局部网络异常或者是协调者在尚未发送完Commit请求之前自身发生了崩溃，导致最终只有部分参与者收到了Commit请求。于是，这部分收到了Commit请求的参与者就会进行事务的提交，而其他没有收到Commit请求的参与者则无法进行事务提交，于是整个分布式系统便出现了数据不一致的现象。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;太过保守&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;如果协调者指示参与者进行事务提交询问的过程中，参与者出现故障而导致协调者始终无法获取到所有参与者的相应信息的话，这时协调者只能依靠其自身的超时机制来判断是否需要中断事务，这样的策略显得比较保守。换句话说，二阶段提交协议咩有设计较为完善的容错机制，任意一个节点的失败都会导致整个事务的失败。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>MySQL提供的事务控制语句</title>
      <link>http://nituchao.com/post/2017/mysql-shi-wu-kong-zhi-yu-ju/</link>
      <pubDate>Tue, 14 Feb 2017 14:09:01 +0800</pubDate>
      
      <guid>http://nituchao.com/post/2017/mysql-shi-wu-kong-zhi-yu-ju/</guid>
      <description>

&lt;p&gt;在MySQL命令行的默认设置下，事务都是自动提交的，即执行SQL语句后就会马上执行&lt;code&gt;COMMIT&lt;/code&gt;操作。因此要显式地开启一个事务需要使用命令&lt;code&gt;BEGIN&lt;/code&gt;, &lt;code&gt;START TRANSACTION&lt;/code&gt;, 或者执行命令&lt;code&gt;SET AUTOCOMMIT=0&lt;/code&gt;, 禁用当前会话的自动提交。&lt;/p&gt;

&lt;p&gt;每个数据库厂商自动提交的设置都会不相同，每个DBA或开发人员需要非常明白这一点，这对之后的SQL编程会有非凡的意义，因此用户不能以之前的经验来判断MySQL数据库的运行方式。&lt;/p&gt;

&lt;p&gt;MySQL为开发者提供了三种类型的事务，分别是扁平化事务，带保存点的事务，链式事务。通过带保存点的事务还可以模拟实现嵌套事务。&lt;/p&gt;

&lt;h3 id=&#34;start-transaction-begin&#34;&gt;START TRANSACTION | BEGIN&lt;/h3&gt;

&lt;p&gt;显式地开启一个事务。&lt;/p&gt;

&lt;h3 id=&#34;commit&#34;&gt;COMMIT&lt;/h3&gt;

&lt;p&gt;要想使用这个语句的最简形式，只需要发出&lt;code&gt;COMMIT&lt;/code&gt;。也可以更详细一点，写为&lt;code&gt;COMMIT WORK&lt;/code&gt;, 不过这两者几乎是等价的。&lt;code&gt;COMMIT&lt;/code&gt;会提交事务，并使得已对数据库做的修改称为永久性的。&lt;/p&gt;

&lt;h3 id=&#34;rollback&#34;&gt;ROLLBACK&lt;/h3&gt;

&lt;p&gt;要想使用这个语句的最简形式，只需要发出&lt;code&gt;ROLLBACK&lt;/code&gt;。同样地，也可以写为&lt;code&gt;ROLLBACK WORK&lt;/code&gt;，但两者几乎是等价的。回滚会结束用户的事务，并撤销正在进行的所有未提交的修改。&lt;/p&gt;

&lt;h3 id=&#34;savepoint-identity&#34;&gt;SAVEPOINT identity&lt;/h3&gt;

&lt;p&gt;&lt;code&gt;SAVEPOINT&lt;/code&gt;允许在事务中创建一个保存点，一个事务中可以有多个&lt;code&gt;SAVEPOINT&lt;/code&gt;。&lt;/p&gt;

&lt;h3 id=&#34;release-savepoint-identity&#34;&gt;RELEASE SAVEPOINT identity&lt;/h3&gt;

&lt;p&gt;删除一个事务的保存点，当没有一个保存点执行这语句时，会抛出一个异常。&lt;/p&gt;

&lt;h3 id=&#34;rollback-to-savepoint-identity&#34;&gt;ROLLBACK TO [SAVEPOINT] identity&lt;/h3&gt;

&lt;p&gt;这个语句与&lt;code&gt;SAVEPOINT&lt;/code&gt;命令一起使用。可以把事务回滚到标记点，而不回滚在此标记点之前的任何工作。&lt;/p&gt;

&lt;p&gt;例如，可以发出两调&lt;code&gt;UPDATE&lt;/code&gt;语句，后面跟一个&lt;code&gt;SAVEPOINT&lt;/code&gt;, 然后又是两条&lt;code&gt;DELETE&lt;/code&gt;语句。如果执行&lt;code&gt;DELETE&lt;/code&gt;语句期间出现了某种异常情况，并且捕获到这个异常，同时发出了&lt;code&gt;ROLLBACK TO SAVEPOINT&lt;/code&gt;命令，事务就会回滚到指定的SAVEPOINT，撤销&lt;code&gt;DELETE&lt;/code&gt;完成的所有工作，而&lt;code&gt;UPDATE&lt;/code&gt;语句完成的工作不受影响。&lt;/p&gt;

&lt;h3 id=&#34;set-transaction&#34;&gt;SET TRANSACTION&lt;/h3&gt;

&lt;p&gt;这个语句用来设置事务的隔离级别。&lt;/p&gt;

&lt;p&gt;InnoDB存储引擎提供的事务隔离级别有：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;READ UNCOMMITED&lt;/li&gt;
&lt;li&gt;READ COMMITTED&lt;/li&gt;
&lt;li&gt;REPEATABLE READ&lt;/li&gt;
&lt;li&gt;SERIALIZABLE&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;code&gt;START TRANSACTION&lt;/code&gt;, &lt;code&gt;BEGIN&lt;/code&gt;语句都可以在MySQL命令行下显示地开启一个事务。但是在存储过程中，MySQL数据库的分析器会自动将BEGIN识别为BEGIN&amp;hellip;END, 因此在存储过程中只能使用&lt;code&gt;START TRANSACTION&lt;/code&gt;语句来开启一个事务。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;COMMIT&lt;/code&gt;和&lt;code&gt;COMMIT WORK&lt;/code&gt;语句基本是一致的，都是用来提交事务。不同之处在于&lt;code&gt;COMMIT WORK&lt;/code&gt;用来控制事务结束后的行为是&lt;code&gt;CHAIN&lt;/code&gt;还是&lt;code&gt;RELEASE&lt;/code&gt;的。如果是&lt;code&gt;CHAIN&lt;/code&gt;方式，那么事务就变成了链事务。&lt;/p&gt;

&lt;p&gt;用户可以通过参数&lt;code&gt;completion_type&lt;/code&gt;来进行控制，该参数默认为0，表示没有任何操作。&lt;/p&gt;

&lt;p&gt;当参数&lt;code&gt;completion_type&lt;/code&gt;的值为1时，&lt;code&gt;COMMIT WORK&lt;/code&gt;等同于&lt;code&gt;COMMIT AND CHAIN&lt;/code&gt;, 表示马上自动开启一个相同隔离级别的事务。&lt;/p&gt;

&lt;p&gt;当参数&lt;code&gt;completion_type&lt;/code&gt;的值为2时，&lt;code&gt;COMMIT WORK&lt;/code&gt;等同于&lt;code&gt;COMMIT AND RELEASE&lt;/code&gt;, 在事务提交后会自动断开与服务器的连接。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>计算机</title>
      <link>http://nituchao.com/book/</link>
      <pubDate>Sun, 12 Feb 2017 17:51:45 +0800</pubDate>
      
      <guid>http://nituchao.com/book/</guid>
      <description>

&lt;p&gt;最近几年，大大小小的项目开发了不少，越来越觉得理论知识不够用，于是决心利用空余时间学习行业内的权威书籍。&lt;/p&gt;

&lt;p&gt;这些列出来的书，都完整读过，有些在不同年份读过多次，也都一一列出。&lt;/p&gt;

&lt;h2 id=&#34;java&#34;&gt;Java&lt;/h2&gt;

&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th align=&#34;left&#34;&gt;名称&lt;/th&gt;
&lt;th align=&#34;left&#34;&gt;作者&lt;/th&gt;
&lt;th align=&#34;left&#34;&gt;页数&lt;/th&gt;
&lt;th align=&#34;left&#34;&gt;评分&lt;/th&gt;
&lt;th align=&#34;left&#34;&gt;年份&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;

&lt;tbody&gt;
&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;Java虚拟机精讲&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;高翔龙&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;280&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;※※※&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;2016\2017&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;Effective Java中文版&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;俞黎敏&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;287&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;※※※※&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;2016&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;Java并发编程实战&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;Brian Goetz/董云兰&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;293&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;※※※&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;2017&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;Java多线程编程核心技术&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;高洪岩&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;306&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;※※※&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;2016&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;Java 7并发编程实战手册&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;申邵勇/俞黎敏&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;339&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;※※※&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;2016&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;Spring揭秘&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;王福强&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;680&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;※※※&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;2016&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;Netty权威指南&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;李林峰&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;572&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;※※※※&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;2015\2016&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;h2 id=&#34;mysql&#34;&gt;MySQL&lt;/h2&gt;

&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th align=&#34;left&#34;&gt;名称&lt;/th&gt;
&lt;th align=&#34;left&#34;&gt;作者&lt;/th&gt;
&lt;th align=&#34;left&#34;&gt;页数&lt;/th&gt;
&lt;th align=&#34;left&#34;&gt;评分&lt;/th&gt;
&lt;th align=&#34;left&#34;&gt;年份&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;

&lt;tbody&gt;
&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;MySQL技术内幕 : InnoDB存储引擎&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;姜承尧&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;436&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;※※※※&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;2017&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;MySQL性能调优与架构设计&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;简朝阳&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;392&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;※※※※&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;2016&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;高性能MySQL&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;Baron Schwartz/宁海元&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;764&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;※※※※&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;2017&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;高可用MySQL&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;Charles Bell/宁青&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;680&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;※※※※&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;2017&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;Effective MySQL之备份与恢复&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;Ronald Bradford/张骏温&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;283&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;※※※&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;2017&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;Effective MySQL之SQL语句最优化&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;Ronald Bradford/李雪锋&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;201&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;※※※&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;2017&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;Effective MySQL之深入理解复制技术&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;Ronald Bradford/李雪锋&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;309&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;※※※&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;2017&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;h2 id=&#34;redis&#34;&gt;Redis&lt;/h2&gt;

&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th align=&#34;left&#34;&gt;名称&lt;/th&gt;
&lt;th align=&#34;left&#34;&gt;作者&lt;/th&gt;
&lt;th align=&#34;left&#34;&gt;页数&lt;/th&gt;
&lt;th align=&#34;left&#34;&gt;评分&lt;/th&gt;
&lt;th align=&#34;left&#34;&gt;年份&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;

&lt;tbody&gt;
&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;Redis设计与实现&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;黄建宏&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;388&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;※※※※&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;2017&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;Redis实战&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;Josiah L. Carlson/黄建宏&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;300&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;※※&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;2016&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;h2 id=&#34;linux&#34;&gt;Linux&lt;/h2&gt;

&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th align=&#34;left&#34;&gt;名称&lt;/th&gt;
&lt;th align=&#34;left&#34;&gt;作者&lt;/th&gt;
&lt;th align=&#34;left&#34;&gt;页数&lt;/th&gt;
&lt;th align=&#34;left&#34;&gt;评分&lt;/th&gt;
&lt;th align=&#34;left&#34;&gt;年份&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;

&lt;tbody&gt;
&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;理解Unix进程&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;Jesse Storimer&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;116&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;※※※&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;Linux高性能服务器编程&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;游双&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;360&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;※※※&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;高性能Linux服务器构建实践：运维监控、性能调优与集群应用&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;高俊峰&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;452&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;※※※&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;h2 id=&#34;tcp-ip&#34;&gt;TCP/IP&lt;/h2&gt;

&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th align=&#34;left&#34;&gt;名称&lt;/th&gt;
&lt;th align=&#34;left&#34;&gt;作者&lt;/th&gt;
&lt;th align=&#34;left&#34;&gt;页数&lt;/th&gt;
&lt;th align=&#34;left&#34;&gt;评分&lt;/th&gt;
&lt;th align=&#34;left&#34;&gt;年份&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;

&lt;tbody&gt;
&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;TCP/IP详解·卷一：协议&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;W.Richard Stevens/范建华&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;423&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;※※※&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;2017&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;h2 id=&#34;mq-amqp&#34;&gt;MQ/AMQP&lt;/h2&gt;

&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th align=&#34;left&#34;&gt;名称&lt;/th&gt;
&lt;th align=&#34;left&#34;&gt;作者&lt;/th&gt;
&lt;th align=&#34;left&#34;&gt;页数&lt;/th&gt;
&lt;th align=&#34;left&#34;&gt;评分&lt;/th&gt;
&lt;th align=&#34;left&#34;&gt;年份&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;

&lt;tbody&gt;
&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;RabbitMQ实战，高效部署分布式消息队列&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;Alvarao Videla/汪佳南&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;334&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;※※※&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;2017&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;Spring AMQP Reference&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;Mark Pollack/Mark Fisher&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;115&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;※※※&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;2017&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;h2 id=&#34;设计模式&#34;&gt;设计模式&lt;/h2&gt;

&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th align=&#34;left&#34;&gt;名称&lt;/th&gt;
&lt;th align=&#34;left&#34;&gt;作者&lt;/th&gt;
&lt;th align=&#34;left&#34;&gt;页数&lt;/th&gt;
&lt;th align=&#34;left&#34;&gt;评分&lt;/th&gt;
&lt;th align=&#34;left&#34;&gt;年份&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;

&lt;tbody&gt;
&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;设计模式之禅&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;秦小波&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;555&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;※※※&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;2017&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;h2 id=&#34;分布式计算&#34;&gt;分布式计算&lt;/h2&gt;

&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th align=&#34;left&#34;&gt;名称&lt;/th&gt;
&lt;th align=&#34;left&#34;&gt;作者&lt;/th&gt;
&lt;th align=&#34;left&#34;&gt;页数&lt;/th&gt;
&lt;th align=&#34;left&#34;&gt;评分&lt;/th&gt;
&lt;th align=&#34;left&#34;&gt;年份&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;

&lt;tbody&gt;
&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;分布式服务框架：原理与实践&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;李林峰&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;312&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;※※※&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;2017&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;从Paxos到Zookeeper：分布式一致性原理与实践&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;倪超&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;422&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;※※※※&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;2017&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;h2 id=&#34;大数据处理&#34;&gt;大数据处理&lt;/h2&gt;

&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th align=&#34;left&#34;&gt;名称&lt;/th&gt;
&lt;th align=&#34;left&#34;&gt;作者&lt;/th&gt;
&lt;th align=&#34;left&#34;&gt;页数&lt;/th&gt;
&lt;th align=&#34;left&#34;&gt;评分&lt;/th&gt;
&lt;th align=&#34;left&#34;&gt;年份&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;

&lt;tbody&gt;
&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;Hive编程指南&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;Edward Capriolo/曹坤&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;318&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;※※※&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;2016&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;HBase权威指南&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;Lars George/代志远&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;522&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;※※※&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;2015&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;Hadoop技术内幕：深入解析YARN架构设计与实现原理&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;董西成&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;396&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;※※※&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;2015&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;Hadoop技术内幕：深入解析MapReduce架构设计与实现原理&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;董西成&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;332&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;※※※&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;2015\2016&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;快学Scala&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;C.S.霍夫曼/高翔宇&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;408&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;※※※&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;2016&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;深入理解Scala&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;Joshua D.Suereth/苏瑞茨&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;288&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;※※※&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;2016&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;Scala编程&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;Martin Odersky/黄海旭/高宇翔&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;492&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;※※&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;2016&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;h2 id=&#34;其他&#34;&gt;其他&lt;/h2&gt;

&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th align=&#34;left&#34;&gt;名称&lt;/th&gt;
&lt;th align=&#34;left&#34;&gt;作者&lt;/th&gt;
&lt;th align=&#34;left&#34;&gt;页数&lt;/th&gt;
&lt;th align=&#34;left&#34;&gt;评分&lt;/th&gt;
&lt;th align=&#34;left&#34;&gt;年份&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;

&lt;tbody&gt;
&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;jQuery基础教程&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;Jonathan Chaffer/李松峰&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;318&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;※※※&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;2016&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
</description>
    </item>
    
    <item>
      <title>JVM调试相关的配置参数</title>
      <link>http://nituchao.com/post/2016/jvm-tiao-shi-xiang-guan-de-pei-zhi-can-shu/</link>
      <pubDate>Thu, 29 Dec 2016 20:15:12 +0800</pubDate>
      
      <guid>http://nituchao.com/post/2016/jvm-tiao-shi-xiang-guan-de-pei-zhi-can-shu/</guid>
      <description>&lt;p&gt;本文将详细分析JVM配置参数中，与调试相关的配置参数，这些配置参数将方便开发人员跟踪JVM运行，查看JVM日志等相关工作。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>JVM行为相关的配置参数</title>
      <link>http://nituchao.com/post/2016/jvm-xing-wei-xiang-guan-de-pei-zhi-can-shu/</link>
      <pubDate>Thu, 29 Dec 2016 13:53:12 +0800</pubDate>
      
      <guid>http://nituchao.com/post/2016/jvm-xing-wei-xiang-guan-de-pei-zhi-can-shu/</guid>
      <description>&lt;p&gt;文本将分析与JVM行为相关的配置参数。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>JVM G1收集器配置参数</title>
      <link>http://nituchao.com/post/2016/jvm-g1-shou-ji-qi-pei-zhi-can-shu/</link>
      <pubDate>Thu, 29 Dec 2016 12:22:12 +0800</pubDate>
      
      <guid>http://nituchao.com/post/2016/jvm-g1-shou-ji-qi-pei-zhi-can-shu/</guid>
      <description>&lt;p&gt;G1收集器配置参数&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>JVM常用的非标准配置参数</title>
      <link>http://nituchao.com/post/2016/jvm-chan-yong-de-fei-biao-zhun-pei-zhi-can-shu/</link>
      <pubDate>Thu, 29 Dec 2016 10:18:12 +0800</pubDate>
      
      <guid>http://nituchao.com/post/2016/jvm-chan-yong-de-fei-biao-zhun-pei-zhi-can-shu/</guid>
      <description>&lt;p&gt;本文将研究JVM常见常见的非标准配置参数。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>JVM性能相关的配置参数</title>
      <link>http://nituchao.com/post/2016/jvm-xing-neng-xiang-guan-de-pei-zhi-can-shu/</link>
      <pubDate>Thu, 29 Dec 2016 09:30:12 +0800</pubDate>
      
      <guid>http://nituchao.com/post/2016/jvm-xing-neng-xiang-guan-de-pei-zhi-can-shu/</guid>
      <description>&lt;p&gt;本问将介绍JVM性能相关的配置参数。&lt;/p&gt;
</description>
    </item>
    
  </channel>
</rss>