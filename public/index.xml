<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>泥土巢</title>
    <link>http://nituchao.com/index.xml</link>
    <description>Recent content on 泥土巢</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh-CN</language>
    <copyright>Copyright (c) 2017, nituchao | All rights reserved.</copyright>
    <lastBuildDate>Mon, 20 Feb 2017 12:34:23 +0800</lastBuildDate>
    <atom:link href="http://nituchao.com/index.xml" rel="self" type="application/rss+xml" />
    
    <item>
      <title>经济学人</title>
      <link>http://nituchao.com/te/</link>
      <pubDate>Mon, 20 Feb 2017 12:34:23 +0800</pubDate>
      
      <guid>http://nituchao.com/te/</guid>
      <description>

&lt;h2 id=&#34;2017年2月&#34;&gt;2017年2月&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://olno3yiqc.bkt.clouddn.com/blog/economist/2017/02/TE_2017.02.04.pdf&#34;&gt;TE_2017.02.04.pdf&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://olno3yiqc.bkt.clouddn.com/blog/economist/2017/02/TE_2017.02.04.epub&#34;&gt;TE_2017.02.04.epub&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://olno3yiqc.bkt.clouddn.com/blog/economist/2017/02/TE_2017.02.04.mobi&#34;&gt;TE_2017.02.04.mobi&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;br/&gt;&lt;/p&gt;

&lt;h2 id=&#34;2017年1月&#34;&gt;2017年1月&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://olno3yiqc.bkt.clouddn.com/blog/economist/2017/01/TE_2017.01.07.pdf&#34;&gt;TE_2017.01.07.pdf&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://olno3yiqc.bkt.clouddn.com/blog/economist/2017/01/TE_2017.01.07.epub&#34;&gt;TE_2017.01.07.epub&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://olno3yiqc.bkt.clouddn.com/blog/economist/2017/01/TE_2017.01.07.mobi&#34;&gt;TE_2017.01.07.mobi&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;br/&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://olno3yiqc.bkt.clouddn.com/blog/economist/2017/01/TE_2017.01.14.pdf&#34;&gt;TE_2017.01.14.pdf&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://olno3yiqc.bkt.clouddn.com/blog/economist/2017/01/TE_2017.01.14.epub&#34;&gt;TE_2017.01.14.epub&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://olno3yiqc.bkt.clouddn.com/blog/economist/2017/01/TE_2017.01.14.mobi&#34;&gt;TE_2017.01.14.mobi&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;br/&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://olno3yiqc.bkt.clouddn.com/blog/economist/2017/01/TE_2017.01.21.pdf&#34;&gt;TE_2017.01.21.pdf&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://olno3yiqc.bkt.clouddn.com/blog/economist/2017/01/TE_2017.01.21.epub&#34;&gt;TE_2017.01.21.epub&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://olno3yiqc.bkt.clouddn.com/blog/economist/2017/01/TE_2017.01.21.mobi&#34;&gt;TE_2017.01.21.mobi&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;br/&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://olno3yiqc.bkt.clouddn.com/blog/economist/2017/01/TE_2017.01.28.pdf&#34;&gt;TE_2017.01.28.pdf&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://olno3yiqc.bkt.clouddn.com/blog/economist/2017/01/TE_2017.01.28.epub&#34;&gt;TE_2017.01.28.epub&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://olno3yiqc.bkt.clouddn.com/blog/economist/2017/01/TE_2017.01.28.mobi&#34;&gt;TE_2017.01.28.mobi&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>设备</title>
      <link>http://nituchao.com/device/</link>
      <pubDate>Sat, 18 Feb 2017 12:34:23 +0800</pubDate>
      
      <guid>http://nituchao.com/device/</guid>
      <description>

&lt;p&gt;工作以后，每年都会给自己买几件称心的电子设备，它们总是会给生活带来各种惊喜。&lt;/p&gt;

&lt;h2 id=&#34;boox-max&#34;&gt;BOOX MAX&lt;/h2&gt;

&lt;p&gt;2016年底入手，13.3寸的电子墨水屏，Android系统，看PDF版的专业书的利器，另外它也支持MOBI，EPUB, TXT, DOC等常见文档格式。&lt;/p&gt;

&lt;h2 id=&#34;garmin-fenix-3hr&#34;&gt;Garmin Fenix 3HR&lt;/h2&gt;

&lt;p&gt;2016年初入手，当时是为了督促自己减肥，咬了咬牙买的，非常专业的运动手表，蓝宝石镜面，支持心率检测，支持GPS定位，做工精良。&lt;/p&gt;

&lt;h2 id=&#34;kindle-paperwhite-2&#34;&gt;Kindle Paperwhite 2&lt;/h2&gt;

&lt;p&gt;2015年初入手，6寸高分辨率电子墨水屏，自带背光灯，亚马逊原厂出品，看文史哲类的图书非常方便。&lt;/p&gt;

&lt;p&gt;记得当时多看部门有个编辑工位在我边上，她手上有各种型号的Kindle设备，我看了非常喜欢，就果断入手了这款。中间还找多看的朋友给刷了多看系统。后来发现多看系统虽然方便，但是很多图书不能更改字体，于是又刷回来Kindle原生系统，而且Kindle原生系统经过几次大版本更新后，也越来越好用。希望这个设备能多用几年。&lt;/p&gt;

&lt;h2 id=&#34;u-nas-home-nas&#34;&gt;U-NAS Home NAS&lt;/h2&gt;

&lt;p&gt;2016年底入手，4盘位的家用NAS，自己配了一块西数4T红盘，运行的是群辉操作系统，整体还算稳定。现在，我把自己所有的照片，视频，文档，电子书等资料都保存在这台NAS上。&lt;/p&gt;

&lt;h2 id=&#34;aoc-u2879vf-display&#34;&gt;AOC U2879VF Display&lt;/h2&gt;

&lt;p&gt;2016年中入手，28寸4K显示器。当时自己DIY了一台基于华擎Z170-ITX小主板的机器，该主板有DP接口可以支持4K显示器，于是入手了这款显示器。电脑上安装了Mac OS X和Windows 10两个系统。Mac OS X对4K显示器的支持非常赞，文字和图片显示效果非常优秀。Windows 10对高分屏的支持一般，很多软件在使用过程中会出现很多显示问题。&lt;/p&gt;

&lt;h2 id=&#34;miwifi-mini&#34;&gt;MIWIFI MINI&lt;/h2&gt;

&lt;p&gt;小米路由器MINI，年会中的奖品，留着自用了。小米路由器给我最大的感受就是设置界面简洁易用，设计感很强。而且，能实时查看当前连接的设备信息，以及设备的网速状况。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Paxos协议整理</title>
      <link>http://nituchao.com/post/2017/paxos-protocol/</link>
      <pubDate>Wed, 15 Feb 2017 10:13:27 +0800</pubDate>
      
      <guid>http://nituchao.com/post/2017/paxos-protocol/</guid>
      <description>

&lt;p&gt;Paxos是一种提高分布式系统容错性的一致性算法。&lt;/p&gt;

&lt;p&gt;其算法描述如下：&lt;/p&gt;

&lt;h2 id=&#34;阶段一&#34;&gt;阶段一&lt;/h2&gt;

&lt;p&gt;1，Proposer选择一个提案编号Mn，然后向Acceptor的某个超过半数的子集成员发送编号为Mn的Prepare请求。&lt;/p&gt;

&lt;p&gt;2，如果一个Acceptor收到一个编号为Mn的Prepare请求，且编号Mn大于该Acctpor已经响应的所有Prepare请求的编号，那么它就会将它已经批准过的最大编号的提案作为响应反馈给Proposer，同时该Acceptor会承诺不会再批准任何编号小于Mn的提案。&lt;/p&gt;

&lt;p&gt;举个例子来说，假定一个Acceptor已经响应过的所有Prepare请求对应的提案编号分别为1、2、&amp;hellip;、5和7，那么该Acceptor在接收一个编号为8的Prepare请求后，就会将编号为7的提案作为响应反馈给Proposer。&lt;/p&gt;

&lt;h2 id=&#34;阶段二&#34;&gt;阶段二&lt;/h2&gt;

&lt;p&gt;1，如果Proposer收到来自半数以上的Acceptor对于其发出的编号为Mn的Prepare请求的响应，那么它就会发送一个针对[Mn, Vn]提案的Accept请求给Acceptor。注意，Vn的值就是收到的响应中编号最大的提案的值，如果响应中不包含任何提案，那么它就是任意值。&lt;/p&gt;

&lt;p&gt;2，如果Acceptor收到这个针对[Mn, Vn]提案的Accept请求，只要改Acceptor尚未对编号大于Mn的Prepare请求作出响应，它就可以通过这个提案。&lt;/p&gt;

&lt;p&gt;当然，在实际运行过程中，每一个Proposer都有可能会产生多个提案，但只要每个Proposer都遵循如何所述的算法运行，就一定能够保证算法执行的正确性。值得一提的是，每个Proposer都可以在任意时刻丢弃一个提案，哪怕针对该提案的请求和响应在提案被丢弃后会到达，但根据Paxos算法的一系列规约，依然可以保证其在提案选定上的正确性。事实上，如果某个Proposer已经在视图生成编号更大的提案，那么丢弃一些就的提案未尝不是一个好的选择。因此，如果一个Acceptor因为已经收到过更大编号的Prepare请求而忽略某个编号更小的Prepare或者Accept请求，那么它也应当通知其对应的Proposer，以便该Proposer也能够将该提案进行丢弃&amp;ndash;这和上面&amp;rdquo;算法优化&amp;rdquo;部分中提到的提案丢弃是一致的。&lt;/p&gt;

&lt;h2 id=&#34;提案的获取&#34;&gt;提案的获取&lt;/h2&gt;

&lt;p&gt;现在，我们再来看看如何让Learner获取提案，大体可以有以下几种方案。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;方案一&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;Learner获取一个已经被选定的提案的前提是，该提案已经被半数以上的Acceptor批准。因此，最简单的做法就是一旦Acceptor批准了一个提案，就将该提案发送给所有的Leaner。&lt;/p&gt;

&lt;p&gt;很显然，这种做法虽然可以让Leaner尽快地获取被选定的提案，但是却需要让每个Acceptor与所有的Leaner逐个进行一次通信，通信的次数至少为二者个数的乘积。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;方案二&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;另一种可行的方案是，我们可以让所有的Acceptor将他们对提案的批准情况，统一发送给一个特定的Leaner(下文中我们将这样的Leaner称为&amp;rdquo;主Leaner&amp;rdquo;)，在不考虑拜占庭将军问题的前提下，我们假定Leaner之间可以通过消息通信来相互感知提案的选定情况。基于这样的前提，当主Leaner被通知一个提案已经被选定时，它会负责通知其他的Leaner。&lt;/p&gt;

&lt;p&gt;这种方案中，Acceptor首先会将得到批准的提案发送给主Learner，再由其同步给其他Leaner，因此较方案一而言，方案二虽然需要多一个步骤才能将提案通知到所有的Leaner，但其通信次数却大大减少了，通常只是Acceptor和Learner的个数总和。但同时，该方案引入了一个新的不稳定因素：主Learner随时可能出现故障。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;方案三&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;在讲解方案二的时候，我们提到，方案二最大的问题在于主Learner存在单点问题，即主Learner随时可能出现故障。因此，对方案二进行改进，可以将主Learner的范围扩大，即Acceptor可以将批准的提案发送给一个特定的Learner集合，该集合中的每个Learner都可以在一个提案被选定后通知所有其他的Learner。这个Learner集合中的Learner个数越多，可靠性就越好，但同时网络通信的复杂度也就越高。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>3PC协议整理</title>
      <link>http://nituchao.com/post/2017/three-phase-commit-protocol/</link>
      <pubDate>Wed, 15 Feb 2017 10:12:58 +0800</pubDate>
      
      <guid>http://nituchao.com/post/2017/three-phase-commit-protocol/</guid>
      <description>

&lt;p&gt;3PC，是Three-Phase Commit的缩写，即三阶段提交，是2PC的改进版，其将二阶段提交协议的&amp;rdquo;提交事务请求&amp;rdquo;过程一分为二，形成了由CanCommit、PreCommit和doCommit三个阶段组成的事务处理协议。&lt;/p&gt;

&lt;h2 id=&#34;阶段一-cancommit&#34;&gt;阶段一：CanCommit&lt;/h2&gt;

&lt;p&gt;1，事务询问&lt;/p&gt;

&lt;p&gt;协调者向所有的参与者发送一个包含事务内容的canCommit请求，询问是否可以执行事务提交操作，并开始等待个参与者的响应。&lt;/p&gt;

&lt;p&gt;2，各参与者向协调者反馈事务询问的响应&lt;/p&gt;

&lt;p&gt;参与者在接收到来自协调者的canCommit请求后，正常情况下，如果其自身认为可以顺利执行事务，那么会反馈Yes响应，并进入预备状态，否则反馈No响应。&lt;/p&gt;

&lt;h2 id=&#34;阶段二-precommit&#34;&gt;阶段二：PreCommit&lt;/h2&gt;

&lt;p&gt;在阶段二中，协调者会根据各参与者的反馈情况来决定是否可以进行事务的PreCommit操作，正常情况下，包含两种可能。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;执行事务预提交&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;假设协调者从所有的参与者获得的反馈都是Yes响应，那么就会执行事务预提交。&lt;/p&gt;

&lt;p&gt;1，发送预提交请求&lt;/p&gt;

&lt;p&gt;协调者向所有参与者节点发出preCommit的请求，并进入Prepared阶段。&lt;/p&gt;

&lt;p&gt;2，事务预提交&lt;/p&gt;

&lt;p&gt;参与者接收到preCommit请求后，会执行事务操作，并将Undo和Redo信息记录到事务日志中。&lt;/p&gt;

&lt;p&gt;3，各参与者向协调者反馈事务执行的响应&lt;/p&gt;

&lt;p&gt;如果参与者成功执行事务操作，那么就会反馈给协调者Ack响应，同时等待最终的指令：提交(commit)或终止(abort)。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;中断事务&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;假如任何一个参与者向协调者反馈了No响应，或者在等待超时之后，协调者尚无法接收到所有参与者的反馈响应，那么就会中断事务。&lt;/p&gt;

&lt;p&gt;1，发送中断请求&lt;/p&gt;

&lt;p&gt;协调者向所有参与者节点发出abort请求。&lt;/p&gt;

&lt;p&gt;2，中断事务&lt;/p&gt;

&lt;p&gt;无论是收到来自协调者的abort请求，或者是在等待协调者过程中出现超时，参与者都会中断事务。&lt;/p&gt;

&lt;h2 id=&#34;阶段三-docommit&#34;&gt;阶段三：doCommit&lt;/h2&gt;

&lt;p&gt;该阶段将进行真正的事务提交，会存在以下两种可能的情况。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;执行提交&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;1，发送提交请求&lt;/p&gt;

&lt;p&gt;进入这一阶段，假设协调者处于正常工作状态，并且它接收到了来自所有参与者的Ack响应，那么它将从&amp;rdquo;预提交&amp;rdquo;状态转换到&amp;rdquo;提交&amp;rdquo;状态，并向所有的参与者发送doCommit请求。&lt;/p&gt;

&lt;p&gt;2，事务提交&lt;/p&gt;

&lt;p&gt;参与者接收到doCommit请求后，会正式执行事务提交操作，并在完成提交之后释放在整个事务执行期间占用的事务资源。&lt;/p&gt;

&lt;p&gt;3，反馈事务提交结果&lt;/p&gt;

&lt;p&gt;参与者在完成事务提交之后，相协调者发送Ack消息。&lt;/p&gt;

&lt;p&gt;4，完成事务&lt;/p&gt;

&lt;p&gt;协调者接收到所有参与者反馈的Ack消息后，完成事务。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;中断事务&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;进入这一阶段，假设协调者处于正常工作状态，并且有任意一个参与者向协调者反馈了No响应，或者在等待超时之后，协调者尚无法接收到所有参与者的反馈响应，那么就会中断事务。&lt;/p&gt;

&lt;p&gt;1，发送中断请求。&lt;/p&gt;

&lt;p&gt;协调者向所有的参与者节点发送abort请求。&lt;/p&gt;

&lt;p&gt;2，事务回滚。&lt;/p&gt;

&lt;p&gt;参与者接收到abort请求后，会利用其在阶段二中记录的Undo信息来执行事务回滚操作，并在完成回滚之后释放在整个事务执行期间占用的资源。&lt;/p&gt;

&lt;p&gt;3，反馈事务回滚结果。&lt;/p&gt;

&lt;p&gt;参与者在完成事务回滚之后，向协调者发送Ack消息。&lt;/p&gt;

&lt;p&gt;4，中断事务。&lt;/p&gt;

&lt;p&gt;协调者接收到所有参与者反馈的Ack消息后，中断事务。&lt;/p&gt;

&lt;p&gt;需要注意的是，一旦进入阶段三，可能会存在以下两种故障：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;协调者出现问题&lt;/li&gt;
&lt;li&gt;协调者和参与者之间的网络出现故障。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;无论出现哪种情况，最终都会导致参与者无法及时接收老子协调者的doCommit或者abort请求，针对这样的异常情况，&lt;code&gt;参与者都会在等待超时之后，继续进行事务提交。&lt;/code&gt;&lt;/p&gt;

&lt;h2 id=&#34;优缺点&#34;&gt;优缺点&lt;/h2&gt;

&lt;p&gt;三阶段提交协议的优点：相较于二阶段提交协议，三阶段提交协议最大的优点就是降低了参与者的阻塞范围，并且能够出现单点故障后继续达成一致。&lt;/p&gt;

&lt;p&gt;三阶段提交协议的缺点：三阶段提交协议在去除阻塞的同时也引入了新的问题，那就是在参与者接收到preCommit消息后，如果网络出现分区，此时协调者所在的节点和参与者无法进行正常的网络通信，在这种情况下，该参与者依然会进行事务的提交，这必然出现数据不一致性。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>2PC协议整理</title>
      <link>http://nituchao.com/post/2017/two-phase-commit-protocol/</link>
      <pubDate>Wed, 15 Feb 2017 10:12:41 +0800</pubDate>
      
      <guid>http://nituchao.com/post/2017/two-phase-commit-protocol/</guid>
      <description>

&lt;p&gt;2PC，是Two-Phase Commit的缩写，即二阶段提交，是计算机网络尤其是在数据库领域内，为了使基于分布式系统架构下的所有节点在进行事务处理的过程中能够保持原子性和一致性而设计的一种算法。通常，二阶段提交协议也被认为是一种一致性协议，用来保证分布式系统数据的一致性。目前，绝大部分的关系型数据库都是采用二阶段提交协议来完成分布式事务处理的，利用该协议能够非常方便地完成所有分布式事务参与者的协调，统一决定事务的提交或回滚，从而能够有效地保证分布式数据一致性，因此二阶段提交协议被广泛地应用在许多分布式系统中。&lt;/p&gt;

&lt;h2 id=&#34;协议说明&#34;&gt;协议说明&lt;/h2&gt;

&lt;p&gt;顾名思义，二阶段提交协议是将事务的提交过程分成了两个阶段来进行处理，其执行流程如下：&lt;/p&gt;

&lt;h3 id=&#34;阶段一-提交事务请求&#34;&gt;阶段一：提交事务请求&lt;/h3&gt;

&lt;p&gt;1，事务询问&lt;/p&gt;

&lt;p&gt;协调者向所有的参与者发送事务内容，询问是否可以执行事务提交操作，并开始等待各参与者的响应。&lt;/p&gt;

&lt;p&gt;2，执行事务&lt;/p&gt;

&lt;p&gt;各参与者节点执行事务操作，并将Undo和Redo信息记入事务日志中。&lt;/p&gt;

&lt;p&gt;3，各参与者向协调者反馈事务询问的响应。&lt;/p&gt;

&lt;p&gt;如果参与者成功执行了事务操作，那么就反馈给协调者Yes响应，表示事务可以执行；如果参与者没有成功执行事务，那么就反馈给协调者No响应，表示事务不可以执行。&lt;/p&gt;

&lt;p&gt;由于上面讲述的内容在形式上近似是协调者组织各参与者对一次事务操作的投标表态过程，因此二阶段提交协议的阶段一也被称为&amp;rdquo;投票阶段&amp;rdquo;，即各参与者投票表明是否要继续执行接下去的事务操作。&lt;/p&gt;

&lt;h3 id=&#34;阶段二-执行事务提交&#34;&gt;阶段二：执行事务提交&lt;/h3&gt;

&lt;p&gt;在阶段二，协调者会根据各参与者的反馈情况来决定最终是否可以进行事务提交操作，正常情况下，包含以下两种可能。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;执行事务提交&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;加入协调者从所有的参与者获得的反馈都是Yes响应，那么就会执行事务提交。&lt;/p&gt;

&lt;p&gt;1，发送提交请求。&lt;/p&gt;

&lt;p&gt;协调者向所有参与者节点发出Commit请求。&lt;/p&gt;

&lt;p&gt;2，事务提交。&lt;/p&gt;

&lt;p&gt;参与者接收到Commit请求后，会正式执行事务提交操作，并在完成提交之后释放在整个事务执行期间占用的事务资源。&lt;/p&gt;

&lt;p&gt;3，反馈事务提交结果。&lt;/p&gt;

&lt;p&gt;参与者在完成事务提交之后，向协调者发送Ack消息。&lt;/p&gt;

&lt;p&gt;4，完成事务。&lt;/p&gt;

&lt;p&gt;协调者收到所有参与者反馈的Ack消息后，完成事务。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;中断事务&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;假如任何一个参与者向协调者反馈了No响应，或者在等待超时之后，协调者尚无法接收到所有参与者的反馈响应，那么就会中断事务。&lt;/p&gt;

&lt;p&gt;1，发送回滚请求&lt;/p&gt;

&lt;p&gt;协调者向所有参与者节点发出Rollback请求。&lt;/p&gt;

&lt;p&gt;2，事务回滚&lt;/p&gt;

&lt;p&gt;参与者接收到Rollback请求后，会利用其在阶段一中记录的Undo信息来执行事务回滚操作，并在完成回滚后释放在整个事务执行期间占用的资源。&lt;/p&gt;

&lt;p&gt;3，反馈事务回滚结果。&lt;/p&gt;

&lt;p&gt;参与者在完成事务回滚之后，向协调者发送Ack消息。&lt;/p&gt;

&lt;p&gt;4，中断事务&lt;/p&gt;

&lt;p&gt;协调者接收到所有参与者反馈的Ack消息后，完成事务中断。&lt;/p&gt;

&lt;p&gt;以上就是二阶段提交过程，前后两个阶段分别进行的处理逻辑。简单地讲，二阶段提交讲一个事务的处理过程分为了投票和执行两个阶段，其核心是对每个事务都采用先尝试后提交的处理方式，因此也可以将二阶段提交看做一个强一致性的算法。&lt;/p&gt;

&lt;h3 id=&#34;优缺点&#34;&gt;优缺点&lt;/h3&gt;

&lt;p&gt;二阶段提交协议的优点：原理简单，实现方便。&lt;/p&gt;

&lt;p&gt;二阶段提交协议的缺点：同步阻塞，单点问题，脑裂，太过保守。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;同步阻塞&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;二阶段提交协议的最明显也是最大的一个问题就是同步阻塞，这会极大地限制分布式系统的性能。在二阶段提交的执行过程中，所有参与该事务操作的逻辑都处于阻塞状态，也就是说，各个参与者在等待其他参与者相应的额过程中，将无法进行其他任何操作。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;单点问题&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;在上面的讲解过程中，相信读者可以看出，协调者的角色在整个二阶段提交协议中起到了非常重要的作用。一旦协调者出现问题，那么整个二阶段提交流程将无法运转，更为严重的是，如果协调者是在阶段二中出现问题的话，那么其他参与者将会一直处于锁定事务资源的状态中，而无法继续完成事务操作。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;数据不一致&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;在二阶段提交协议的阶段二，即执行事务提交的时候，当协调者向所有的参与者发送Commit请求之后，发生了局部网络异常或者是协调者在尚未发送完Commit请求之前自身发生了崩溃，导致最终只有部分参与者收到了Commit请求。于是，这部分收到了Commit请求的参与者就会进行事务的提交，而其他没有收到Commit请求的参与者则无法进行事务提交，于是整个分布式系统便出现了数据不一致的现象。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;太过保守&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;如果协调者指示参与者进行事务提交询问的过程中，参与者出现故障而导致协调者始终无法获取到所有参与者的相应信息的话，这时协调者只能依靠其自身的超时机制来判断是否需要中断事务，这样的策略显得比较保守。换句话说，二阶段提交协议咩有设计较为完善的容错机制，任意一个节点的失败都会导致整个事务的失败。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>MySQL提供的事务控制语句</title>
      <link>http://nituchao.com/post/2017/mysql-shi-wu-kong-zhi-yu-ju/</link>
      <pubDate>Tue, 14 Feb 2017 14:09:01 +0800</pubDate>
      
      <guid>http://nituchao.com/post/2017/mysql-shi-wu-kong-zhi-yu-ju/</guid>
      <description>

&lt;p&gt;在MySQL命令行的默认设置下，事务都是自动提交的，即执行SQL语句后就会马上执行&lt;code&gt;COMMIT&lt;/code&gt;操作。因此要显式地开启一个事务需要使用命令&lt;code&gt;BEGIN&lt;/code&gt;, &lt;code&gt;START TRANSACTION&lt;/code&gt;, 或者执行命令&lt;code&gt;SET AUTOCOMMIT=0&lt;/code&gt;, 禁用当前会话的自动提交。&lt;/p&gt;

&lt;p&gt;每个数据库厂商自动提交的设置都会不相同，每个DBA或开发人员需要非常明白这一点，这对之后的SQL编程会有非凡的意义，因此用户不能以之前的经验来判断MySQL数据库的运行方式。&lt;/p&gt;

&lt;p&gt;MySQL为开发者提供了三种类型的事务，分别是扁平化事务，带保存点的事务，链式事务。通过带保存点的事务还可以模拟实现嵌套事务。&lt;/p&gt;

&lt;h3 id=&#34;start-transaction-begin&#34;&gt;START TRANSACTION | BEGIN&lt;/h3&gt;

&lt;p&gt;显式地开启一个事务。&lt;/p&gt;

&lt;h3 id=&#34;commit&#34;&gt;COMMIT&lt;/h3&gt;

&lt;p&gt;要想使用这个语句的最简形式，只需要发出&lt;code&gt;COMMIT&lt;/code&gt;。也可以更详细一点，写为&lt;code&gt;COMMIT WORK&lt;/code&gt;, 不过这两者几乎是等价的。&lt;code&gt;COMMIT&lt;/code&gt;会提交事务，并使得已对数据库做的修改称为永久性的。&lt;/p&gt;

&lt;h3 id=&#34;rollback&#34;&gt;ROLLBACK&lt;/h3&gt;

&lt;p&gt;要想使用这个语句的最简形式，只需要发出&lt;code&gt;ROLLBACK&lt;/code&gt;。同样地，也可以写为&lt;code&gt;ROLLBACK WORK&lt;/code&gt;，但两者几乎是等价的。回滚会结束用户的事务，并撤销正在进行的所有未提交的修改。&lt;/p&gt;

&lt;h3 id=&#34;savepoint-identity&#34;&gt;SAVEPOINT identity&lt;/h3&gt;

&lt;p&gt;&lt;code&gt;SAVEPOINT&lt;/code&gt;允许在事务中创建一个保存点，一个事务中可以有多个&lt;code&gt;SAVEPOINT&lt;/code&gt;。&lt;/p&gt;

&lt;h3 id=&#34;release-savepoint-identity&#34;&gt;RELEASE SAVEPOINT identity&lt;/h3&gt;

&lt;p&gt;删除一个事务的保存点，当没有一个保存点执行这语句时，会抛出一个异常。&lt;/p&gt;

&lt;h3 id=&#34;rollback-to-savepoint-identity&#34;&gt;ROLLBACK TO [SAVEPOINT] identity&lt;/h3&gt;

&lt;p&gt;这个语句与&lt;code&gt;SAVEPOINT&lt;/code&gt;命令一起使用。可以把事务回滚到标记点，而不回滚在此标记点之前的任何工作。&lt;/p&gt;

&lt;p&gt;例如，可以发出两调&lt;code&gt;UPDATE&lt;/code&gt;语句，后面跟一个&lt;code&gt;SAVEPOINT&lt;/code&gt;, 然后又是两条&lt;code&gt;DELETE&lt;/code&gt;语句。如果执行&lt;code&gt;DELETE&lt;/code&gt;语句期间出现了某种异常情况，并且捕获到这个异常，同时发出了&lt;code&gt;ROLLBACK TO SAVEPOINT&lt;/code&gt;命令，事务就会回滚到指定的SAVEPOINT，撤销&lt;code&gt;DELETE&lt;/code&gt;完成的所有工作，而&lt;code&gt;UPDATE&lt;/code&gt;语句完成的工作不受影响。&lt;/p&gt;

&lt;h3 id=&#34;set-transaction&#34;&gt;SET TRANSACTION&lt;/h3&gt;

&lt;p&gt;这个语句用来设置事务的隔离级别。&lt;/p&gt;

&lt;p&gt;InnoDB存储引擎提供的事务隔离级别有：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;READ UNCOMMITED&lt;/li&gt;
&lt;li&gt;READ COMMITTED&lt;/li&gt;
&lt;li&gt;REPEATABLE READ&lt;/li&gt;
&lt;li&gt;SERIALIZABLE&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;code&gt;START TRANSACTION&lt;/code&gt;, &lt;code&gt;BEGIN&lt;/code&gt;语句都可以在MySQL命令行下显示地开启一个事务。但是在存储过程中，MySQL数据库的分析器会自动将BEGIN识别为BEGIN&amp;hellip;END, 因此在存储过程中只能使用&lt;code&gt;START TRANSACTION&lt;/code&gt;语句来开启一个事务。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;COMMIT&lt;/code&gt;和&lt;code&gt;COMMIT WORK&lt;/code&gt;语句基本是一致的，都是用来提交事务。不同之处在于&lt;code&gt;COMMIT WORK&lt;/code&gt;用来控制事务结束后的行为是&lt;code&gt;CHAIN&lt;/code&gt;还是&lt;code&gt;RELEASE&lt;/code&gt;的。如果是&lt;code&gt;CHAIN&lt;/code&gt;方式，那么事务就变成了链事务。&lt;/p&gt;

&lt;p&gt;用户可以通过参数&lt;code&gt;completion_type&lt;/code&gt;来进行控制，该参数默认为0，表示没有任何操作。&lt;/p&gt;

&lt;p&gt;当参数&lt;code&gt;completion_type&lt;/code&gt;的值为1时，&lt;code&gt;COMMIT WORK&lt;/code&gt;等同于&lt;code&gt;COMMIT AND CHAIN&lt;/code&gt;, 表示马上自动开启一个相同隔离级别的事务。&lt;/p&gt;

&lt;p&gt;当参数&lt;code&gt;completion_type&lt;/code&gt;的值为2时，&lt;code&gt;COMMIT WORK&lt;/code&gt;等同于&lt;code&gt;COMMIT AND RELEASE&lt;/code&gt;, 在事务提交后会自动断开与服务器的连接。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>计算机</title>
      <link>http://nituchao.com/book/</link>
      <pubDate>Sun, 12 Feb 2017 17:51:45 +0800</pubDate>
      
      <guid>http://nituchao.com/book/</guid>
      <description>

&lt;p&gt;最近几年，大大小小的项目开发了不少，越来越觉得理论知识不够用，于是决心利用空余时间学习行业内的权威书籍。&lt;/p&gt;

&lt;p&gt;这些列出来的书，都完整读过，有些在不同年份读过多次，也都一一列出。&lt;/p&gt;

&lt;h2 id=&#34;java&#34;&gt;Java&lt;/h2&gt;

&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th align=&#34;left&#34;&gt;名称&lt;/th&gt;
&lt;th align=&#34;left&#34;&gt;作者&lt;/th&gt;
&lt;th align=&#34;left&#34;&gt;页数&lt;/th&gt;
&lt;th align=&#34;left&#34;&gt;评分&lt;/th&gt;
&lt;th align=&#34;left&#34;&gt;年份&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;

&lt;tbody&gt;
&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;Java虚拟机精讲&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;高翔龙&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;280&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;※※※&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;2016\2017&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;Effective Java中文版&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;俞黎敏&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;287&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;※※※※&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;2016&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;Java并发编程实战&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;Brian Goetz/董云兰&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;293&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;※※※&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;2017&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;Java多线程编程核心技术&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;高洪岩&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;306&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;※※※&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;2016&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;Java 7并发编程实战手册&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;申邵勇/俞黎敏&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;339&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;※※※&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;2016&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;Spring揭秘&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;王福强&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;680&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;※※※&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;2016&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;Netty权威指南&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;李林峰&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;572&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;※※※※&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;2015\2016&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;h2 id=&#34;mysql&#34;&gt;MySQL&lt;/h2&gt;

&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th align=&#34;left&#34;&gt;名称&lt;/th&gt;
&lt;th align=&#34;left&#34;&gt;作者&lt;/th&gt;
&lt;th align=&#34;left&#34;&gt;页数&lt;/th&gt;
&lt;th align=&#34;left&#34;&gt;评分&lt;/th&gt;
&lt;th align=&#34;left&#34;&gt;年份&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;

&lt;tbody&gt;
&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;MySQL技术内幕 : InnoDB存储引擎&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;姜承尧&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;436&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;※※※※&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;2017&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;MySQL性能调优与架构设计&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;简朝阳&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;392&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;※※※※&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;2016&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;高性能MySQL&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;Baron Schwartz/宁海元&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;764&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;※※※※&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;2017&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;高可用MySQL&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;Charles Bell/宁青&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;680&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;※※※※&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;2017&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;Effective MySQL之备份与恢复&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;Ronald Bradford/张骏温&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;283&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;※※※&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;2017&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;Effective MySQL之SQL语句最优化&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;Ronald Bradford/李雪锋&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;201&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;※※※&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;2017&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;Effective MySQL之深入理解复制技术&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;Ronald Bradford/李雪锋&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;309&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;※※※&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;2017&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;h2 id=&#34;redis&#34;&gt;Redis&lt;/h2&gt;

&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th align=&#34;left&#34;&gt;名称&lt;/th&gt;
&lt;th align=&#34;left&#34;&gt;作者&lt;/th&gt;
&lt;th align=&#34;left&#34;&gt;页数&lt;/th&gt;
&lt;th align=&#34;left&#34;&gt;评分&lt;/th&gt;
&lt;th align=&#34;left&#34;&gt;年份&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;

&lt;tbody&gt;
&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;Redis设计与实现&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;黄建宏&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;388&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;※※※※&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;2017&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;Redis实战&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;Josiah L. Carlson/黄建宏&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;300&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;※※&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;2016&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;h2 id=&#34;linux&#34;&gt;Linux&lt;/h2&gt;

&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th align=&#34;left&#34;&gt;名称&lt;/th&gt;
&lt;th align=&#34;left&#34;&gt;作者&lt;/th&gt;
&lt;th align=&#34;left&#34;&gt;页数&lt;/th&gt;
&lt;th align=&#34;left&#34;&gt;评分&lt;/th&gt;
&lt;th align=&#34;left&#34;&gt;年份&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;

&lt;tbody&gt;
&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;理解Unix进程&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;Jesse Storimer&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;116&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;※※※&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;Linux高性能服务器编程&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;游双&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;360&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;※※※&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;高性能Linux服务器构建实践：运维监控、性能调优与集群应用&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;高俊峰&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;452&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;※※※&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;h2 id=&#34;设计模式&#34;&gt;设计模式&lt;/h2&gt;

&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th align=&#34;left&#34;&gt;名称&lt;/th&gt;
&lt;th align=&#34;left&#34;&gt;作者&lt;/th&gt;
&lt;th align=&#34;left&#34;&gt;页数&lt;/th&gt;
&lt;th align=&#34;left&#34;&gt;评分&lt;/th&gt;
&lt;th align=&#34;left&#34;&gt;年份&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;

&lt;tbody&gt;
&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;设计模式之禅&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;秦小波&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;555&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;※※※&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;2017&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;h2 id=&#34;分布式计算&#34;&gt;分布式计算&lt;/h2&gt;

&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th align=&#34;left&#34;&gt;名称&lt;/th&gt;
&lt;th align=&#34;left&#34;&gt;作者&lt;/th&gt;
&lt;th align=&#34;left&#34;&gt;页数&lt;/th&gt;
&lt;th align=&#34;left&#34;&gt;评分&lt;/th&gt;
&lt;th align=&#34;left&#34;&gt;年份&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;

&lt;tbody&gt;
&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;分布式服务框架：原理与实践&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;李林峰&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;312&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;※※※&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;2017&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;从Paxos到Zookeeper：分布式一致性原理与实践&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;倪超&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;422&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;※※※※&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;2017&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;h2 id=&#34;大数据处理&#34;&gt;大数据处理&lt;/h2&gt;

&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th align=&#34;left&#34;&gt;名称&lt;/th&gt;
&lt;th align=&#34;left&#34;&gt;作者&lt;/th&gt;
&lt;th align=&#34;left&#34;&gt;页数&lt;/th&gt;
&lt;th align=&#34;left&#34;&gt;评分&lt;/th&gt;
&lt;th align=&#34;left&#34;&gt;年份&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;

&lt;tbody&gt;
&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;Hive编程指南&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;Edward Capriolo/曹坤&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;318&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;※※※&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;2016&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;HBase权威指南&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;Lars George/代志远&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;522&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;※※※&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;2015&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;Hadoop技术内幕：深入解析YARN架构设计与实现原理&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;董西成&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;396&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;※※※&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;2015&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;Hadoop技术内幕：深入解析MapReduce架构设计与实现原理&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;董西成&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;332&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;※※※&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;2015\2016&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;快学Scala&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;C.S.霍夫曼/高翔宇&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;408&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;※※※&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;2016&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;深入理解Scala&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;Joshua D.Suereth/苏瑞茨&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;288&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;※※※&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;2016&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;Scala编程&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;Martin Odersky/黄海旭/高宇翔&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;492&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;※※&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;2016&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;h2 id=&#34;其他&#34;&gt;其他&lt;/h2&gt;

&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th align=&#34;left&#34;&gt;名称&lt;/th&gt;
&lt;th align=&#34;left&#34;&gt;作者&lt;/th&gt;
&lt;th align=&#34;left&#34;&gt;页数&lt;/th&gt;
&lt;th align=&#34;left&#34;&gt;评分&lt;/th&gt;
&lt;th align=&#34;left&#34;&gt;年份&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;

&lt;tbody&gt;
&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;jQuery基础教程&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;Jonathan Chaffer/李松峰&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;318&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;※※※&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;2016&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
</description>
    </item>
    
    <item>
      <title>JVM调试相关的配置参数</title>
      <link>http://nituchao.com/post/2016/jvm-tiao-shi-xiang-guan-de-pei-zhi-can-shu/</link>
      <pubDate>Thu, 29 Dec 2016 20:15:12 +0800</pubDate>
      
      <guid>http://nituchao.com/post/2016/jvm-tiao-shi-xiang-guan-de-pei-zhi-can-shu/</guid>
      <description>&lt;p&gt;本文将详细分析JVM配置参数中，与调试相关的配置参数，这些配置参数将方便开发人员跟踪JVM运行，查看JVM日志等相关工作。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>JVM行为相关的配置参数</title>
      <link>http://nituchao.com/post/2016/jvm-xing-wei-xiang-guan-de-pei-zhi-can-shu/</link>
      <pubDate>Thu, 29 Dec 2016 13:53:12 +0800</pubDate>
      
      <guid>http://nituchao.com/post/2016/jvm-xing-wei-xiang-guan-de-pei-zhi-can-shu/</guid>
      <description>&lt;p&gt;文本将分析与JVM行为相关的配置参数。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>JVM G1收集器配置参数</title>
      <link>http://nituchao.com/post/2016/jvm-g1-shou-ji-qi-pei-zhi-can-shu/</link>
      <pubDate>Thu, 29 Dec 2016 12:22:12 +0800</pubDate>
      
      <guid>http://nituchao.com/post/2016/jvm-g1-shou-ji-qi-pei-zhi-can-shu/</guid>
      <description>&lt;p&gt;G1收集器配置参数&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>JVM常用的非标准配置参数</title>
      <link>http://nituchao.com/post/2016/jvm-chan-yong-de-fei-biao-zhun-pei-zhi-can-shu/</link>
      <pubDate>Thu, 29 Dec 2016 10:18:12 +0800</pubDate>
      
      <guid>http://nituchao.com/post/2016/jvm-chan-yong-de-fei-biao-zhun-pei-zhi-can-shu/</guid>
      <description>&lt;p&gt;本文将研究JVM常见常见的非标准配置参数。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>JVM性能相关的配置参数</title>
      <link>http://nituchao.com/post/2016/jvm-xing-neng-xiang-guan-de-pei-zhi-can-shu/</link>
      <pubDate>Thu, 29 Dec 2016 09:30:12 +0800</pubDate>
      
      <guid>http://nituchao.com/post/2016/jvm-xing-neng-xiang-guan-de-pei-zhi-can-shu/</guid>
      <description>&lt;p&gt;本问将介绍JVM性能相关的配置参数。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>JVM配置参数-X与-XX的区别</title>
      <link>http://nituchao.com/post/2016/jvm-options-x-vs-xx/</link>
      <pubDate>Wed, 28 Dec 2016 13:14:12 +0800</pubDate>
      
      <guid>http://nituchao.com/post/2016/jvm-options-x-vs-xx/</guid>
      <description>

&lt;p&gt;启动JVM时通过指定配置参数来指导虚拟机按照我们的要求提供服务，这一点对大多数的Java程序员来说已经是司空见惯。&lt;/p&gt;

&lt;p&gt;在指定配置参数时，会有-X和-XX两种形式，那么它们两者有什么区别呢，今天我想借这篇文章总结一下。&lt;/p&gt;

&lt;p&gt;下面是我们的某个Java项目在正式环境上启动JVM时的一个典型命令，在该命令中指定了各种启动参数：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;java -Xmx15G -Xms10G -Xmn3G -Xss512k -XX:MaxPermSize=512M -XX:PermSize=512M -XX:+PrintFlagsFinal -XX:MaxTenuringThreshold=1 -XX:SurvivorRatio=23 -XX:TargetSurvivorRatio=80 -Xnoclassgc -XX:+UseParNewGC -XX:+UseConcMarkSweepGC -XX:CMSInitiatingOccupancyFraction=80 -XX:ParallelGCThreads=24 -XX:ConcGCThreads=24 -XX:+CMSParallelRemarkEnabled -XX:+CMSScavengeBeforeRemark -XX:+ExplicitGCInvokesConcurrent -XX:+UseTLAB -XX:TLABSize=64K, -verbose:gc -XX:+PrintGCDetails -XX:+PrintGCDateStamps -XX:+PrintGCTimeStamps -XX:+PrintGCApplicationStoppedTime -Xloggc:./gc.log
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Java HotSpot VM的官方文档中将启动参数分为如下两类：&lt;/p&gt;

&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th align=&#34;center&#34;&gt;配置 参数&lt;/th&gt;
&lt;th align=&#34;center&#34;&gt;类型&lt;/th&gt;
&lt;th align=&#34;left&#34;&gt;说明&lt;/th&gt;
&lt;th align=&#34;center&#34;&gt;举例&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;

&lt;tbody&gt;
&lt;tr&gt;
&lt;td align=&#34;center&#34;&gt;-X&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;non-standard&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;非标准参数。&lt;br/&gt;&lt;br/&gt;这些参数不是虚拟机规范规定的。因此，不是所有VM的实现(如:HotSpot,JRockit,J9等)都支持这些配置参数。&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;-Xmx、-Xms、-Xmn、-Xss&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;center&#34;&gt;-XX&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;not-stable&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;不稳定参数。&lt;br/&gt;&lt;br/&gt;这些参数是虚拟机规范中规定的。这些参数指定虚拟机实例在运行时的各种行为，从而对虚拟机的运行时性能有很大影响。&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;-XX:SurvivorRatio、-XX:+UseParNewGc&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;补充: -X和-XX两种参数都可能随着JDK版本的变更而发生变化，有些参数可以能会被废弃掉，有些参数的功能会发生改变，但是JDK官方不会通知开发者这些变化，需要使用者注意。&lt;/p&gt;

&lt;p&gt;-XX参数被称为不稳定参数，是因为这类参数的设置会引起JVM运行时性能上的差异，配置得当可以提高JVM性能，配置不当则会使JVM出现各种问题, 甚至造成JVM崩溃。&lt;/p&gt;

&lt;p&gt;国外有个哥们从HotSpot VM的源码里发现了934个此类型的配置参数，因此能对JVM做出很多组合配置，对JVM的调优也没有统一的标准，需要我们在实践中不断总结经验，并结合实际业务来进行操作，最终找到最适合当前业务的那些配置。&lt;/p&gt;

&lt;h2 id=&#34;一些有用的-xx配置&#34;&gt;一些有用的-XX配置&lt;/h2&gt;

&lt;p&gt;对于-XX类型的配置选项，虚拟机规范有一些惯例，针对不同的平台虚拟机也会提供不同的默认值。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;对于布尔(Boolean)类型的配置选项，通过&lt;code&gt;-XX:+&amp;lt;option&amp;gt;&lt;/code&gt;来开启，通过&lt;code&gt;-XX:-&amp;lt;option&amp;gt;&lt;/code&gt;来关闭。&lt;/li&gt;
&lt;li&gt;对于数字(Numberic)类型的配置选项，通过&lt;code&gt;-XX:&amp;lt;option&amp;gt;=&amp;lt;number&amp;gt;&lt;/code&gt;来配置。&lt;code&gt;&amp;lt;number&amp;gt;&lt;/code&gt;后面可以携带单位字母，比如: &amp;lsquo;k&amp;rsquo;或者&amp;rsquo;K&amp;rsquo;代表千字节，&amp;rsquo;m&amp;rsquo;或者&amp;rsquo;M&amp;rsquo;代表兆字节，&amp;rsquo;g&amp;rsquo;或者&amp;rsquo;G&amp;rsquo;代表千兆字节。&lt;/li&gt;
&lt;li&gt;对于字符串(String)类型的配置选项，通过&lt;code&gt;-XX:&amp;lt;option&amp;gt;=&amp;lt;string&amp;gt;&lt;/code&gt;来配置。这种配置通过用来指定文件，路径或者命令列表。&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;参考文献&#34;&gt;参考文献&lt;/h2&gt;

&lt;p&gt;1, &lt;a href=&#34;http://jvm-options.tech.xebia.fr/&#34;&gt;JVM Options - The complete reference&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;2, &lt;a href=&#34;http://www.oracle.com/technetwork/java/javase/tech/vmoptions-jsp-140102.html&#34;&gt;Java HotSpot VM Options&lt;/a&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Java通过信号量机制实现生产者消费者</title>
      <link>http://nituchao.com/post/2016/java-xin-hao-liang-ji-zhi-shi-xian-sheng-chan-zhe-xiao-fei-zhe/</link>
      <pubDate>Tue, 27 Dec 2016 16:12:12 +0800</pubDate>
      
      <guid>http://nituchao.com/post/2016/java-xin-hao-liang-ji-zhi-shi-xian-sheng-chan-zhe-xiao-fei-zhe/</guid>
      <description>

&lt;p&gt;信号量是一种计数器，用来保护一个或者多个共享资源的访问。Java提供了Semaphore类来实现信号量机制。&lt;/p&gt;

&lt;p&gt;如果线程要访问一个共享资源，它必须先获得信号量。如果信号量的内部计数器大于0，信号量将减1，然后允许访问这个共享资源。计数器大于0意味着有可以使用的资源，因此线程将被允许使用其中一个资源。&lt;/p&gt;

&lt;p&gt;否则，如果信号量的计数器等于0，信号量将会把线程置入休眠直至计数器大于0.计数器等于0的时候意味着所有的共享资源已经被其他线程使用了，所以需要访问这个共享资源的线程必须等待。&lt;/p&gt;

&lt;p&gt;当线程使用完某个共享资源时，信号量必须被释放，以便其他线程能够访问共享资源。释放操作将使信号量的内部计数器增加1。&lt;/p&gt;

&lt;h3 id=&#34;设计思想&#34;&gt;设计思想&lt;/h3&gt;

&lt;p&gt;为了使用信号量机制来实现生产者VS消费者模型，我们需要实例化一个二进制信号量对象，即内部计数器只有0和1两个值。多个生产者线程和多个消费者线程竞争这个信号量来互斥访问共享缓冲区。&lt;/p&gt;

&lt;p&gt;另外，由于共享缓冲区是有空间限制的，生产者在生产前要判断共享缓冲区空间是否充足。消费者在消费前要判断共享缓冲区内的元素是否足够消费。&lt;/p&gt;

&lt;h3 id=&#34;代码实现&#34;&gt;代码实现&lt;/h3&gt;

&lt;p&gt;基于上面的设计思想，我们需要实现共享缓冲区，生产者线程，消费者线程和主程序四部分。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;共享缓冲区&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;package com.nituchao.jvm.prosumer.semaphore;

import java.util.ArrayList;
import java.util.List;
import java.util.concurrent.Semaphore;

/**
 * 缓冲区
 * Created by liang on 2016/12/29.
 */
public class Buffer {
    private int MAX_SIZE = 100;
    private final List&amp;lt;String&amp;gt; list;
    private final Semaphore semaphore;

    public Buffer() {
        this.list = new ArrayList&amp;lt;&amp;gt;();
        this.semaphore = new Semaphore(1);
    }

    /**
     * 生产Buffer元素
     *
     * @param num
     */
    public boolean BufferProduct(int num) {
        boolean result = true;

        try {
            // 获取信号量
            semaphore.acquire();

            // 如果缓冲区能够容纳要生成的元素，允许生产
            if (list.size() + num &amp;lt;= MAX_SIZE) {
                // 开始生产
                for (int i = 1; i &amp;lt;= num; i++) {
                    list.add(0, Thread.currentThread().getName() + &amp;quot; : &amp;quot; + i);
                }

                result = true;

                System.out.printf(&amp;quot;Thread %s: Buffer Product succ, num is %d, buffer size is %d\n&amp;quot;, Thread.currentThread().getName(), num, list.size());
            } else {
                // 缓冲区无法容纳要生成的元素，禁止生产
                result = false;

                System.out.printf(&amp;quot;Thread %s: Buffer Product fail, num is %d, buffer size is %d\n&amp;quot;, Thread.currentThread().getName(), num, list.size());
            }
        } catch (InterruptedException e) {
            e.printStackTrace();
        } finally {
            semaphore.release();
        }

        return result;
    }

    /**
     * 消费Buffer元素
     *
     * @param num
     * @return
     */
    public boolean BufferConsume(int num) {
        boolean result = true;

        try {
            // 获取信号量
            semaphore.acquire();

            // 如果缓冲区中有足够的元素消费，允许消费
            if (list.size() - num &amp;gt;= 0) {
                // 开始消费
                for (int i = 1; i &amp;lt;= num; i++) {
                    String element = list.remove(0);
                }

                result = true;

                System.out.printf(&amp;quot;Thread: %s, Buffer Consume succ, num is %d, buffer size is %d\n&amp;quot;, Thread.currentThread().getName(), num, list.size());
            } else {
                // 缓冲取没有足够的元素供消费，禁止消费
                result = false;

                System.out.printf(&amp;quot;Thread: %s, Buffer Consume fail, num is %d, buffer size is %d\n&amp;quot;, Thread.currentThread().getName(), num, list.size());
            }
        } catch (InterruptedException e) {
            e.printStackTrace();
        } finally {
            semaphore.release();
        }

        return result;
    }
}

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;生产者线程&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;package com.nituchao.jvm.prosumer.semaphore;

import java.util.Random;
import java.util.concurrent.TimeUnit;

/**
 * 生产者线程
 * Created by liang on 2016/12/29.
 */
public class BufferProducer implements Runnable {
    private Buffer buffer;
    private int num;

    public BufferProducer(Buffer buffer, int num) {
        this.buffer = buffer;
        this.num = num;
    }

    @Override
    public void run() {
        while (!buffer.BufferProduct(num)) {
            try {
                TimeUnit.MILLISECONDS.sleep(new Random(1000).nextInt());
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
        }
    }
}


&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;消费者线程&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;package com.nituchao.jvm.prosumer.semaphore;

import java.util.Random;
import java.util.concurrent.TimeUnit;

/**
 * 消费者线程
 * Created by liang on 2016/12/29.
 */
public class BufferConsumer implements Runnable {
    private Buffer buffer;
    private int num;

    public BufferConsumer(Buffer buffer, int num) {
        this.buffer = buffer;
        this.num = num;
    }

    @Override
    public void run() {
        while (!buffer.BufferConsume(num)) {
            try {
                TimeUnit.MILLISECONDS.sleep(new Random(1000).nextInt());
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
        }
    }
}

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;主程序&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;package com.nituchao.jvm.prosumer.semaphore;

/**
 * 主程序
 * Created by liang on 2016/12/29.
 */
public class BufferMain {

    public static void main(String[] args) {
        int num = 10;

        // 初始化Buffer对象
        Buffer buffer = new Buffer();

        // 实例化num个生产者和消费者线程
        Thread[] threadProducers = new Thread[num];
        Thread[] threadConsumers = new Thread[num];

        for (int i = 0; i &amp;lt; num; i++) {
            threadProducers[i] = new Thread(new BufferProducer(buffer, i + 1));
            threadConsumers[i] = new Thread(new BufferConsumer(buffer, i + 1));
        }

        // 分别启动生产者和消费者线程
        for (int i = 0; i &amp;lt; num; i++) {
            // 故意先开始消费
            threadConsumers[i].start();

            // 故意后开始生产
            threadProducers[i].start();
        }
    }
}

&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;运行结果&#34;&gt;运行结果&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;Connected to the target VM, address: &#39;127.0.0.1:61012&#39;, transport: &#39;socket&#39;
Thread: Thread-1, Buffer Consume fail, num is 1, buffer size is 0
Thread Thread-0: Buffer Product succ, num is 1, buffer size is 1
Thread: Thread-3, Buffer Consume fail, num is 2, buffer size is 1
Thread Thread-2: Buffer Product succ, num is 2, buffer size is 3
Thread: Thread-5, Buffer Consume succ, num is 3, buffer size is 0
Thread Thread-4: Buffer Product succ, num is 3, buffer size is 3
Thread: Thread-7, Buffer Consume fail, num is 4, buffer size is 3
Thread: Thread-7, Buffer Consume fail, num is 4, buffer size is 3
Thread: Thread-7, Buffer Consume fail, num is 4, buffer size is 3
Thread: Thread-7, Buffer Consume fail, num is 4, buffer size is 3
Thread: Thread-7, Buffer Consume fail, num is 4, buffer size is 3
Thread: Thread-7, Buffer Consume fail, num is 4, buffer size is 3
Thread Thread-6: Buffer Product succ, num is 4, buffer size is 7
Thread: Thread-9, Buffer Consume succ, num is 5, buffer size is 2
Thread Thread-8: Buffer Product succ, num is 5, buffer size is 7
Thread: Thread-11, Buffer Consume succ, num is 6, buffer size is 1
Thread Thread-10: Buffer Product succ, num is 6, buffer size is 7
Thread: Thread-13, Buffer Consume succ, num is 7, buffer size is 0
Thread Thread-12: Buffer Product succ, num is 7, buffer size is 7
Thread: Thread-15, Buffer Consume fail, num is 8, buffer size is 7
Thread: Thread-15, Buffer Consume fail, num is 8, buffer size is 7
Thread: Thread-15, Buffer Consume fail, num is 8, buffer size is 7
Thread: Thread-15, Buffer Consume fail, num is 8, buffer size is 7
Thread: Thread-15, Buffer Consume fail, num is 8, buffer size is 7
Thread Thread-14: Buffer Product succ, num is 8, buffer size is 15
Thread: Thread-17, Buffer Consume succ, num is 9, buffer size is 6
Thread Thread-16: Buffer Product succ, num is 9, buffer size is 15
Thread: Thread-19, Buffer Consume succ, num is 10, buffer size is 5
Thread Thread-18: Buffer Product succ, num is 10, buffer size is 15
Thread: Thread-3, Buffer Consume succ, num is 2, buffer size is 13
Thread: Thread-1, Buffer Consume succ, num is 1, buffer size is 12
Thread: Thread-7, Buffer Consume succ, num is 4, buffer size is 8
Thread: Thread-15, Buffer Consume succ, num is 8, buffer size is 0
Disconnected from the target VM, address: &#39;127.0.0.1:61012&#39;, transport: &#39;socket&#39;

Process finished with exit code 0
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;工作原理&#34;&gt;工作原理&lt;/h3&gt;

&lt;p&gt;主程序首先实例化一个二进制信号量对象semaphore，指定该信号量内部计数器只有0和1，这样可以保证同一时间只有一个线程能够访问共享缓冲区。这样一来，共享缓冲区buffer本质上就成为一个队列。&lt;/p&gt;

&lt;p&gt;主程序实例化num个生产者线程和num个消费者线程。&lt;/p&gt;

&lt;p&gt;生产者线程负责向缓冲区里生产元素，每个生产者生产的数量都各不相同，从而能更好的观察效果。生产者首先会去尝试获取信号量(acquire)，然后检查当前共享缓冲区是否有足够空间容纳自己可生产的元素。如果有，则进行生产，如果没有，则不进行生产。最后，释放信号量(release)并把生产的结果返回(boolen)。生产者线程如果发现自己生产失败，则会随机休眠一段时间再重复上面的操作，直到生产操作成功。&lt;/p&gt;

&lt;p&gt;消费者线程负责从缓冲区里消费元素，每个消费者消费的数量都各不相同，从而能更好的观察效果。消费者首先回去尝试获取信号量(acquire)，然后检查当前共享缓冲区中是否有足够的元素供自己消费。如果有，则进行消费，如果没有，则不进行消费。最后，释放信号量(release)并把消费的结果返回(boolean)。消费者线程如果发现自己消费失败，则会随机休眠一段时间再重复上面的操作，直到消费操作成功。&lt;/p&gt;

&lt;p&gt;生产者线程和消费者线程访问是信号量是公平竞争，第一个获取信号量的线程将能够访问临界区，其余的线程将被信号量阻塞，直到信号量被释放。一旦信号量被释放，被被阻塞的线程就可以重新竞争信号量并访问临界区。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Java通过重入锁实现生产者消费者</title>
      <link>http://nituchao.com/post/2016/java-chong-ru-suo-shi-xian-sheng-chan-zhe-xiao-fei-zhe/</link>
      <pubDate>Tue, 27 Dec 2016 16:12:12 +0800</pubDate>
      
      <guid>http://nituchao.com/post/2016/java-chong-ru-suo-shi-xian-sheng-chan-zhe-xiao-fei-zhe/</guid>
      <description>

&lt;p&gt;ReentrantLock是一个可重入的互斥锁，又被称为&amp;rdquo;独占锁&amp;rdquo;，ReentrantLock锁在同一个时间点只能被一个线程锁持有，而可重入的意思是，ReentrantLock可以被单个线程多次获取，ReentrantLock的性能并不高，优点是比价灵活。ReentrantLock比Synchronized关键词更加灵活，并且能支持条件变量，后面我还会单独介绍使用条件变量实现生产者消费者模型的方法。&lt;/p&gt;

&lt;h3 id=&#34;设计思想&#34;&gt;设计思想&lt;/h3&gt;

&lt;p&gt;本文希望同ReentrantLock来实现一个共享缓冲区，生产者线程和消费者线程通过该共享缓冲区来实现相关的生产和消费操作，每个线程对共享缓冲区的访问是互斥的。&lt;/p&gt;

&lt;p&gt;另外，由于共享缓冲区是有空间限制的，生产者在生产前要判断共享缓冲区空间是否充足。消费者在消费前要判断共享缓冲区内的元素是否足够消费。&lt;/p&gt;

&lt;h3 id=&#34;代码实现&#34;&gt;代码实现&lt;/h3&gt;

&lt;p&gt;根据上面的设计思想，我们需要实现共享缓冲区，生产者线程，消费者线程，主程序等四个部分。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;共享缓冲区&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;package com.nituchao.jvm.prosumer.reentrant;

import java.util.ArrayList;
import java.util.List;
import java.util.concurrent.locks.Lock;
import java.util.concurrent.locks.ReentrantLock;

/**
 * 共享缓冲区
 * Created by liang on 2016/12/30.
 */
public class Buffer {
    private final List&amp;lt;String&amp;gt; list;
    private int MAX_SIZE = 10;
    private final Lock lock;

    public Buffer() {
        this.list = new ArrayList&amp;lt;String&amp;gt;();
        this.lock = new ReentrantLock();
    }

    /**
     * 生产num个元素
     *
     * @param num
     * @return
     */
    public boolean bufferProduct(int num) {
        boolean result = true;
        try {
            lock.lock();

            // 检查缓冲区是否能够容纳要生产的元素
            if (list.size() + num &amp;lt;= MAX_SIZE) {
                // 开始生产
                for (int i = 0; i &amp;lt; num; i++) {
                    list.add(0, Thread.currentThread().getName() + &amp;quot;:&amp;quot; + (i + 1));
                }

                result = true;

                System.out.printf(&amp;quot;Thread %s: Buffer Product succ, num is %d, buffer size is %d\n&amp;quot;, Thread.currentThread().getName(), num, list.size());
            } else {
                result = false;

                System.out.printf(&amp;quot;Thread %s: Buffer Product succ, num is %d, buffer size is %d\n&amp;quot;, Thread.currentThread().getName(), num, list.size());
            }
        } catch (Exception e) {
            e.printStackTrace();
            result = false;
        } finally {
            lock.unlock();
        }

        return result;
    }

    /**
     * 消费num个元素
     *
     * @param num
     * @return
     */
    public boolean bufferConsume(int num) {
        boolean result = false;
        try {
            lock.lock();

            // 检查缓冲区是否有足够的元素供消费
            if (list.size() &amp;gt;= num) {
                // 开始消费
                for (int i = 0; i &amp;lt; num; i++) {
                    list.remove(0);
                }

                result = true;

                System.out.printf(&amp;quot;Thread: %s, Buffer Consume succ, num is %d, buffer size is %d\n&amp;quot;, Thread.currentThread().getName(), num, list.size());
            } else {
                result = false;

                System.out.printf(&amp;quot;Thread: %s, Buffer Consume fail, num is %d, buffer size is %d\n&amp;quot;, Thread.currentThread().getName(), num, list.size());
            }
        } catch (Exception e) {
            e.printStackTrace();
            result = false;
        } finally {
            lock.unlock();
        }

        return result;
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;生产者线程&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;package com.nituchao.jvm.prosumer.reentrant;

import java.util.Random;
import java.util.concurrent.TimeUnit;

/**
 * 生产者线程
 * Created by liang on 2016/12/30.
 */
public class BufferProducer implements Runnable {
    private int num;
    private Buffer buffer;

    public BufferProducer(Buffer buffer, int num) {
        this.num = num;
        this.buffer = buffer;
    }

    @Override
    public void run() {
        // 生产num个元素，如果生产失败，则休眠一段时间重新生产
        while (!buffer.bufferProduct(num)) {
            try {
                TimeUnit.MILLISECONDS.sleep(new Random(1000).nextInt());
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
        }
    }
}

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;消费者线程&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;package com.nituchao.jvm.prosumer.reentrant;

import java.util.Random;
import java.util.concurrent.TimeUnit;

/**
 * 消费者线程
 * Created by liang on 2016/12/30.
 */
public class BufferConsumer implements Runnable {
    private int num;
    private Buffer buffer;

    public BufferConsumer(Buffer buffer, int num) {
        this.num = num;
        this.buffer = buffer;
    }

    @Override
    public void run() {
        // 消费num个产品，如果消费失败，则休眠一段时间再重新消费
        while (!buffer.bufferConsume(num)) {
            try {
                TimeUnit.MILLISECONDS.sleep(new Random(1000).nextInt());
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
        }
    }
}

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;主程序&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;package com.nituchao.jvm.prosumer.reentrant;

/**
 * 主程序
 * Created by liang on 2016/12/30.
 */
public class BufferMain {

    public static void main(String[] args) {
        int num = 10;
        // 实例化Buffer
        Buffer buffer = new Buffer();

        // 实例化生产者和消费者线程集合
        Thread[] threadProducers = new Thread[num];
        Thread[] threadConsumers = new Thread[num];

        // 实例化生产者和消费者线程
        for (int i = 0; i &amp;lt; num; i++) {
            Thread threadProducer = new Thread(new BufferProducer(buffer, i + 1));
            Thread threadConsumer = new Thread(new BufferConsumer(buffer, i + 1));

            threadProducers[i] = threadProducer;
            threadConsumers[i] = threadConsumer;
        }

        // 启动生产者和消费者线程
        for (int i = 0; i &amp;lt; num; i++) {
            threadConsumers[i].start();

            threadProducers[i].start();
        }
    }
}

&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;运行结果&#34;&gt;运行结果&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;Connected to the target VM, address: &#39;127.0.0.1:53178&#39;, transport: &#39;socket&#39;
Thread: Thread-1, Buffer Consume fail, num is 1, buffer size is 0
Thread Thread-0: Buffer Product succ, num is 1, buffer size is 1
Thread: Thread-3, Buffer Consume fail, num is 2, buffer size is 1
Thread Thread-2: Buffer Product succ, num is 2, buffer size is 3
Thread: Thread-3, Buffer Consume succ, num is 2, buffer size is 1
Thread: Thread-5, Buffer Consume fail, num is 3, buffer size is 1
Thread: Thread-5, Buffer Consume fail, num is 3, buffer size is 1
Thread: Thread-5, Buffer Consume fail, num is 3, buffer size is 1
Thread Thread-4: Buffer Product succ, num is 3, buffer size is 4
Thread: Thread-7, Buffer Consume succ, num is 4, buffer size is 0
Thread Thread-6: Buffer Product succ, num is 4, buffer size is 4
Thread: Thread-9, Buffer Consume fail, num is 5, buffer size is 4
Thread: Thread-9, Buffer Consume fail, num is 5, buffer size is 4
Thread: Thread-9, Buffer Consume fail, num is 5, buffer size is 4
Thread Thread-8: Buffer Product succ, num is 5, buffer size is 9
Thread: Thread-11, Buffer Consume succ, num is 6, buffer size is 3
Thread Thread-10: Buffer Product succ, num is 6, buffer size is 9
Thread: Thread-13, Buffer Consume succ, num is 7, buffer size is 2
Thread Thread-12: Buffer Product succ, num is 7, buffer size is 9
Thread: Thread-15, Buffer Consume succ, num is 8, buffer size is 1
Thread Thread-14: Buffer Product succ, num is 8, buffer size is 9
Thread: Thread-17, Buffer Consume succ, num is 9, buffer size is 0
Thread Thread-16: Buffer Product succ, num is 9, buffer size is 9
Thread: Thread-19, Buffer Consume fail, num is 10, buffer size is 9
Thread: Thread-19, Buffer Consume fail, num is 10, buffer size is 9
Thread: Thread-19, Buffer Consume fail, num is 10, buffer size is 9
Thread: Thread-19, Buffer Consume fail, num is 10, buffer size is 9
Thread: Thread-19, Buffer Consume fail, num is 10, buffer size is 9
Thread Thread-18: Buffer Product succ, num is 10, buffer size is 9
Thread: Thread-1, Buffer Consume succ, num is 1, buffer size is 8
Thread: Thread-5, Buffer Consume succ, num is 3, buffer size is 5
Thread: Thread-9, Buffer Consume succ, num is 5, buffer size is 0
Thread: Thread-19, Buffer Consume fail, num is 10, buffer size is 0
Thread: Thread-19, Buffer Consume fail, num is 10, buffer size is 0
Thread: Thread-19, Buffer Consume fail, num is 10, buffer size is 0
Thread: Thread-19, Buffer Consume fail, num is 10, buffer size is 0
Thread: Thread-19, Buffer Consume fail, num is 10, buffer size is 0
Disconnected from the target VM, address: &#39;127.0.0.1:53178&#39;, transport: &#39;socket&#39;
Thread: Thread-19, Buffer Consume fail, num is 10, buffer size is 0
Thread Thread-18: Buffer Product succ, num is 10, buffer size is 10
Thread: Thread-19, Buffer Consume succ, num is 10, buffer size is 0

Process finished with exit code 0

&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;工作原理&#34;&gt;工作原理&lt;/h3&gt;

&lt;p&gt;主程序首先实例化一个共享缓冲区对象buffer，然后将该共享缓冲区对象buffer作为构造参数生成若干个生产者线程，和若干个消费者线程。&lt;/p&gt;

&lt;p&gt;生产者线程调用共享缓冲区的bufferProduce(num)方法生产元素，在生产前要先获取锁(lock.lock()方法)，并判断当前共享缓冲区是否能够容纳所有元素，如果不能容纳，则直接返回false，并释放锁。如果可以容纳，则进行生产活动，返回true，并释放锁。生产者线程在一个while循环里判断，如果生产失败(返回false)，则等待一段时间，重新开始执行生产操作。如果生产成功，则结束当前线程。&lt;/p&gt;

&lt;p&gt;消费者线程调用共享缓冲区的bufferConsume(num)方法消费元素，在生产前要先获取锁(lock.lock()方法)，并判断当前共享缓冲区是否有足够的元素供消费，如果元素数量不够，则直接返回false，并释放锁。如果元素足够，则进行消费活动，返回true，并释放锁。消费者线程在一个while循环里判断，如果消费失败(返回false)，则等待一段时间，重新开始执行消费操作。如果消费成功，则结束当前线程。&lt;/p&gt;
</description>
    </item>
    
  </channel>
</rss>