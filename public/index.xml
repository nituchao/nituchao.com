<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>泥土巢</title>
    <link>http://nituchao.com/index.xml</link>
    <description>Recent content on 泥土巢</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh-CN</language>
    <copyright>Copyright (c) 2017, nituchao | All rights reserved.</copyright>
    <lastBuildDate>Mon, 06 Mar 2017 09:34:07 +0800</lastBuildDate>
    <atom:link href="http://nituchao.com/index.xml" rel="self" type="application/rss+xml" />
    
    <item>
      <title>YourKit远程连接线上服务器</title>
      <link>http://nituchao.com/post/2017/your-kit-yuan-cheng-lian-jie-xian-shang-fu-wu/</link>
      <pubDate>Mon, 06 Mar 2017 09:34:07 +0800</pubDate>
      
      <guid>http://nituchao.com/post/2017/your-kit-yuan-cheng-lian-jie-xian-shang-fu-wu/</guid>
      <description>

&lt;p&gt;YourKit是一款业内领先的性能分析工具，目前支持Java和.NET两个平台。该工具功能全面强悍，能通过本地连接或者远程连接的方式，对各种服务器，框架，平台的性能进行分析，并提供了多种由浅入深，针对开发环境或者生产环境的分析模式。该工具提供了高效的图形化显示方式，动动鼠标就可以对系统进行显微镜式的观察分析。&lt;/p&gt;

&lt;p&gt;通过YourKit可以对以下内容进行分析：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;CPU profiling - investigate performace issues&lt;/li&gt;
&lt;li&gt;Memory profiling - memory leaks, usage, GC&lt;/li&gt;
&lt;li&gt;Threads and synchronization&lt;/li&gt;
&lt;li&gt;Exception profiling&lt;/li&gt;
&lt;li&gt;Web, Database, I/O&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;本文想总结一下，YourKit提供的两种连接到Java进程的方式，一种是attach方式，另一种是integrate方式。&lt;/p&gt;

&lt;h2 id=&#34;通过attach方式连接到远程服务器&#34;&gt;通过attach方式连接到远程服务器&lt;/h2&gt;

&lt;p&gt;在控制台，attach方式可以通过进程号，连接到运行中的任何Java进程中，这种方式并不保证总能连接成功，而且会禁用某些分析功能。&lt;/p&gt;

&lt;h4 id=&#34;线上环境&#34;&gt;线上环境&lt;/h4&gt;

&lt;ul&gt;
&lt;li&gt;CentOS release 6.3 64-Bit&lt;/li&gt;
&lt;li&gt;Java 1.7.0_79 HotSpot&amp;trade; 64-Bit Server VM&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&#34;下载安装包&#34;&gt;下载安装包&lt;/h4&gt;

&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;# wget https://www.yourkit.com/download/yjp-2017.02-b53.zip
# unzip yjp-2017.02-b53.zip
# cd yjp-2017.02
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;确定服务进程号&#34;&gt;确定服务进程号&lt;/h4&gt;

&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;# jps
2230 Resin
3959 Jps
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;console连接进程&#34;&gt;Console连接进程&lt;/h4&gt;

&lt;p&gt;通过下面的命令来连接到Java进程。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;# bin/yjp.sh -attach
[YourKit Java Profiler 2017.02-b53] Log file: /root/.yjp/log/yjp-4473.log
Running JVMs:

Name                             |   PID| Status
-------------------------------- |------|--------------------------------
Resin                            | 11760| Ready for attach
ThriftMain                       |  2934| Ready for attach
Resin                            |  2230| Agent already loaded, agent port is 10001
Resin                            | 14232| Ready for attach
Resin                            |  3657| Ready for attach
WatchdogManager                  | 16411| Ready for attach

Enter PID of the application you want to attach (0 to exit) and press Enter:
&amp;gt;2230
Please specify comma-separated list of startup options, or press Enter for default options (recommended):
&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;上面的操作执行完成后，会出现如下提示，表示YourKit Console服务已经成功运行，并在10001开始工作。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;Attaching to process 2230 using default options
[YourKit Java Profiler 2017.02-b53] Log file: /root/.yjp/log/yjp-30209.log
The profiler agent has attached. Waiting while it initializes...
The agent is loaded and is listening on port 10001.
You can connect to it from the profiler UI.
# lsof -i:10001
COMMAND  PID USER   FD   TYPE    DEVICE SIZE/OFF NODE NAME
java    2230 root   72u  IPv4 199000044      0t0  TCP *:scp-config (LISTEN)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;在浏览器，通过ip:port的方式，可以看到YourKit的运行概况。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://olno3yiqc.bkt.clouddn.com/blog/img/your-kit-attach.png&#34; alt=&#34;YourKit Attach&#34; /&gt;&lt;/p&gt;

&lt;h4 id=&#34;yourkit-ui连接远程服务&#34;&gt;YourKit UI连接远程服务&lt;/h4&gt;

&lt;p&gt;打开YourKit UI，点击Connect to remote application，输入IP:PORT进行连接。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://olno3yiqc.bkt.clouddn.com/blog/img/yourkit-connect-attach.png&#34; alt=&#34;YourKit Connect&#34; /&gt;&lt;/p&gt;

&lt;p&gt;连接成功后，进行性能分析界面，大功告成。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://olno3yiqc.bkt.clouddn.com/blog/img/yourkit-home-attach.png&#34; alt=&#34;YourKit性能分析界面&#34; /&gt;&lt;/p&gt;

&lt;h4 id=&#34;疑难问题&#34;&gt;疑难问题&lt;/h4&gt;

&lt;p&gt;通过attach方式并不总能连接到Java进程，常常会出现JVM无响应的问题，控制台报错如下：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;Attaching to process 31833 using options
com.yourkit.util.bf: com.sun.tools.attach.AttachNotSupportedException: Unable to open socket file: target process not responding or HotSpot VM not loaded
	at com.yourkit.b.f.a(a:128)
	at com.yourkit.b.c.attach(a:1)
	at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)
	at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.lang.reflect.Method.invoke(Method.java:498)
	at com.yourkit.h.run(a:17)

Attach to a running JVM failed.

Solution: start JVM with the profiler agent instead of attaching it to a running JVM:
https://www.yourkit.com/docs/java/help/running_with_profiler.jsp
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;因此，分析本地Java进程时可以选择attach方式，对于远程服务，还是推荐integrate方式。&lt;/p&gt;

&lt;h2 id=&#34;通过integrate方式连接到远程服务器-重点推荐&#34;&gt;通过integrate方式连接到远程服务器（重点推荐）&lt;/h2&gt;

&lt;p&gt;integrate方式通过修服务器启动配置文件，随服务启动，这种方式比较稳定，而且能够全面启用YourKit的所有功能。&lt;/p&gt;

&lt;h4 id=&#34;线上环境-1&#34;&gt;线上环境&lt;/h4&gt;

&lt;ul&gt;
&lt;li&gt;CentOS release 6.3 64-Bit&lt;/li&gt;
&lt;li&gt;Java 1.7.0_79 HotSpot&amp;trade; 64-Bit Server VM&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&#34;下载安装包-1&#34;&gt;下载安装包&lt;/h4&gt;

&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;# wget https://www.yourkit.com/download/yjp-2017.02-b53.zip
# unzip yjp-2017.02-b53.zip
# cd yjp-2017.02
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;确定服务进程号-1&#34;&gt;确定服务进程号&lt;/h4&gt;

&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;# jps
2230 Resin
3959 Jps
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;console连接进程-1&#34;&gt;Console连接进程&lt;/h4&gt;

&lt;p&gt;通过下面的命令来连接到Java进程。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;# bin/yjp.sh -integrate
Choose server to integrate with:
1) Geronimo
2) GlassFish
3) JBoss / WildFly
4) Jetty
5) JRun 4
6) Resin 3.1/4
7) Tomcat 3–8
8) WebLogic 9 and newer
9) WebSphere Application Server 7 or newer
10) WebSphere Application Server V8.5 Liberty profile
11) Generic server (use if your server is not on the list)
Enter number which corresponds to your server (0 to exit) and press Enter:
&amp;gt;6
Please specify whether the server runs on a 32-bit JVM or a 64-bit JVM.
Hint: If you are not sure what to choose, choose &amp;quot;32-bit JVM&amp;quot;. If with this choice the server does not start with profiling, re-run the integration and choose &amp;quot;64-bit Java&amp;quot; option.
1) 32-bit JVM
2) 64-bit JVM
&amp;gt;2
Resin configuration file (&amp;lt;RESIN_HOME&amp;gt;/conf/resin.xml or &amp;lt;RESIN_HOME&amp;gt;/conf/resin.conf):
&amp;gt;/home/work/bin/miui-sec-adv/resin/conf/resin.xml

Startup options configuration: step 1 of 5
Should option &#39;disablestacktelemetry&#39; be specified?
1) Yes (recommended to minimize profiling overhead in production)
2) No
&amp;gt;2
Startup options configuration: step 2 of 5
Should option &#39;exceptions=disable&#39; be specified?
1) Yes (recommended to minimize profiling overhead in production)
2) No
&amp;gt;1
Startup options configuration: step 3 of 5
Built-in probes:

1) Enabled: recommended for use in DEVELOPMENT; gives high level profiling results, but may add overhead
2) Disabled: recommended for use in PRODUCTION to minimise overhead, or for troubleshooting

Hint: It&#39;s recommended to choose #1 in development and #2 in production.
If choosing #1 makes profiling overhead big or there are startup issues, re-run the integration and choose #2.
&amp;gt;2
Startup options configuration: step 4 of 5
Should option &#39;delay=10000&#39; be specified?
1) Yes (recommended)
2) No
&amp;gt;1
Startup options configuration: step 5 of 5
Please specify comma-separated list of additional startup options, or press Enter for no additional options:
&amp;gt;
A new config file is created:

/home/work/bin/miui-sec-adv/resin/conf/resin_yjp.xml

To profile the server:

1) [Recommended] Backup original &#39;resin.xml&#39;
2) Rename &#39;resin_yjp.xml&#39; to &#39;resin.xml&#39;
3) Start the server
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;上面的操作执行完成后，会在操作中指定的resin配置文件目录生成&lt;code&gt;resin_yjp.xml&lt;/code&gt;文件，接下来将该&lt;code&gt;resin_yjp.xml&lt;/code&gt;重命名为&lt;code&gt;resin.xml&lt;/code&gt;，并启动服务器。正常情况下，YourKit的Console程序便会随着Resin服务器自动启动，可以通过&lt;code&gt;lsof&lt;/code&gt;命令确认一下。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;# lsof -i:10001
COMMAND  PID USER   FD   TYPE     DEVICE SIZE/OFF NODE NAME
java    2389 work    8u  IPv4 3188835745      0t0  TCP *:scp-config (LISTEN)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;同时，可以通过IP:PORT的方式在浏览器中查看YourKit Console服务的概况。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://olno3yiqc.bkt.clouddn.com/blog/img/yourkit-page-integrate.png&#34; alt=&#34;YourKit Page&#34; /&gt;&lt;/p&gt;

&lt;h4 id=&#34;yourkit-ui连接远程服务-1&#34;&gt;YourKit UI连接远程服务&lt;/h4&gt;

&lt;p&gt;打开YourKit UI，点击Connect to remote application，输入IP:PORT进行连接。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://olno3yiqc.bkt.clouddn.com/blog/img/yourkit-ui-connect-integrate.png&#34; alt=&#34;YourKit UI Connect&#34; /&gt;&lt;/p&gt;

&lt;p&gt;连接成功后，进行性能分析界面，大功告成。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://olno3yiqc.bkt.clouddn.com/blog/img/your-kit-home-integrate.png&#34; alt=&#34;YourKit性能分析界面&#34; /&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>在CentOS上安装Rabbitmq集群</title>
      <link>http://nituchao.com/post/2017/centos-an-zhuang-rabbit-cluster/</link>
      <pubDate>Thu, 02 Mar 2017 17:35:54 +0800</pubDate>
      
      <guid>http://nituchao.com/post/2017/centos-an-zhuang-rabbit-cluster/</guid>
      <description>

&lt;h2 id=&#34;系统环境&#34;&gt;系统环境&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;CentOS 7 四台&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;安装包准备&#34;&gt;安装包准备&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;wxBase-2.8.12-1.el6.centos.x86_64.rpm&lt;/li&gt;
&lt;li&gt;wxGTK-2.8.12-1.el6.centos.x86_64.rpm&lt;/li&gt;
&lt;li&gt;wxGTK-gl-2.8.12-1.el6.centos.x86_64.rpm&lt;/li&gt;
&lt;li&gt;esl-erlang_19.2.3~centos~6_amd64.rpm&lt;/li&gt;
&lt;li&gt;otp_src_19.1.tar.gz&lt;/li&gt;
&lt;li&gt;rabbitmq-server-3.6.6-1.el6.noarch.rpm&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;安装erlang环境&#34;&gt;安装Erlang环境&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;# yum localinstall wxBase-2.8.12-1.el6.centos.x86_64.rpm
# yum localinstall wxGTK-2.8.12-1.el6.centos.x86_64.rpm
# yum localinstall wxGTK-gl-2.8.12-1.el6.centos.x86_64.rpm
# yum localinstall esl-erlang_19.2.3~centos~6_amd64.rpm
# yum install build-essential openssl openssl-devel unixODBC unixODBC-devel make gcc gcc-c++ kernel-devel m4 ncurses-devel tk tc
# tar -zxvf otp_src_19.1.tar.gz
# cd otp_src_19.1
# ./configure --prefix=/home/erlang --without-javac
# make &amp;amp;&amp;amp; make install
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;安装完Erlang之后，修改/etc/profile增加&lt;/p&gt;

&lt;p&gt;export PATH=$PATH:/home/erlang/bin&lt;/p&gt;

&lt;p&gt;执行source /etc/profile使得环境变量生效&lt;/p&gt;

&lt;h2 id=&#34;安装rabbitmq&#34;&gt;安装Rabbitmq&lt;/h2&gt;

&lt;h3 id=&#34;安装rabbitmq-1&#34;&gt;安装rabbitmq&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;# rpm --import https://www.rabbitmq.com/rabbitmq-release-signing-key.asc
# rpm --nodeps -Uvh rabbitmq-server-3.6.6-1.noarch.rpm
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;添加开机启动&#34;&gt;添加开机启动&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;# chkconfig rabbitmq-server on
# service rabbitmq-server start
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;开启web管理界面&#34;&gt;开启web管理界面&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;# rabbitmq-plugins enable rabbitmq_management
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;添加用户&#34;&gt;添加用户&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;# rabbitmqctl add_user work workO^m15213
# rabbitmqctl set_user_tags work administrator
# rabbitmqctl set_permissions -p / work &amp;quot;.*&amp;quot;&amp;quot;.*&amp;quot;&amp;quot;.*&amp;quot;
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>jstack命令</title>
      <link>http://nituchao.com/post/2017/tong-guo-jstack-fen-xi/</link>
      <pubDate>Tue, 28 Feb 2017 19:01:58 +0800</pubDate>
      
      <guid>http://nituchao.com/post/2017/tong-guo-jstack-fen-xi/</guid>
      <description>

&lt;p&gt;Java程序在操作系统上是以单进程、多线程的形式运行。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;[work@zc-stage1-miui-sec02 ~]$ jstack
Usage:
    jstack [-l] &amp;lt;pid&amp;gt;
        (to connect to running process)
    jstack -F [-m] [-l] &amp;lt;pid&amp;gt;
        (to connect to a hung process)
    jstack [-m] [-l] &amp;lt;executable&amp;gt; &amp;lt;core&amp;gt;
        (to connect to a core file)
    jstack [-m] [-l] [server_id@]&amp;lt;remote server IP or hostname&amp;gt;
        (to connect to a remote debug server)

Options:
    -F  to force a thread dump. Use when jstack &amp;lt;pid&amp;gt; does not respond (process is hung)
    -m  to print both java and native frames (mixed mode)
    -l  long listing. Prints additional information about locks
    -h or -help to print this help message
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;jstack参数说明&#34;&gt;jstack参数说明&lt;/h2&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;连接到运行中的进程&lt;/p&gt;

&lt;p&gt;&amp;ldquo;jstack pid&amp;rdquo;，pid为进程号，可以通过jps或者top命令查到。&lt;/p&gt;

&lt;p&gt;命令执行成功则堆栈信息打印在控制台，可以通过&amp;rdquo;jstack 7023 &amp;gt; stack.log&amp;rdquo;这种方式将内容输出文件。&lt;/p&gt;

&lt;p&gt;导出的文本中包含线程号，线程号状态，线程调用栈等信息，结合ps命令中查询出的线程号，可以分析出CPU使用率比较高的线程，以及该线程中的调用堆栈，进而可以定位到项目代码。&lt;/p&gt;

&lt;p&gt;```
Thread 1091: (state = BLOCKED)&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;sun.misc.Unsafe.park(boolean, long) @bci=0 (Compiled frame; information may be imprecise)&lt;/li&gt;
&lt;li&gt;java.util.concurrent.locks.LockSupport.park() @bci=5, line=315 (Interpreted frame)&lt;/li&gt;
&lt;li&gt;com.caucho.env.thread2.ResinThread2.park() @bci=29, line=196 (Compiled frame)&lt;/li&gt;
&lt;li&gt;com.caucho.env.thread2.ResinThread2.runTasks() @bci=65, line=147 (Compiled frame)&lt;/li&gt;
&lt;li&gt;com.caucho.env.thread2.ResinThread2.run() @bci=15, line=118 (Interpreted frame)
```&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;Thread 1089: (state = BLOCKED)
    - sun.misc.Unsafe.park(boolean, long) @bci=0 (Compiled frame; information may be imprecise)
    - java.util.concurrent.locks.LockSupport.park() @bci=5, line=315 (Interpreted frame)
    - com.caucho.env.thread2.ResinThread2.park() @bci=29, line=196 (Compiled frame)
    - com.caucho.env.thread2.ResinThread2.runTasks() @bci=65, line=147 (Compiled frame)
    - com.caucho.env.thread2.ResinThread2.run() @bci=15, line=118 (Interpreted frame)&lt;/p&gt;

&lt;p&gt;Thread 1088: (state = IN_NATIVE)
    - java.net.SocketInputStream.socketRead0(java.io.FileDescriptor, byte[], int, int, int) @bci=0 (Compiled frame; information may be imprecise)
    - java.net.SocketInputStream.read(byte[], int, int, int) @bci=79, line=150 (Compiled frame)
    - java.net.SocketInputStream.read(byte[], int, int) @bci=11, line=121 (Compiled frame)
    - java.net.SocketInputStream.read(byte[]) @bci=5, line=107 (Compiled frame)
    - redis.clients.util.RedisInputStream.ensureFill() @bci=20, line=195 (Compiled frame)
    - redis.clients.util.RedisInputStream.readByte() @bci=1, line=40 (Compiled frame)
    - redis.clients.jedis.Protocol.process(redis.clients.util.RedisInputStream) @bci=1, line=141 (Compiled frame)
    - redis.clients.jedis.Protocol.read(redis.clients.util.RedisInputStream) @bci=1, line=205 (Compiled frame)
    - redis.clients.jedis.Connection.readProtocolWithCheckingBroken() @bci=4, line=297 (Compiled frame)
    - redis.clients.jedis.Connection.getBinaryBulkReply() @bci=15, line=216 (Compiled frame)
    - redis.clients.jedis.Connection.getBulkReply() @bci=1, line=205 (Compiled frame)
    - redis.clients.jedis.Jedis.get(java.lang.String) @bci=27, line=101 (Compiled frame)
    - redis.clients.jedis.JedisCluster$3.execute(redis.clients.jedis.Jedis) @bci=5, line=79 (Compiled frame)
    - redis.clients.jedis.JedisCluster$3.execute(redis.clients.jedis.Jedis) @bci=2, line=76 (Compiled frame)
    - redis.clients.jedis.JedisClusterCommand.runWithRetries(byte[], int, boolean, boolean) @bci=78, line=119 (Compiled frame)
    - redis.clients.jedis.JedisClusterCommand.run(java.lang.String) @bci=25, line=30 (Compiled frame)
    - redis.clients.jedis.JedisCluster.get(java.lang.String) @bci=18, line=81 (Compiled frame)
    - com.xiaomi.miui.sec.service.RedisCacheService$14.call(redis.clients.jedis.RedisCluster) @bci=5, line=667 (Compiled frame)
    - com.xiaomi.miui.sec.service.RedisCacheService$14.call(java.lang.Object) @bci=5, line=663 (Compiled frame)
    - com.xiaomi.miui.cache.rediscluster.DefaultRedisClusterCache.get(java.lang.Object, com.xiaomi.miui.cache.rediscluster.RedisClusterCallable) @bci=22, line=68 (Compiled frame)
    - com.xiaomi.miui.sec.service.RedisCacheService.getSettingAdv(java.lang.String, java.lang.String, java.lang.String) @bci=49, line=663 (Compiled frame)
    - com.xiaomi.miui.sec.service.CacheService.getSettingAdv(java.lang.String, java.lang.String, java.lang.String) @bci=7, line=113 (Compiled frame)
    - com.xiaomi.miui.sec.bizLogic.SettingBiz.postHandlerMiCom(net.sf.json.JSONObject, com.xiaomi.miui.sec.thrift.Device, net.paoding.rose.web.Invocation) @bci=55, line=119 (Compiled frame)
    - com.xiaomi.miui.sec.bizLogic.SettingBiz.postHandler(net.sf.json.JSONObject, com.xiaomi.miui.sec.thrift.Device, net.paoding.rose.web.Invocation) @bci=118, line=65 (Compiled frame)
    - com.xiaomi.miui.sec.bizLogic.BasicBiz.mainHandler(net.paoding.rose.web.Invocation) @bci=29, line=59 (Compiled frame)
    - com.xiaomi.miui.sec.controllers.InfoController.setting(net.paoding.rose.web.Invocation, java.lang.String) @bci=73, line=252 (Compiled frame)
    - sun.reflect.GeneratedMethodAccessor31.invoke(java.lang.Object, java.lang.Object[]) @bci=48 (Compiled frame)
    - sun.reflect.DelegatingMethodAccessorImpl.invoke(java.lang.Object, java.lang.Object[]) @bci=6, line=43 (Compiled frame)
    - java.lang.reflect.Method.invoke(java.lang.Object, java.lang.Object[]) @bci=57, line=606 (Compiled frame)&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;
   ​

## jstack分析java线程的CPU使用率和使用时长



## jstack分析分析已有的javacore文件



## jstack连接到远程调试服务器进行分析
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>解决Java进程占用CPU过高的问题</title>
      <link>http://nituchao.com/post/2017/ji-lu-yi-ci-cpu-guo-gao-chu-li/</link>
      <pubDate>Tue, 28 Feb 2017 09:16:18 +0800</pubDate>
      
      <guid>http://nituchao.com/post/2017/ji-lu-yi-ci-cpu-guo-gao-chu-li/</guid>
      <description></description>
    </item>
    
    <item>
      <title>Atomic变量</title>
      <link>http://nituchao.com/post/juc.atomic/atomic-summary/</link>
      <pubDate>Thu, 23 Feb 2017 18:39:27 +0800</pubDate>
      
      <guid>http://nituchao.com/post/juc.atomic/atomic-summary/</guid>
      <description>&lt;p&gt;Java原子变量的诞生源自一个简单的需求 —— 多个线程共享某个变量或者对象时，需要对修改和读取操作进行同步。&lt;/p&gt;

&lt;p&gt;同步包含两层含义：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;互斥访问&lt;/li&gt;
&lt;li&gt;可见性&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;通常，多线程对临界资源的互斥访问通过对象锁(synchronized关键字)保证。对象锁是一种独占锁（悲观锁），会导致其它所有需要锁的线程挂起。而可见性则由volatile的内存语义保证。&lt;/p&gt;

&lt;p&gt;Java 1.5开始提供了原子变量和原子引用，这些类放置在&lt;code&gt;java.util.concurrent&lt;/code&gt;下。大概可以归为4类：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;基本类型：AtomicInteger, AtomicLong, AtomicBoolean;&lt;/li&gt;
&lt;li&gt;数组类型：AtomicIntegerArray, AtomicLongArray, AtomicReferenceArray;&lt;/li&gt;
&lt;li&gt;引用类型：AtomicReference, AtomicStampedReference, AtomicMarkableReference;&lt;/li&gt;
&lt;li&gt;对象的属性修改类型：AtomicIntegerFieldUpdater, AtomicLongFieldUpdater, AtomicReferenceFieldUpdater;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;Java原子变量的存在是为了对相应的数据进行原子操作。&lt;/p&gt;

&lt;p&gt;所谓的原子操作包含下面几层含义：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;操作过程不会被中断。&lt;/li&gt;
&lt;li&gt;操作过程不会被阻塞。&lt;/li&gt;
&lt;li&gt;修改结果被其他线程可见。&lt;/li&gt;
&lt;/ol&gt;
</description>
    </item>
    
    <item>
      <title>Java锁之AOS抽象类源码分析</title>
      <link>http://nituchao.com/post/juc.lock/lock-abstract-ownable-synchronizer/</link>
      <pubDate>Thu, 23 Feb 2017 18:39:27 +0800</pubDate>
      
      <guid>http://nituchao.com/post/juc.lock/lock-abstract-ownable-synchronizer/</guid>
      <description>

&lt;h2 id=&#34;概述&#34;&gt;概述&lt;/h2&gt;

&lt;p&gt;在JUC包中实现的同步器锁分为独占锁(如ReentrantLock、WriteLock)和共享锁(ReadLock)。共享锁本质上是通过对volatile修饰的计数器state进行维护而实现的。独占锁则是通过在同步器中设置独占线程来实现的。在JUC包中AbstractOwnableSynchronizer是个抽象类，它维护了一个Thread类型的成员变量，标识当前独占同步器的线程引用。AbstractOwnableSynchronizer的子类是大名鼎鼎的AbstractQueuedSynchronizer和AbstractQueuedLongSynchronizer，这两个子类是实现JUC包下锁框架的基础。&lt;/p&gt;

&lt;p&gt;本文重点研究AbstractOwnerSynchronizer抽象类的设计，具体实现会在AbstractQueuedSynchronizer类中进行分析。&lt;/p&gt;

&lt;p&gt;本文基于JDK1.7.0_67&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;java version &amp;ldquo;1.7.0&lt;em&gt;67&amp;rdquo;&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;_Java&amp;trade; SE Runtime Environment (build 1.7.0_67-b01)&lt;/p&gt;

&lt;p&gt;Java HotSpot&amp;trade; 64-Bit Server VM (build 24.65-b04, mixed mode)&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&#34;成员变量&#34;&gt;成员变量&lt;/h2&gt;

&lt;p&gt;在AbstractOwnableSynchronizer类中只有一个成员变量exclusiveOwnerThread，该变量记录当前独占同步器的那个线程。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;private transient Thread exclusiveOwnerThread;
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;函数列表&#34;&gt;函数列表&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;// 空实现的构造函数，供子类实现
protected AbstractOwnableSynchronizer();
// 设置同步器的独占线程
protected final void setExclusiveOwnerThread(Thread t);
// 获取同步器的独占线程
protected final Thread getExclusiveOwnerThread();
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>Java锁之AQS抽象类源码分析</title>
      <link>http://nituchao.com/post/juc.lock/lock-abstract-queued-synchronizer/</link>
      <pubDate>Thu, 23 Feb 2017 18:39:27 +0800</pubDate>
      
      <guid>http://nituchao.com/post/juc.lock/lock-abstract-queued-synchronizer/</guid>
      <description>

&lt;h2 id=&#34;概述&#34;&gt;概述&lt;/h2&gt;

&lt;p&gt;队列同步器AbstractQueuedSynchronizer（以下简称AQS），是用来构建锁或者其他同步组件的基础框架。它使用一个int成员变量来表示同步状态（重入次数，共享状态等），通过CAS操作对同步状态进行修改，确保状态的改变是安全的。通过内置的FIFO(First In First Out)队列来完成资源获取的排队工作。在AQS里有两个队列，分别是维护Sync Queue和Condition Queue，两个队列的节点都是AQS的静态内部类Node。Sync Queue在独占模式和共享模式中均会使用到，本质上是一个存放Node的CLH队列（主要特点是, 队列中总有一个 dummy 节点, 后继节点获取锁的条件由前继节点决定, 前继节点在释放 lock 时会唤醒sleep中的后继节点），维护的是等待获取锁的线程信息。Condition Queue在独占模式中才会用到，当用户使用条件变量进行线程同步时，维护的是等待条件变量的线程信息。&lt;/p&gt;

&lt;p&gt;通过AQS实现的锁分独占锁(ReentrantLock，WriteLock，Segment等)和共享锁(ReadLock)，使用一个volatile修饰的int类型的变量state来表示当前同步块的状态。state在AQS中功能强大，即可以用来表示同步器的加锁状态，也可以用来表示重入锁的重入次数(tryAcquire)，还可以用来标识读锁和写锁的加锁状态。&lt;/p&gt;

&lt;p&gt;在AQS的基础上，JUC包实现了如下几类锁：
1，公平锁和非公平所&lt;/p&gt;

&lt;p&gt;2，可重入锁&lt;/p&gt;

&lt;p&gt;3，独占锁和共享锁&lt;/p&gt;

&lt;p&gt;以上三类锁并不是独立的，可以有多种组合。&lt;/p&gt;

&lt;p&gt;1，ReentrantLock：可重入锁，公平锁|非公平锁，独占锁。&lt;/p&gt;

&lt;p&gt;2，ReentrantReadWriteLock：可重入锁，公平锁|非公平锁，独占锁|共享锁。&lt;/p&gt;

&lt;p&gt;另外，除了上面列举的ReentrantLock和ReentrantReadWriteLock外，下面几个类也是依靠AQS实现的。&lt;/p&gt;

&lt;p&gt;1，CountDownLatch&lt;/p&gt;

&lt;p&gt;2，CyclicBarrier&lt;/p&gt;

&lt;p&gt;3，Semaphore&lt;/p&gt;

&lt;p&gt;4，Segment&lt;/p&gt;

&lt;p&gt;AQS主要包含下面几个特点，是我们理解AQS框架的关键：&lt;/p&gt;

&lt;p&gt;1，内部含有两条队列（Sync Queue，Condition Queue）。&lt;/p&gt;

&lt;p&gt;2，AQS内部定义获取锁（acquire），释放锁（release）的主逻辑，子类实现相应的模板方法。&lt;/p&gt;

&lt;p&gt;3，支持共享和独占两种模式（共享模式时只用Sync Queue，独占时只用Sync Queue，但如果涉及条件变量Condition，则还有Condition Queue）。&lt;/p&gt;

&lt;p&gt;4，支持不响应中断获取独占锁（acquire），响应中断获取独占锁（acquireInterruptibly），超时获取独占锁（tryAcquireNanos）；不响应中断获取共享锁（acquireShared），响应中断获取共享锁（acquireSharedInterruptibly），超时获取共享锁（tryAcquireSharedNanos）；&lt;/p&gt;

&lt;p&gt;5，在子类的tryAcquire，tryAcquireShared中实现公平和非公平的区分。&lt;/p&gt;

&lt;p&gt;本文重点介绍AbstractQueuedSynchronizer的设计，其实现待到具体的子类再做分析。&lt;/p&gt;

&lt;p&gt;本文基于JDK1.7.0_67&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;java version &amp;ldquo;1.7.0&lt;em&gt;67&amp;rdquo;&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;_Java&amp;trade; SE Runtime Environment (build 1.7.0_67-b01)&lt;/p&gt;

&lt;p&gt;Java HotSpot&amp;trade; 64-Bit Server VM (build 24.65-b04, mixed mode)&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&#34;内部类&#34;&gt;内部类&lt;/h2&gt;

&lt;h3 id=&#34;node&#34;&gt;Node&lt;/h3&gt;

&lt;p&gt;Node是AbstractQueuedSynchronizer的静态内部类，文章概述里，我们说在AQS中有两类等待队列(Sync Queue和Condition Queue)，Node就是等待队列的节点类。AQS的等待队列是&amp;rdquo;CLH&amp;rdquo;锁队列的变种。&amp;rdquo;CLH&amp;rdquo;锁是一种自旋锁，在AQS中&lt;/p&gt;

&lt;h4 id=&#34;成员变量&#34;&gt;成员变量&lt;/h4&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;// 标识节点是否是 共享的节点(这样的节点只存在于 Sync Queue 里面)
static final Node SHARED = new Node();
// 标识节点是 独占模式
static final Node EXCLUSIVE = null;
// 代表线程已经被取消
static final int CANCELLED =  1;
// 代表后续节点需要唤醒
static final int SIGNAL    = -1;
// 代表线程在condition queue中，等待某一条件
static final int CONDITION = -2;
// 代表后续结点会传播唤醒的操作，共享模式下起作用
static final int PROPAGATE = -3;
// 当前节点的状态
volatile int waitStatus;
// 当前节点的上一个节点
volatile Node prev;
// 当前节点的下一个节点
volatile Node next;
// 当前节点代表的线程
volatile Thread thread;
// 这个节点等待的模式(共享模式和独占模式)
Node nextWaiter;
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;函数列表&#34;&gt;函数列表&lt;/h4&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;// 空制造函数
Node();
// 构造函数，初始化nextWaiter
// addWaiter使用
Node(Thread thread, Node mode);
// 构造函数，初始化waitStatus
// Condition使用
Node(Thread thread, int waitStatus);
// 如果当前节点的等待模式(nextWaiter)是共享模式，返回true
final boolean isShared();
// 返回当前节点的上一个节点
final Node predecessor() throws NullPointerException;
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;conditionobject&#34;&gt;ConditionObject&lt;/h3&gt;

&lt;p&gt;参考：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://download.csdn.net/detail/u011898232/9548575&#34;&gt;Java 并发编程的艺术&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://ifeve.com/sun-misc-unsafe/&#34;&gt;Java Magic. Part 4: sun.misc.Unsafe&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://www.blogjava.net/mstar/archive/2013/04/24/398351.html&#34;&gt;Java里的CompareAndSet(CAS)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://blog.csdn.net/luonanqin/article/details/41871909&#34;&gt;ReentrantLock的lock-unlock流程详解&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://blog.csdn.net/chen77716/article/details/6641477&#34;&gt;深入JVM锁机制2-Lock&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://www.infoq.com/cn/articles/jdk1.8-abstractqueuedsynchronizer&#34;&gt;深度解析Java 8：JDK1.8 AbstractQueuedSynchronizer的实现分析（上）&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://www.cnblogs.com/zhanjindong/p/java-concurrent-package-aqs-AbstractQueuedSynchronizer.html&#34;&gt;AbstractQueuedSynchronizer源码分析&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://my.oschina.net/xianggao/blog/532709&#34;&gt;聊聊并发（十二）—AQS分析&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://www.javarticles.com/2012/10/abstractqueuedsynchronizer-aqs.html&#34;&gt;AbstractQueuedSynchronizer (AQS)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://blog.csdn.net/tomato__/article/details/24774465&#34;&gt;并发编程实践二：AbstractQueuedSynchronizer&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>Java锁之Condition接口源码分析</title>
      <link>http://nituchao.com/post/juc.lock/lock-condition/</link>
      <pubDate>Thu, 23 Feb 2017 18:39:27 +0800</pubDate>
      
      <guid>http://nituchao.com/post/juc.lock/lock-condition/</guid>
      <description>

&lt;h2 id=&#34;概述&#34;&gt;概述&lt;/h2&gt;

&lt;p&gt;Condition是一个接口，用于定义条件变量。条件变量的实例化是通过一个Lock对象调用newCondition()方法获取的，这样，条件变量就和一个锁对象绑定起来了。Java中的条件变量只能和锁配合使用，来控制编发程序访问竞争资源的安全。条件变量增强了juc包下基于AQS锁框架的灵活性。对比synchronized代表的监视器锁，条件变量将锁和监视器操作(await, signal, signalAll)分离开来，而且一个锁可以绑定多个条件变量，每个条件变量的实例会维护一个单独的等待队列。条件变量使得锁框架能更加精细控制线程等待与唤醒。在AbstractQueuedSynchronizer和AbstractQueuedLongSynchronizer类中分别有一个实现ConditionObject，为整个AQS框架提供条件变量的相关能力。&lt;/p&gt;

&lt;p&gt;本文重点关注Condition接口的设计，具体实现会在AbstractQueuedSynchronizer类中进行具体分析。&lt;/p&gt;

&lt;p&gt;本文基于JDK1.7.0_67&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;java version &amp;ldquo;1.7.0&lt;em&gt;67&amp;rdquo;&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;_Java&amp;trade; SE Runtime Environment (build 1.7.0_67-b01)&lt;/p&gt;

&lt;p&gt;Java HotSpot&amp;trade; 64-Bit Server VM (build 24.65-b04, mixed mode)&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&#34;函数列表&#34;&gt;函数列表&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;void await() throws InterruptedException;
void awaitUninterruptibly();
long awaitNanos(long nanosTimeout) throws InterruptedException;
boolean await(long time, TimeUnit unit) throws InterruptedException;
boolean awaitUntil(Date deadline) throws InterruptedException;
void signal();
void signalAll();
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;重点函数分析&#34;&gt;重点函数分析&lt;/h2&gt;

&lt;h3 id=&#34;signal-和signalall&#34;&gt;signal()和signalAll()&lt;/h3&gt;

&lt;p&gt;signal()和signal()函数的字面意思很好理解，signal()负责唤醒等待队列中的一个线程，signalAll负责唤醒等待队列中的所有线程。&lt;/p&gt;

&lt;p&gt;那什么时候用signal()？什么时候用signalAll()？&lt;/p&gt;

&lt;p&gt;答案是：避免死锁的情况下，要用signalAll()，其他情况下两者可以通用，甚至signal()的效率要高一些。&lt;/p&gt;

&lt;p&gt;参考：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;a href=&#34;http://www.cnblogs.com/zhjh256/p/6389168.html&#34;&gt;java Condition条件变量的通俗易懂解释、基本使用及注意点&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://ifeve.com/understand-condition/&#34;&gt;怎么理解Condition&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://blog.csdn.net/ghsau/article/details/7481142&#34;&gt;Condition-线程通信更高效的方式&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;
</description>
    </item>
    
    <item>
      <title>Java锁之Lock接口源码分析</title>
      <link>http://nituchao.com/post/juc.lock/lock-lock/</link>
      <pubDate>Thu, 23 Feb 2017 18:39:27 +0800</pubDate>
      
      <guid>http://nituchao.com/post/juc.lock/lock-lock/</guid>
      <description>

&lt;h2 id=&#34;概述&#34;&gt;概述&lt;/h2&gt;

&lt;p&gt;在JUC包中，Lock接口定义了一个锁应该拥有基本操作。Lock接口的实现类非常多，既有共享锁，也有独占锁，甚至在ConcurrentHashMap等并发集合里的Segment结构本质上也是锁的实现。另外，Lock接口还组合了一个Condition类型的条件变量，用于提供更加灵活、高效的控制操作。&lt;/p&gt;

&lt;p&gt;本文重点关注Lock接口的设计，具体实现会在各个实现类中进行具体分析。&lt;/p&gt;

&lt;p&gt;本文基于JDK1.7.0_67&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;java version &amp;ldquo;1.7.0&lt;em&gt;67&amp;rdquo;&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;_Java&amp;trade; SE Runtime Environment (build 1.7.0_67-b01)&lt;/p&gt;

&lt;p&gt;Java HotSpot&amp;trade; 64-Bit Server VM (build 24.65-b04, mixed mode)&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&#34;函数列表&#34;&gt;函数列表&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;// 获取锁
// 如果获取失败，则进入阻塞队列
// 忽略了中断，在成功获取锁之后，再根据中断标识处理中断，即selfInterrupt中断自己
void lock();
// 获取锁
// 如果获取失败，则进入阻塞队列
// 在锁获取过程中不处理中断状态，而是直接抛出中断异常，由上层调用者处理中断。
void lockInterruptibly() throws InterruptedException;
// 尝试获取锁
// 获取成功，返回true
// 获取失败，返回fasle
// 不阻塞
boolean tryLock();
// 尝试获取锁
// 获取成功，返回true
// 获取失败，返回false
// 该操作必须在time时间内完成
boolean tryLock(long time, TimeUnit unit) throws InterruptedException;
// 释放锁
void unlock();
// 创建一个条件变量，用于更加精细地控制同步过程
Condition newCondition();
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>Java锁之ReadWriteLock接口源码分析</title>
      <link>http://nituchao.com/post/juc.lock/lock-read-write-lock/</link>
      <pubDate>Thu, 23 Feb 2017 18:39:27 +0800</pubDate>
      
      <guid>http://nituchao.com/post/juc.lock/lock-read-write-lock/</guid>
      <description>

&lt;h2 id=&#34;概述&#34;&gt;概述&lt;/h2&gt;

&lt;p&gt;为了提高性能，Java提供了读写锁，在读的地方使用读锁，在写的地方使用写锁，灵活控制。如果没有写锁的情况下，读是无阻塞的，在一定程度上提高了程序的执行效率。读锁本质上是一种共享锁，写锁本质上是一种互斥锁。Java通过ReadWriteLock接口声明了读写锁的相关操作，通过该接口用户可以同时获取一个读锁实例和写锁实例。ReentrantReadWriteLock是ReadWriteLock的唯一实现，该类通过静态内部类的方式实现了ReadLock和WriteLock，并且根据需要提供了公平锁(FairSync)和非公平所(NonfairSync)的实现。&lt;/p&gt;

&lt;p&gt;本文重点关注ReadWriteLock接口的设计，具体实现会在ReentrantReadWriteLock类中进行具体分析。&lt;/p&gt;

&lt;p&gt;本文基于JDK1.7.0_67&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;java version &amp;ldquo;1.7.0&lt;em&gt;67&amp;rdquo;&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;_Java&amp;trade; SE Runtime Environment (build 1.7.0_67-b01)&lt;/p&gt;

&lt;p&gt;Java HotSpot&amp;trade; 64-Bit Server VM (build 24.65-b04, mixed mode)&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&#34;函数列表&#34;&gt;函数列表&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;Lock readLock();
Lock writeLock();
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;重点函数分析&#34;&gt;重点函数分析&lt;/h2&gt;

&lt;h3 id=&#34;readlock&#34;&gt;readLock&lt;/h3&gt;

&lt;p&gt;返回一个读锁。读锁本质上是一个共享锁。在Java的实现中，共享锁通过计数器实现，区分公平锁和非公平锁。&lt;/p&gt;

&lt;h3 id=&#34;writelock&#34;&gt;writeLock&lt;/h3&gt;

&lt;p&gt;返回一个写锁。写锁本质上是一个独占锁。在Java的实现中，区分公平锁和非公平锁。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Java锁之Unsafe类源码分析</title>
      <link>http://nituchao.com/post/juc.lock/java-unsafe/</link>
      <pubDate>Thu, 23 Feb 2017 18:39:27 +0800</pubDate>
      
      <guid>http://nituchao.com/post/juc.lock/java-unsafe/</guid>
      <description>

&lt;h2 id=&#34;一言&#34;&gt;一言&lt;/h2&gt;

&lt;p&gt;&lt;code&gt;sun.misc.Unsafe&lt;/code&gt;类是超越Java的存在，它违反了Java在内存管理上的设计初衷，却又是Java很多重要特性与功能得以实现的基础，它使Java的安全性受到威胁，却有使Java在很多方面的性能得到提升，它是魔鬼与天使的混合体。&lt;/p&gt;

&lt;h2 id=&#34;概述&#34;&gt;概述&lt;/h2&gt;

&lt;p&gt;Java是一个安全的开发工具，它阻止开发人员犯很低级的错误，而大部分的错误都是基于内存管理的。Unsafe类突破了Java原生的内存管理体制，使用Unsafe类可以在系统内存的任意地址进行读写数据，而这些操作对于普通用户来说是非常危险的，Unsafe的操作粒度不是类，而是数据和地址。&lt;/p&gt;

&lt;p&gt;从另一方讲，Java正被广泛应用于游戏服务器和高频率的交易应用。这些之所以能够实现主要归功于Java提供的这个非常便利的类&lt;code&gt;sun.mics.Unsafe&lt;/code&gt;。Unsafe类为了速度，在Java严格的安全标准方法做了一些妥协。&lt;/p&gt;

&lt;p&gt;Java在JUC包中提供了对&lt;code&gt;sun.misc.Unsafe&lt;/code&gt;类的封装实现，这就是&lt;code&gt;java.util.concurrent.LockSupport&lt;/code&gt;。&lt;/p&gt;

&lt;p&gt;本文基于JDK1.7.0_67&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;java version &amp;ldquo;1.7.0&lt;em&gt;67&amp;rdquo;&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;_Java&amp;trade; SE Runtime Environment (build 1.7.0_67-b01)&lt;/p&gt;

&lt;p&gt;Java HotSpot&amp;trade; 64-Bit Server VM (build 24.65-b04, mixed mode)&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&#34;重要函数&#34;&gt;重要函数&lt;/h2&gt;

&lt;p&gt;&lt;code&gt;sun.mics.Unsafe&lt;/code&gt;一共提供了106个函数，这些函数涵盖了以下五个方面的功能：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;对变量和数组内容的原子访问，自定义内存屏障&lt;/li&gt;
&lt;li&gt;对序列化的支持&lt;/li&gt;
&lt;li&gt;自定义内存管理/高效的内存布局&lt;/li&gt;
&lt;li&gt;与原生代码和其他JVM进行互操作&lt;/li&gt;
&lt;li&gt;对高级锁的支持&lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&#34;获取实例&#34;&gt;获取实例&lt;/h3&gt;

&lt;p&gt;&lt;code&gt;sun.misc.Unsafe&lt;/code&gt;只有一个无参的私有构造函数，要想实例化&lt;code&gt;sun.misc.Unsafe&lt;/code&gt;可以调用&lt;code&gt;getUnsafe()&lt;/code&gt;方法。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;@CallerSensitive
public static Unsafe getUnsafe() {
  Class var0 = Reflection.getCallerClass();
  if(var0.getClassLoader() != null) {
    throw new SecurityException(&amp;quot;Unsafe&amp;quot;);
  } else {
    return theUnsafe;
  }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;出于安全考虑，Unsafe类只能被系统类加载器实例化，否则会抛出&lt;code&gt;SecurityException&lt;/code&gt;异常。普通用户如果想实例化&lt;code&gt;sun.misc.Unsafe&lt;/code&gt;类的对象，需要通过类反射机制或者修改Java的安全策略。&lt;/p&gt;

&lt;h3 id=&#34;内存操作&#34;&gt;内存操作&lt;/h3&gt;

&lt;h4 id=&#34;获取成员变量偏移量&#34;&gt;获取成员变量偏移量&lt;/h4&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;// 返回对象中指定静态成员变量的内存偏移量(相对于类存储)
public native long staticFieldOffset(Field f);

// 返回对象中指定成员变量的内存偏移量(相对于对象实例)
public native long objectFieldOffset(Field f);

// 返回对象中指定成员变量
public native Object staticFieldBase(Field f);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;sun.misc.Unsafe&lt;/code&gt;的操作对象是内存数据，获取指定成员变量的内存地址是对其进行操作的第一步。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;objectFieldOffset&lt;/code&gt;是一个本地函数，返回指定静态field的内存地址偏移量，&lt;code&gt;Unsafe&lt;/code&gt;类的其他方法中这个值是被用作一个访问特定field的一个方式。这个值对于给定的field是唯一的，并且后续对该方法的调用都返回相同的值。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;objectFieldOffset&lt;/code&gt;获取到的是内存偏移量，并不是真正的内存指针地址，Unsafe类提供了&lt;code&gt;getAddress&lt;/code&gt;函数将该偏移量转换为真正的内存指针地址，有了该内存指针地址，就可以直接操作内存数据的读写了。&lt;/p&gt;

&lt;h4 id=&#34;操作成员变量数据&#34;&gt;操作成员变量数据&lt;/h4&gt;

&lt;p&gt;有了&lt;code&gt;objectFieldOffset&lt;/code&gt;获取到的内存偏移量，就可以使用Unsafe类对该内存位置的数据进行读写。Unsafe类提供了对所有Java基本数据类型（byte, short, int, long, float, double）和对象类型的读写，这些方法都是本地函数（另外有一些对本地函数进行封装的读写函数，已经被标识为弃用）。&lt;/p&gt;

&lt;p&gt;这些操作可以从另一个层面理解为&lt;code&gt;sun.misc.Unsafe&lt;/code&gt;对序列化和反序列化的支持。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;// o: 对象引用
// offset: 内存偏移量，通过objectFieldOffset获取
public native int getInt(Object o, long offset);
// o: 对象引用
// offset: 内存偏移量，通过objectFieldOffset获取
// x: 新的数据值
public native void putInt(Object o, long offset, int x);
public native Object getObject(Object o, long offset);
public native void putObject(Object o, long offset, Object x);
public native boolean getBoolean(Object o, long offset);
public native void    putBoolean(Object o, long offset, boolean x);
public native byte    getByte(Object o, long offset);
public native void    putByte(Object o, long offset, byte x);
public native short   getShort(Object o, long offset);
public native void    putShort(Object o, long offset, short x);
public native char    getChar(Object o, long offset);
public native void    putChar(Object o, long offset, char x);
public native long    getLong(Object o, long offset);
public native void    putLong(Object o, long offset, long x);
public native float   getFloat(Object o, long offset);
public native void    putFloat(Object o, long offset, float x);
public native double  getDouble(Object o, long offset);
public native void    putDouble(Object o, long offset, double x);

// 获取obj对象中offset地址对应的object型field的值为指定值。
// getObject(Object, long)的volatile版
public native Object getObjectVolatile(Object o, long offset);
// 设置obj对象中offset偏移地址对应的object型field的值为指定值。
// putObject(Object, long, Object)的volatile版
public native void    putObjectVolatile(Object o, long offset, Object x);
public native int     getIntVolatile(Object o, long offset);
public native void    putIntVolatile(Object o, long offset, int x);
public native boolean getBooleanVolatile(Object o, long offset);
public native void    putBooleanVolatile(Object o, long offset, boolean x);
public native byte    getByteVolatile(Object o, long offset);
public native void    putByteVolatile(Object o, long offset, byte x);
public native short   getShortVolatile(Object o, long offset);
public native void    putShortVolatile(Object o, long offset, short x);
public native char    getCharVolatile(Object o, long offset);
public native void    putCharVolatile(Object o, long offset, char x);
public native long    getLongVolatile(Object o, long offset);
public native void    putLongVolatile(Object o, long offset, long x);
public native float   getFloatVolatile(Object o, long offset);
public native void    putFloatVolatile(Object o, long offset, float x);
public native double  getDoubleVolatile(Object o, long offset);
public native void    putDoubleVolatile(Object o, long offset, double x);

// 设置obj对象中offset偏移地址对应的object型field的值为指定值。这是一个有序或者 
// 有延迟的&amp;lt;code&amp;gt;putObjectVolatile&amp;lt;/cdoe&amp;gt;方法，并且不保证值的改变被其他线程立 
// 即看到。只有在field被&amp;lt;code&amp;gt;volatile&amp;lt;/code&amp;gt;修饰并且期望被意外修改的时候 
// 使用才有用。 
// 这个方法在对低延迟代码是很有用的，它能够实现非堵塞的写入，这些写入不会被Java的JIT重新排序指令
// (instruction reordering)，这样它使用快速的存储-存储(store-store) barrier, 而不是较慢
// 的存储-加载(store-load) barrier, 后者总是用在volatile的写操作上，这种性能提升是有代价的，
// 虽然便宜，也就是写后结果并不会被其他线程看到，甚至是自己的线程，通常是几纳秒后被其他线程看到，
// 这个时间比较短，所以代价可以忍受。类似Unsafe.putOrderedObject还有unsafe.putOrderedLong
// 等方法，unsafe.putOrderedLong比使用 volatile long要快3倍左右。.
public native void    putOrderedObject(Object o, long offset, Object x);
public native void    putOrderedInt(Object o, long offset, int x);
public native void    putOrderedLong(Object o, long offset, long x);
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;获取内存指针地址&#34;&gt;获取内存指针地址&lt;/h4&gt;

&lt;p&gt;&lt;code&gt;objectFieldOffset&lt;/code&gt;获取到的是内存偏移量，并不是真正的内存指针地址，Unsafe类提供了&lt;code&gt;getAddress&lt;/code&gt;函数将该偏移量转换为真正的内存指针地址，有了该内存指针地址，就可以直接操作内存数据的读写了。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;// 根据给定的内存偏移量(objectFieldOffset的返回值)，获取真正的内存指针地址。
// 如果给定的内存偏移量为0或者并没有指向一个内存块，返回undefined。
// 如果返回的内存指针地址位宽小于64，用无符号整数进行扩展转换为Java long型。
public native long getAddress(long var1);
// 保存一个内存指针地址到给定的内存偏移量。
// 如过给定的内存偏移量为0或者并没有指向一个内存块，返回undefined。
public native void putAddress(long var1, long var3);

// 返回一个内存指针占用的字节数(bytes)
public native int addressSize();
// 返回一个内存页占用的字节数(bytes)
public native int pageSize();

&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;直接分配内存空间&#34;&gt;直接分配内存空间&lt;/h4&gt;

&lt;p&gt;&lt;code&gt;sun.mics.Unsafe&lt;/code&gt;类允许Java程序使用JVM堆外内存，即操作系统内存。&lt;code&gt;BufferBytes&lt;/code&gt;类也可以分配JVM堆外内存，但是只能使用最大2GB的JVM堆外内存空间，而&lt;code&gt;sun.mics.Unsafe&lt;/code&gt;类没有这个限制。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;// 分配一块大小为var1字节的JVM堆外内存。
// 新分配的内存空间中的内容处于未初始化状态。
// 新分配的内存空间的指针地址不为0，并对所有的值类型做内存对齐。
public native long allocateMemory(long var1);
// 调整JVM堆外内存空间大小。
// 参数var1是待调整的JVM堆外内存空间的指针地址。
// 参数var3是新的JVM堆外内存空间字节大小。
// 如果新空间大小var1=0，则返回指针地址为0.
public native long reallocateMemory(long var1, long var3);
// 释放指定内存指针地址的内存空间。
public native void freeMemory(long var1);
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;直接操作内存类型数据&#34;&gt;直接操作内存类型数据&lt;/h4&gt;

&lt;p&gt;有了&lt;code&gt;addAddress&lt;/code&gt;函数获取到的内存指针地址，就可以直接操作该内存指针地址处的数据了。Unsafe类提供了对所有Java基础数据类型和对象类型的直接内存操作函数。&lt;/p&gt;

&lt;p&gt;下面提供的这些函数，都是按照数据类型对内存数据进行读写。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;// var1: 内存指针地址
public native byte getByte(long var1);
// var1: 内存指针地址
// var3: 新的数据值
public native void putByte(long var1, byte var3);
public native short getShort(long var1);
public native void putShort(long var1, short var3);
public native char getChar(long var1);
public native void putChar(long var1, char var3);
public native int getInt(long var1);
public native void putInt(long var1, int var3);
public native long getLong(long var1);
public native void putLong(long var1, long var3);
public native float getFloat(long var1);
public native void putFloat(long var1, float var3);
public native double getDouble(long var1);
public native void putDouble(long var1, double var3);
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;直接操作内存字节数据&#34;&gt;直接操作内存字节数据&lt;/h4&gt;

&lt;p&gt;有了&lt;code&gt;addAddress&lt;/code&gt;函数获取到的内存指针地址，就可以直接操作该内存指针地址处的数据了。Unsafe类提供了直接按照字节为单位对指定的内存指针地址进行数据操作的函数。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public native void setMemory(Object o, long offset, long bytes, byte value);
public void setMemory(long address, long bytes, byte value) {
  	setMemory(null, address, bytes, value);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;直接复制内存数据&#34;&gt;直接复制内存数据&lt;/h4&gt;

&lt;p&gt;有了&lt;code&gt;addAddress&lt;/code&gt;函数获取到的内存指针地址，还可以直接将一个内存指针地址对应的数据块拷贝到另一个内存指针地址对应的位置。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public native void copyMemory(Object srcBase, long srcOffset,
                              Object destBase, long destOffset,
                              long bytes);
public void copyMemory(long srcAddress, long destAddress, long bytes) {
  	copyMemory(null, srcAddress, null, destAddress, bytes);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;数组操作&#34;&gt;数组操作&lt;/h3&gt;

&lt;p&gt;Unsafe类中有很多以BASE_OFFSET结尾的常量，比如ARRAY_INT_BASE_OFFSET，ARRAY_BYTE_BASE_OFFSET等，这些常量值是通过arrayBaseOffset方法得到的。arrayBaseOffset方法是一个本地方法，可以获取数组第一个元素的偏移地址。&lt;/p&gt;

&lt;p&gt;Unsafe类中还有很多以INDEX_SCALE结尾的常量，比如 ARRAY_INT_INDEX_SCALE ， ARRAY_BYTE_INDEX_SCALE等，这些常量值是通过arrayIndexScale方法得到的。arrayIndexScale方法也是一个本地方法，可以获取数组的转换因子，也就是数组中元素的增量地址。&lt;/p&gt;

&lt;p&gt;将arrayBaseOffset与arrayIndexScale配合使用，可以定位数组中每个元素在内存中的位置。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;// 返回给定数组的第一个元素的内存偏移量
public native int arrayBaseOffset(Class arrayClass);
// 返回给定数组的转换因子，也就是数组中元素的增量地址
public native int arrayIndexScale(Class arrayClass);
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;原子操作&#34;&gt;原子操作&lt;/h3&gt;

&lt;p&gt;&lt;code&gt;sun.misc.Unsafe&lt;/code&gt;类提供了CAS原子操作，能够实现高性能的线程安全的无锁数据结构。&lt;code&gt;sun.misc.Unsafe&lt;/code&gt;类的CAS操作是&lt;code&gt;java.util.concurrent&lt;/code&gt;包的基础，&lt;code&gt;LockSupport&lt;/code&gt;，&lt;code&gt;AbstractQueuedSynchronized&lt;/code&gt;，&lt;code&gt;AtomicInteger&lt;/code&gt;等原子变量和锁框架都基于CAS操作实现的。&lt;/p&gt;

&lt;p&gt;由于CAS操作在执行时当前线程不会被阻塞，所以通常使用自旋锁循环执行，直到操作成功时，表示获取到锁。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;// 当Java对象o的域偏移offset上的值为excepted时，原子地修改为x。
// 如果修改成功，返回true。否则，返回false。
// 操作过程中线程不会阻塞。
public final native boolean compareAndSwapObject(Object o, long offset,
                                                 Object expected,
                                                 Object x);
// 当Java对象o的域偏移offset上的值为int型的excepted时，原子地修改为x。
// 如果修改成功，返回true。否则，返回false。
// 操作过程中线程不会阻塞。
public final native boolean compareAndSwapInt(Object o, long offset,
                                              int expected,
                                              int x);
// 当Java对象o的域偏移offset上的值为int型的excepted时，原子地修改为x。
// 如果修改成功，返回true。否则，返回false。
// 操作过程中线程不会阻塞。
public final native boolean compareAndSwapLong(Object o, long offset,
                                               long expected,
                                               long x);
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;监视器锁&#34;&gt;监视器锁&lt;/h3&gt;

&lt;p&gt;&lt;code&gt;synchronized&lt;/code&gt;是JVM最早提供的锁，称为监视器锁，也称对象锁。获得锁的过程称为monitorEnter，释放锁的过程称为monitorExit，锁的信息保存在对象头里，同步语句会在编译成字节码后转换成监视器语法(monitorEnter和monitorExit)。&lt;code&gt;sun.misc.Unsafe&lt;/code&gt;类提供了监视器的相关操作。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;// 锁住对象
public native void monitorEnter(Object o);
// 尝试锁住对象
public native boolean tryMonitorEnter(Object o);
// 解锁对象
public native void monitorExit(Object o);
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;线程控制&#34;&gt;线程控制&lt;/h3&gt;

&lt;p&gt;在实现&lt;code&gt;java.util.concurrent.AbstractQueued&lt;/code&gt;类，并基于AQS实现整个JUC锁框架的过程中，一方面需要使用&lt;code&gt;sun.misc.Unsafe&lt;/code&gt;类的CAS操作进行锁的获取(标记位state的修改)，另一方在获取锁失败时要把当前线程放入等待队列，并阻塞当前线程。阻塞当前的线程的方法也是&lt;code&gt;sun.misc.Unsafe&lt;/code&gt;类提供的。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;// 阻塞当前线程。
// 直到通过unpark方法解除阻塞，或者线程被中断，或者指定的超时时间到期
// isAbsolute参数是指明时间是绝对的，还是相对的
// time单位是纳秒，如果为0则表示长期阻塞
public native void park(boolean isAbsolute, long time);
// 解除指定线程的阻塞状态。
public native void unpark(Object thread);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;park方法的两个参数里并没有指定要阻塞的线程引用，JVM怎么知道要将哪个线程阻塞？而unpark方法又是如何将一个线程的阻塞状态解除的呢？要真正理解park和unpark的工作原理，需要深入到HotSpot的源码。&lt;/p&gt;

&lt;p&gt;简单的讲，park和unpark本质上是通过HotSpot里的一个volatile共享变量(volatile int _counter)来通信的，当park时，这个变量设置为0，当unpark时，这个变量设置为1。&lt;/p&gt;

&lt;p&gt;由此，我们发现使用park和unpark来对线程进行同步控制非常灵活，unpark甚至可以在park之前调用。park/unpark模型真正实现了线程之间的同步，Java线程之间不再需要一个Object(synchronized代表的对象锁，用对象头存储锁信息)或者其他变量来存储状态(AQS中的state变量)来存储状态，不再需要关心对方的状态。&lt;/p&gt;

&lt;p&gt;对比Java5中提供的wait/notify/notifyAll同步体系。wait/notify机制有个很蛋疼的地方是，比如线程B要用notify通知线程A，那么线程B要确保线程A已经在wait调用上等待了，否则线程A可能永远都在等待。编程的时候就会很蛋疼。&lt;/p&gt;

&lt;p&gt;unpark函数为线程提供“许可(permit)”，线程调用park函数则等待“许可”。这个有点像信号量，但是这个“许可”是不能叠加的，“许可”是一次性的。&lt;/p&gt;

&lt;p&gt;比如线程B连续调用了三次unpark函数，当线程A调用park函数就使用掉这个“许可”，如果线程A再次调用park，则进入等待状态。&lt;/p&gt;

&lt;p&gt;在HotSpot的实现里，每个Java线程都有一个Parker实例，Parker类的定义如下：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;class Parker : public os::PlatformParker {  
private:  
  volatile int _counter ;  
  ...  
public:  
  void park(bool isAbsolute, jlong time);  
  void unpark();  
  ...  
}  
class PlatformParker : public CHeapObj&amp;lt;mtInternal&amp;gt; {  
  protected:  
    pthread_mutex_t _mutex [1] ;  
    pthread_cond_t  _cond  [1] ;  
    ...  
}  
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;异常处理&#34;&gt;异常处理&lt;/h3&gt;

&lt;p&gt;&lt;code&gt;sun.misc.Unsafe&lt;/code&gt;类还提供了抛出异常的能力。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;// 在不通知验证器(verifier)的情况下，抛出异常。
public native void throwException(Throwable ee);
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;对象增强&#34;&gt;对象增强&lt;/h3&gt;

&lt;p&gt;&lt;code&gt;sun.misc.Unsafe&lt;/code&gt;类还提供了一些对类和对象进行操作的函数。通过这些函数，用户可以在绕过虚拟机的情况下进行类的加载、初始化，或者对对象进行实例化。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;// 让虚拟机在不进行安全检查的情况下定义一个类。
// 默认情况下，该类的类加载器和保护域来自调用类。
public native Class defineClass(String name, byte[] b, int off, int len,
                                ClassLoader loader,
                                ProtectionDomain protectionDomain);
public native Class defineClass(String name, byte[] b, int off, int len);

// 在不调用构造函数的情况下，实例化类Class的一个对象
// 如果累Class还没有加载到JVM，则进行加载
public native Object allocateInstance(Class cls)
        throws InstantiationException;

// 定义一个匿名类，该类将不被classloader，或系统目录感知
public native Class defineAnonymousClass(Class hostClass, byte[] data, Object[] cpPatches);

// 确保指定的类已经被初始化(加载到JVM)
public native void ensureClassInitialized(Class c);
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;实例分析&#34;&gt;实例分析&lt;/h2&gt;

&lt;p&gt;本节记录了一些使用&lt;code&gt;sun.misc.Unsafe&lt;/code&gt;的实例，并对这些实例进行分析。&lt;/p&gt;

&lt;h3 id=&#34;实例化私有类&#34;&gt;实例化私有类&lt;/h3&gt;

&lt;p&gt;很多类为了封装的需要将构造函数声明成私有的，防止被实例化。在&lt;code&gt;sun.misc.Unsafe&lt;/code&gt;类面前，这中做法不堪一击。&lt;code&gt;allocateInstance&lt;/code&gt;方法可以在不调用构造函数的情况下，直接实例化类的一个对象。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;import sun.misc.Unsafe;

import java.lang.reflect.Field;

public class UnsafeUser {
    public static void main(String[] args) throws Exception {
        // 由于安全限制，只有系统class loader才能使用getUnsafe()方法
        // 普通用户只能通过反射实例化Unsafe
        Field field = Unsafe.class.getDeclaredField(&amp;quot;theUnsafe&amp;quot;);
        field.setAccessible(true);
        Unsafe unsafe = (Unsafe) field.get(null);

        // 实例化User，不调用构造函数
        User user = (User) unsafe.allocateInstance(User.class);
        user.setName(&amp;quot;liang&amp;quot;);
        System.out.println(user.getName());
    }
}

class User {
    private String name;
    private User() {}
    public String getName() { return name; }
    public void setName(String name) { this.name = name; }
}

// 执行后输出
liang
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;操作对象内存&#34;&gt;操作对象内存&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;import sun.misc.Unsafe;

import java.lang.reflect.Field;

public class UnsafeUser {

    public static void main(String[] args) throws Exception {
        // 由于安全限制，只有系统classloader才能使用getUnsafe()方法
        // 普通用户只能通过反射实例化Unsafe
        Field field = Unsafe.class.getDeclaredField(&amp;quot;theUnsafe&amp;quot;);
        field.setAccessible(true);
        Unsafe unsafe = (Unsafe) field.get(null);

        // 实例化User，不调用构造函数
        User user = (User) unsafe.allocateInstance(User.class);
        user.setName(&amp;quot;liang&amp;quot;);
        user.setAge(28);

        // 输出user对象中各个成员遍历的内存偏移值
        for (Field f : user.getClass().getDeclaredFields()) {
            System.out.println(f.getName() + &amp;quot; 对应的内存偏移地址: &amp;quot; + unsafe.objectFieldOffset(f));
        }

        System.out.println(&amp;quot;---------------------&amp;quot;);

      	// 获取age内存偏移量
        long ageOffset = 
          unsafe.objectFieldOffset(user.getClass().getDeclaredField(&amp;quot;age&amp;quot;));
       	// // 获取name内存偏移量
        long nameOffset = 
          unsafe.objectFieldOffset(user.getClass().getDeclaredField(&amp;quot;name&amp;quot;));

        // 修改age值
        unsafe.putInt(user, ageOffset, 29);
        // 修改name值
        unsafe.putObject(user, nameOffset, &amp;quot;zhang liang&amp;quot;);

        System.out.println(&amp;quot;age: &amp;quot; + user.getAge());
        System.out.println(&amp;quot;name: &amp;quot; + user.getName());
    }
}

class User {
    private int age;
    private String name;
    private User() {}
    public String getName() { return name; }
    public void setName(String name) { this.name = name; }
    public int getAge() { return age; }
    public void setAge(int age) { this.age = age; }
}

// 执行后输出：
age 对应的内存偏移地址: 12
name 对应的内存偏移地址: 16
---------------------
age: 29
name: zhang liang
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;创建超大数组&#34;&gt;创建超大数组&lt;/h3&gt;

&lt;p&gt;Java中数组的最大长度为Integer.MAX_VALUE，正常情况下如果想创建一个大于Integer.MAX_VALUE的数组是做不到的，但是Unsafe可以，通过对内存进行直接分配实现。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public class BigArray {
    public static void main(String[] arg) throws Exception {

        // 由于安全限制，只有系统classloader才能使用getUnsafe()方法
        // 普通用户只能通过反射实例化Unsafe
        Field field = Unsafe.class.getDeclaredField(&amp;quot;theUnsafe&amp;quot;);
        field.setAccessible(true);
        Unsafe unsafe = (Unsafe) field.get(null);

        //只要内存够大，可以把这个调大，大于Integer.MAX_VALUE
        long size = (long) Integer.MAX_VALUE * 2;
        long addr = unsafe.allocateMemory(size);
        System.out.println(&amp;quot;unsafe address :&amp;quot; + addr);

        for (int i = 0; i &amp;lt; size; i++) {
            unsafe.putByte(addr + i, (byte) 6);
            if (unsafe.getByte(addr + i) != 6) {
                System.out.println(&amp;quot;failed at offset&amp;quot;);
            }
        }
    }
}

// 运行结果
unsafe address :4754382848
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;线程挂起与恢复&#34;&gt;线程挂起与恢复&lt;/h3&gt;

&lt;p&gt;将一个线程进行挂起是通过park方法实现的，调用 park后，线程将一直阻塞直到超时或者中断等条件出现。unpark可以终止一个挂起的线程，使其恢复正常。&lt;/p&gt;

&lt;p&gt;整个并发框架中对线程的挂起操作被封装在 LockSupport类中，LockSupport类中有各种版本pack方法，但最终都调用了Unsafe.park()方法。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;import sun.misc.Unsafe;

import java.lang.reflect.Field;
import java.util.concurrent.TimeUnit;
import java.util.concurrent.locks.LockSupport;

public class Lock {
    public static void main(String[] args) throws Exception {

        // 由于安全限制，只有系统classloader才能使用getUnsafe()方法
        // 普通用户只能通过反射实例化Unsafe
        Field field = Unsafe.class.getDeclaredField(&amp;quot;theUnsafe&amp;quot;);
        field.setAccessible(true);
        Unsafe unsafe = (Unsafe) field.get(null);

        WaitThread waitThread = new WaitThread(unsafe);
        waitThread.start();
        WorkThread workThread = new WorkThread(unsafe, waitThread);
        workThread.start();

        workThread.join();

        System.out.println(&amp;quot;the end.&amp;quot;);
    }
}

/**
 * 工作线程
 */
class WorkThread extends Thread {
    private Thread waitThread;
    private Unsafe unsafe;

    public WorkThread(Unsafe unsafe, Thread waitThread) {
        this.waitThread = waitThread;
        this.unsafe = unsafe;
    }

    public void run() {
        int i = 0;
        while (true) {
            if (i == 5) {
                System.out.println(&amp;quot;WorkThread is now to wake WaitThread&amp;quot;);
                unsafe.unpark(waitThread);

                break;
            }

            System.out.println(&amp;quot;WorkThread is now working for &amp;quot; + (++i) + &amp;quot; s&amp;quot;);

            try {
                TimeUnit.SECONDS.sleep(1);
            } catch (Exception e) {
                e.printStackTrace();
            }
        }
    }
}

class WaitThread extends Thread {
    private Unsafe unsafe;

    public WaitThread(Unsafe unsafe) {
        this.unsafe = unsafe;
    }
  
    public void run() {
        System.out.println(&amp;quot;Wait Thread is now going to block!&amp;quot;);
        unsafe.park(false, 0);
        System.out.println(&amp;quot;WaitThread is now awake&amp;quot;);
    }
}

// 执行结果
Wait Thread is now going to block!
WorkThread is now working for 1 s
WorkThread is now working for 2 s
WorkThread is now working for 3 s
WorkThread is now working for 4 s
WorkThread is now working for 5 s
WorkThread is now to wake WaitThread
WaitThread is now awake
the end.
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;参考:&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;&lt;a href=&#34;http://hg.openjdk.java.net/jdk7/jdk7/jdk/file/9b8c96f96a0f/src/share/classes/sun/misc/Unsafe.java&#34;&gt;sun.misc.Unsafe基于JDK7的源码&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;a href=&#34;http://www.cnblogs.com/chenpi/p/5389254.html&#34;&gt;sun.misc.Unsafe的理解&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;a href=&#34;http://ifeve.com/sun-misc-unsafe/&#34;&gt;Java Magic. Part 4: sun.misc.Unsafe&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;a href=&#34;http://howtodoinjava.com/tag/java-hidden-features/&#34;&gt;java-hidden-features&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;a href=&#34;http://blog.csdn.net/fenglibing/article/details/17138079&#34;&gt;sun.misc.unsafe类的使用&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;a href=&#34;http://www.blogjava.net/xylz/archive/2010/07/04/325206.html&#34;&gt;深入浅出 Java Concurrency (5): 原子操作 part 4&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;a href=&#34;http://www.infoq.com/cn/articles/A-Post-Apocalyptic-sun.misc.Unsafe-World&#34;&gt;sun.misc.Unsafe的后启示录&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;a href=&#34;http://blog.csdn.net/aesop_wubo/article/details/7537278&#34;&gt;JAVA并发编程学习笔记之Unsafe类&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;a href=&#34;http://blog.csdn.net/dfdsggdgg/article/details/51538601&#34;&gt;sun.misc.Unsafe源码解析&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;a href=&#34;http://blog.csdn.net/dfdsggdgg/article/details/51543545&#34;&gt;sun.misc.Unsafe的各种神技&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;a href=&#34;http://blog.csdn.net/hengyunabc/article/details/28126139&#34;&gt;Java的LockSupport.park()实现分析&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;
</description>
    </item>
    
    <item>
      <title>定律</title>
      <link>http://nituchao.com/theorem/</link>
      <pubDate>Thu, 23 Feb 2017 18:39:27 +0800</pubDate>
      
      <guid>http://nituchao.com/theorem/</guid>
      <description>

&lt;h2 id=&#34;沃尔夫定律&#34;&gt;沃尔夫定律&lt;/h2&gt;

&lt;blockquote&gt;
&lt;p&gt;第一印象永不再来。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&#34;奥卡姆剃刀原理&#34;&gt;奥卡姆剃刀原理&lt;/h2&gt;

&lt;blockquote&gt;
&lt;p&gt;如无必要，勿增实体。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&#34;二八定律&#34;&gt;二八定律&lt;/h2&gt;

&lt;p&gt;二八定律，又叫帕累托定律，是19世纪末20世纪初意大利经济学家巴莱多发现的。他认为，&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;在任何一组东西中，最重要的只占其中一小部分，约20％，其余80％尽管是多数，却是次要的，因此又称二八定律。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&#34;墨菲定律&#34;&gt;墨菲定律&lt;/h2&gt;

&lt;blockquote&gt;
&lt;p&gt;如果事情有变坏的可能，不管这种可能性有多小，它总会发生。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&amp;ldquo;墨菲定律&amp;rdquo;是一种心理学效应，是由爱德华·墨菲（Edward A. Murphy）提出的。&lt;/p&gt;

&lt;p&gt;主要内容：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;任何事都没有表面看起来那么简单；&lt;/li&gt;
&lt;li&gt;所有的事都会比你预计的时间长；&lt;/li&gt;
&lt;li&gt;会出错的事总会出错；&lt;/li&gt;
&lt;li&gt;如果你担心某种情况发生，那么它就更有可能发生。&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;墨菲定律的原句是这样的：如果有两种或两种以上的方式去做某件事情，而其中一种选择方式将导致灾难，则必定有人会做出这种选择。&lt;/p&gt;

&lt;h2 id=&#34;沉没成本&#34;&gt;沉没成本&lt;/h2&gt;

&lt;blockquote&gt;
&lt;p&gt;决策时，要排除沉没成本的干扰。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;沉没成本是指由于过去的决策已经发生了的，而不能由现在或将来的任何决策改变的成本。人们在决定是否去做一件事情的时候，不仅是看这件事对自己有没有好处，而且也看过去是不是已经在这件事情上有过投入。我们把这些已经发生不可收回的支出，如时间、金钱、精力等称为“沉没成本”（Sunk Cost）。&lt;/p&gt;

&lt;p&gt;在经济学和商业决策制定过程中会用到“沉没成本”的概念，代指已经付出且不可收回的成本。沉没成本常用来和可变成本作比较，可变成本可以被改变，而沉没成本则不能被改变。&lt;/p&gt;

&lt;h2 id=&#34;彼得定律&#34;&gt;彼得定律&lt;/h2&gt;

&lt;p&gt;彼得原理（The Peter Principle）是劳伦斯·彼得根据千百个有关组织中不能胜任的失败实例的分析而归纳出来的。&lt;/p&gt;

&lt;p&gt;其具体内容是：&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;在一个等级制度中，每个职工趋向于上升到他所不能胜任的地位。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;彼得指出，每一个职工由于在原有职位上工作成绩表现好（胜任），就将被提升到更高一级职位；其后，如果继续胜任则将进一步被提升，直至到达他所不能胜任的职位。&lt;/p&gt;

&lt;p&gt;由此导出的彼得推论是：&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;每一个职位最终都将被一个不能胜任其工作的职工所占据。层级组织的工作任务多半是由尚未达到不胜任阶层的员工完成的。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;每一个职工最终都将达到彼得高地，在该处他的提升商数（PQ）为零。至于如何加速提升到这个高地，有两种方法。其一，是上面的“拉动”，即依靠裙带关系和熟人等从上面拉；其二，是自我的“推动”，即自我训练和进步等，而前者是被普遍采用的。&lt;/p&gt;

&lt;h2 id=&#34;彼得反转定律&#34;&gt;彼得反转定律&lt;/h2&gt;

&lt;blockquote&gt;
&lt;p&gt;一个员工的胜任与否，是由层级组织中的上司判定，而不是外界人士。如果上司已到达不胜任的阶层，他或许会以制度的价值来评判部属。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;例如，他会注重员工是否遵守规范、仪式、表格之类的事；他将特别赞赏工作迅速、整洁有礼的员工。总之，类似上司是以输入（input）评断部属。于是对于那些把手段和目的的关系弄反了，方法重于目标、文书作业重于预定的目的、缺乏独立判断的自主权、只是服从而不作决定的职业性机械行为者而言，他们会被组织认为是能胜任的工作者，因此有资格获得晋升，一直升到必须作决策的职务时，组织才会发现他们已到达不胜任的阶层。而以顾客、客户或受害者的观点来看，他们本来就是不胜任的。&lt;/p&gt;

&lt;h2 id=&#34;帕金森定律&#34;&gt;帕金森定律&lt;/h2&gt;

&lt;p&gt;1958年，英国历史学家、政治学家西里尔·诺斯古德·帕金森通过长期调查研究，出版了《帕金森定律》一书。帕金森经过多年调查研究，发现一个人做一件事所耗费的时间差别如此之大：他可以在10分钟内看完一份报纸，也可以看半天；一个忙人20分钟可以寄出一叠明信片，但一个无所事事的老太太为了给远方的外甥女寄张明信片，可以足足花一整天：找明信片一个钟头，寻眼镜一个钟头，查地址半个钟头，写问候的话一个钟头零一刻钟……特别是在工作中，工作会自动地膨胀，占满一个人所有可用的时间，如果时间充裕，他就会放慢工作节奏或是增添其他项目以便用掉所有的时间。&lt;/p&gt;

&lt;p&gt;由此得出结论：在行政管理中，行政机构会像金字塔一样不断增多，行政人员会不断膨胀，每个人都很忙，但组织效率越来越低下。这条定律又被称为“金字塔上升”现象。&lt;/p&gt;

&lt;p&gt;他在书中阐述了机构人员膨胀的原因及后果：&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;一个不称职的官员，可能有三条出路。第一是申请退职，把位子让给能干的人；第二是让一位能干的人来协助自己工作；第三是任用两个水平比自己更低的人当助手。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;这第一条路是万万走不得的，因为那样会丧失许多权力；第二条路也不能走，因为那个能干的人会成为自己的对手；看来只有第三条路最适宜。于是，两个平庸的助手分担了他的工作，他自己则高高在上发号施令。两个助手既无能，也就上行下效，再为自己找两个无能的助手。如此类推，就形成了一个机构臃肿、人浮于事、相互扯皮、效率低下的领导体系。&lt;/p&gt;

&lt;p&gt;至上而下，一级比一级庸人多，最终产生出机构臃肿的庞大管理机构。由于对于一个组织而言，管理人员或多或少是注定要增长的。&lt;/p&gt;

&lt;h2 id=&#34;蘑菇定律&#34;&gt;蘑菇定律&lt;/h2&gt;

&lt;p&gt;“蘑菇管理定律”指的是组织或个人对待新进者的一种管理心态。因初学者常被置于阴暗的角落,不受部门的重视，只做一些打杂跑腿的工作，有时还会被浇上一头大粪，受到无端的批评、指责、代人受过;组织或直属领导任其自生自灭;初学者得不到必要的指导和提携，这种情况与蘑菇的生长情景极为相似。一般在管理机构比较正式的大企业和公司里，这种情况比较多。管理者要提早认识到这种现象并加以预防利用，才能做到事半功倍的管理效果!&lt;/p&gt;

&lt;p&gt;据称，蘑菇管理定律一词来源于20世纪70年代一批年轻的电脑程序员的创意。由于当时许多人不理解他们的工作，持怀疑和轻视的态度，所以年轻的电脑程序员就经常自嘲“像蘑菇一样的生活”。电脑程序员之所以如此自嘲，这与蘑菇的生存空间有一定的关系。&lt;/p&gt;

&lt;p&gt;蘑菇的生长特性是需要养料和水分，但同时也要注意避免阳光的直接照射，一般需在阴暗角落里培育，过分的曝光会导致过早夭折。古时，蘑菇的养料一般为人、兽的排泄物，虽不洁但为必需品。&lt;/p&gt;

&lt;p&gt;从两者的关系来看，地点、养料两方面的条件给予了蘑菇的生存空间，但须为自生自灭，新进学者亦是如此。&lt;/p&gt;

&lt;h2 id=&#34;弗兰克定律&#34;&gt;弗兰克定律&lt;/h2&gt;

&lt;blockquote&gt;
&lt;p&gt;没有必要做出决定时就有必要不做决定。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&#34;露西定律&#34;&gt;露西定律&lt;/h2&gt;

&lt;blockquote&gt;
&lt;p&gt;衰老的根源是忧伤。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&#34;卡德宁定律&#34;&gt;卡德宁定律&lt;/h2&gt;

&lt;blockquote&gt;
&lt;p&gt;你得到最多的东西是你最不需要的东西。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&#34;科安定律&#34;&gt;科安定律&lt;/h2&gt;

&lt;blockquote&gt;
&lt;p&gt;如果事情看起来很复杂，就会让人失去兴趣。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&#34;拉瑟福德定律&#34;&gt;拉瑟福德定律&lt;/h2&gt;

&lt;blockquote&gt;
&lt;p&gt;越是不知道怎么去做的事情，就越没必要去做。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&#34;鲁尼恩定律&#34;&gt;鲁尼恩定律&lt;/h2&gt;

&lt;blockquote&gt;
&lt;p&gt;赛跑时不一定快的赢，打架时不一定弱的输。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&#34;马歇尔广义冰山定律&#34;&gt;马歇尔广义冰山定律&lt;/h2&gt;

&lt;blockquote&gt;
&lt;p&gt;任何事物只能了解到它的八分之一。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&#34;破窗理论&#34;&gt;破窗理论&lt;/h2&gt;

&lt;blockquote&gt;
&lt;p&gt;如果有一个人打破了玻璃而没有修补的话。别人可能看到后被纵容打破更多的玻璃。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;久而久之这些『破窗』就会给社会造成无序感，而在社会中就会导致犯罪的滋生和蔓延。所以不要千里之堤毁于蚁穴！&lt;/p&gt;

&lt;h2 id=&#34;木桶定律&#34;&gt;木桶定律&lt;/h2&gt;

&lt;blockquote&gt;
&lt;p&gt;就是说一个木桶能盛的水由最短的那个板子决定。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;所以劣势影响优势，劣势决定生死，如果一个人在工作中是那个『末位』的话。不好意思，末位必将被淘汰。&lt;/p&gt;

&lt;h2 id=&#34;路径依赖&#34;&gt;路径依赖&lt;/h2&gt;

&lt;blockquote&gt;
&lt;p&gt;可以理解为『惯性』，一个人选择一条路后就会产生依赖，一直走下去，并在这条路上不断发展。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;好的路径会对自己和自己所在的单位有利，利用『惯性』一飞冲天。坏的路径也会形成负反馈，恶性循环。&lt;/p&gt;

&lt;h2 id=&#34;马太效应&#34;&gt;马太效应&lt;/h2&gt;

&lt;blockquote&gt;
&lt;p&gt;『凡是少的，就连他所有的也要夺回来』
『凡是多的，还要给他叫他多多益善』&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;这就是马太效应。穷人越来越穷，富人越来越富就是这个道理。&lt;/p&gt;

&lt;h2 id=&#34;约克基定律&#34;&gt;约克基定律&lt;/h2&gt;

&lt;blockquote&gt;
&lt;p&gt;知识最少的人发言最多。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&#34;手表定律&#34;&gt;手表定律&lt;/h2&gt;

&lt;blockquote&gt;
&lt;p&gt;一个人如果有一个手表他知道是几点，可当他同时拥有两个手表时他就不能确定具体时间了。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&#34;爱因斯坦工作三定律&#34;&gt;爱因斯坦工作三定律&lt;/h2&gt;

&lt;blockquote&gt;
&lt;p&gt;从杂乱中发现简单。&lt;/p&gt;

&lt;p&gt;从混乱中制造和谐。&lt;/p&gt;

&lt;p&gt;在困境中寻求机会。&lt;/p&gt;
&lt;/blockquote&gt;
</description>
    </item>
    
    <item>
      <title>AtomicLong源码分析</title>
      <link>http://nituchao.com/post/juc.atomic/atomic-long/</link>
      <pubDate>Thu, 23 Feb 2017 18:30:28 +0800</pubDate>
      
      <guid>http://nituchao.com/post/juc.atomic/atomic-long/</guid>
      <description>

&lt;h2 id=&#34;概述&#34;&gt;概述&lt;/h2&gt;

&lt;p&gt;在原子变量相关类中，AtomicBoolean, AtomicInteger, AtomicLong三个类是对于基本数据类型的操作，其原理和用法类似，区别在于Boolean, Integer, Long分别是8位，32位，64位的类型，本文重点研究AtomicLong。&lt;/p&gt;

&lt;p&gt;Boolean类型数据长度为8位，Integer类型数据是32位，在当前32位操作系统或者64位操作中都能够直接对其进行原子修改和读取。而Long类型数据是64位，在32位JVM上会当做两个分离的32位来进行操作，所以本身不具备原子性。&lt;/p&gt;

&lt;p&gt;还好我们现在的JDK基本都已经更新到64位，对long型数据的直接修改不存在原子性问题，但是当出现运算操作(比如++, —等)时还是会出现性问题，AtomicLong的目的是实现Long类型数据的各种原子操作。&lt;/p&gt;

&lt;p&gt;Java原子变量的实现依赖于&lt;code&gt;sun.misc.Unsafe&lt;/code&gt;的CAS操作和volatile的内存可见性语义。&lt;/p&gt;

&lt;p&gt;本文基于JDK1.7.0_67&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;java version &amp;ldquo;1.7.0&lt;em&gt;67&amp;rdquo;&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;_Java&amp;trade; SE Runtime Environment (build 1.7.0_67-b01)&lt;/p&gt;

&lt;p&gt;Java HotSpot&amp;trade; 64-Bit Server VM (build 24.65-b04, mixed mode)&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&#34;成员变量&#34;&gt;成员变量&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;// 成员变量unsafe是原子变量相关操作的基础
// 原子变量的修改操作最终有sun.misc.Unsafe类的CAS操作实现
private static final Unsafe unsafe = Unsafe.getUnsafe();
// 成员变量value的内存偏移值，在静态代码块中初始化
private static final long valueOffset;
// 通过volatile关键字保证可见性，用于保存值
private volatile long value;

// 记录当前虚拟机是否支持long的原子化操作，如果支持，可以使用CAS进行更新
// 这个问题主要是针对32位JVM对long的更新
static final boolean VM_SUPPORTS_LONG_CAS = VMSupportsCS8();

static {
  try {
    valueOffset = unsafe.objectFieldOffset
      	(AtomicLong.class.getDeclaredField(&amp;quot;value&amp;quot;));
  } catch (Exception ex) { throw new Error(ex); }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;函数列表&#34;&gt;函数列表&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;// 构造函数，初始化值为0
public AtomicLong()
// 构造函数，指定初始化值
public AtomicLong(long initialValue)
// 以原子方式获取当前值
public final long get()
// 以原子方式设置当前值为newValue
// 赋值语句是单操作，所以本身具有原子性
public final void set(long newValue)
// 最后设置为给定值。延时设置变量值，这个等价于set()方法，
// 但是由于字段是volatile类型的，因此此字段的修改会比普通字段
//（非volatile字段）有稍微的时间延时（尽管可以忽略），所以如果
// 不是想立即读取设置的新值，允许在“后台”修改值，那么此方法就很
// 有用。如果还是难以理解，这里就类似于启动一个后台线程如执行修
// 改新值的任务，原线程就不等待修改结果立即返回。
public final void lazySet(long newValue)
// 以原子方式设置当前值为newValue，并返回旧值
public final long getAndSet(long newValue)
// 以原子方式设置当前值为update。
// 如果当前值等于expect，并设置成功，返回true
// 如果当前值不等于expect，则设置失败，返回false
// 该过程不阻塞
public final boolean compareAndSet(long expect, long update)
// 以原子方式设置当前值为update。
// 如果当前值等于expect，并设置成功，返回true
// 如果当前值不等于expect，则设置失败，返回false
// 该过程不阻塞
// 该过程不保证volatile成员的happens-before语义顺序
public final boolean weakCompareAndSet(long expect, long update)
// 以原子的方式将当前值加1
// 该过程以自旋锁的形似循环执行，直到操作成功
// 该过程不会阻塞
// 返回更新前的值
public final long getAndIncrement()
// 以原子的方式将当前值减1
// 该过程以自旋的形式循环执行，直到操作成功
// 该过程不会阻塞
// 返回更新前的值
public final long getAndDecrement()
// 以原子方式将原值加上给定的delta
// 该过程以自旋的形式循环执行，直到操作成功
// 该过程不会阻塞
// 返回更新前的值
public final long getAndAdd(long delta)
// 以原子方式将原值加1
// 该过程以自旋的形式循环执行，直到操作成功
// 该过程不会阻塞
// 返回更新后的值
public final long incrementAndGet()
// 以原子方式将原值减1
// 该过程以自旋的形式循环执行，直到操作成功
// 该过程不会阻塞
// 返回更新后的值
public final long decrementAndGet()
// 以原子方式将原值加上给定的delta
// 该过程以自旋的形式循环执行，直到操作成功
// 该过程不会阻塞
// 返回更新后的值
public final long addAndGet(long delta)
// 将当前值使用Long的静态方法转换成String类型，并返回
public String toString()
// 将当前值使用强制类型转换成int类型，并返回
public int intValue()
// 直接返回当前值
public long longValue()
// 将当前值使用强制类型转换成float类型，并返回
public float floatValue()
// 将当前值使用强制类型转换成double类型，并返回
public double doubleValue()
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;重点函数分析&#34;&gt;重点函数分析&lt;/h2&gt;

&lt;h3 id=&#34;set&#34;&gt;set&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public final void set(long newValue) {
	value = newValue;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;以原子方式设置当前值为newValue，因为set方法只是一个单操作的赋值语句，因此是原子的。加上volatile的内存可见性保证，Set是原子操作无疑。&lt;/p&gt;

&lt;h3 id=&#34;lazyset&#34;&gt;lazySet&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public final void lazySet(long newValue) {
  	unsafe.putOrderedLong(this, valueOffset, newValue);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;简单点说，lazySet优先保证数据的修改操作，而降低对可见性的要求。&lt;/p&gt;

&lt;p&gt;lazySet是使用Unsafe.putOrderedObject方法，这个方法在对低延迟代码是很有用的，它能够实现非堵塞的写入，这些写入不会被Java的JIT重新排序指令(&lt;a href=&#34;http://stackoverflow.com/questions/14321212/java-instruction-reordering-cache-in-threads&#34;&gt;instruction reordering&lt;/a&gt;)，这样它使用快速的存储-存储(store-store) barrier, 而不是较慢的存储-加载(store-load) barrier, 后者总是用在volatile的写操作上，这种性能提升是有代价的，虽然便宜，也就是写后结果并不会被其他线程看到，甚至是自己的线程，通常是几纳秒后被其他线程看到，这个时间比较短，所以代价可以忍受。&lt;/p&gt;

&lt;p&gt;类似Unsafe.putOrderedObject还有unsafe.putOrderedLong等方法，unsafe.putOrderedLong比使用 volatile long要快3倍左右。&lt;/p&gt;

&lt;h3 id=&#34;compareandset&#34;&gt;compareAndSet&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public final boolean compareAndSet(long expect, long update) {
	return unsafe.compareAndSwapLong(this, valueOffset, expect, update);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;以原子方式设置当前值为update。如果当前值等于expect，并设置成功，返回true。如果当前值不等于expect，则设置失败，返回false。该过程不阻塞。由于是使用了&lt;code&gt;sun.misc.Unsafe&lt;/code&gt;的CAS操作实现，它是原子操作无疑。&lt;/p&gt;

&lt;p&gt;_&lt;em&gt;set和compareAndSet都是原子操作，只是他们的目的不同，set只是单纯想设置一个新的值。而compareAndSet则是希望在满足一定条件的情况下(当前值等于except)再设置新的值。&lt;/em&gt;&lt;/p&gt;

&lt;h3 id=&#34;weakcompareandset&#34;&gt;weakCompareAndSet&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public final boolean weakCompareAndSet(long expect, long update) {
	return unsafe.compareAndSwapLong(this, valueOffset, expect, update);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;以原子方式设置当前值为update。它的实现与compareAndSet完全一致。JDK文档中说，weakCompareAndSet在更新变量时并不创建任何&lt;code&gt;happens-before&lt;/code&gt;顺序，因此即使要修改的值是volatile的，也不保证对该变量的读写操作的顺序（一般来讲，volatile的内存语义保证&lt;code&gt;happens-before&lt;/code&gt;顺序）。&lt;/p&gt;

&lt;p&gt;参考：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;&lt;a href=&#34;http://www.cnblogs.com/timlearn/p/4127616.html&#34;&gt;Java并发——原子变量和原子操作&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;a href=&#34;https://stackoverflow.com/questions/1468007/atomicinteger-lazyset-vs-set&#34;&gt;AtomicInteger lazySet vs set&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;a href=&#34;https://stackoverflow.com/questions/19238594/java-atomic-variable-set-vs-compareandset&#34;&gt;Java Atomic Variable set() vs compareAndSet()&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;
</description>
    </item>
    
    <item>
      <title>AtomicLongArray源码分析</title>
      <link>http://nituchao.com/post/juc.atomic/atomic-long-array/</link>
      <pubDate>Thu, 23 Feb 2017 18:30:27 +0800</pubDate>
      
      <guid>http://nituchao.com/post/juc.atomic/atomic-long-array/</guid>
      <description>

&lt;h2 id=&#34;概述&#34;&gt;概述&lt;/h2&gt;

&lt;p&gt;在原子变量相关类中，AtomicIntegerArray, AtomicLongArray, AtomicReferenceArray三个类是对数组类型的原子类操作，其原理和用法类似，本文重点研究AtomicLongArray。&lt;/p&gt;

&lt;p&gt;Java原子变量的实现依赖于&lt;code&gt;sun.misc.Unsafe&lt;/code&gt;的CAS操作和volatile的内存可见性语义。&lt;/p&gt;

&lt;p&gt;本文基于JDK1.7.0_67&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;java version &amp;ldquo;1.7.0&lt;em&gt;67&amp;rdquo;&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;_Java&amp;trade; SE Runtime Environment (build 1.7.0_67-b01)&lt;/p&gt;

&lt;p&gt;Java HotSpot&amp;trade; 64-Bit Server VM (build 24.65-b04, mixed mode)&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&#34;成员变量&#34;&gt;成员变量&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;// 成员变量unsafe是原子变量相关操作的基础
// 原子变量的修改操作最终有sun.misc.Unsafe类的CAS操作实现
private static final Unsafe unsafe = Unsafe.getUnsafe();
// arrayBaseOffset获取数组首个元素地址偏移
private static final int base = unsafe.arrayBaseOffset(long[].class);
// shift就是数组元素的偏移量
private static final int shift;
// 保存数据的数组，在构造函数中初始化
private final long[] array;

static {
  	// scale数组元素的增量偏移 
    int scale = unsafe.arrayIndexScale(long[].class);
  	// 用二进制&amp;amp;操作判断是否是2的倍数，很精彩
    // 对于int型数组，scale是4
  	// 对于lang型数组，scale是8
    // 对于Reference型数组，scale是4
    if ((scale &amp;amp; (scale - 1)) != 0)
          throw new Error(&amp;quot;data type scale not a power of two&amp;quot;);
    // 这里是处理long型的偏移量
    // 对于int型的偏移量，shift是2
    // 对于lang型的偏移量，shift是3
  	// 对于Reference型的偏移量，shift是2
    shift = 31 - Integer.numberOfLeadingZeros(scale);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;函数列表&#34;&gt;函数列表&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;// 构造函数，初始化一个长度为length的空数组
public AtomicLongArray(int length)
// 构造函数，通过拷贝给定数组的值进行初始化
// 通过构造函数中final域的内存语义，保证数据可见性
public AtomicLongArray(long[] array)
// 检查索引值是否越界，并计算数组中元素的地址
private long checkedByteOffset(int i)
// 计算数组中元素的地址，首地址偏移+每个元素的偏移
// 采用了移位操作
private static long byteOffset(int i)
// 返回数组长度
public final int length()
// 以原子方式获取数组元素
public final long get(int i)
// 以原子方式获取数组元素，私有函数
private long getRaw(long offset)
// 以原子方式设置数组指定位置为新的值newValue
public final void set(int i, long newValue)
// 以原子方式设置数组指定位置为新的值newValue
// 该函数优先保证对数据的更新，而不保证数据可见性
// 该函数的性能比set函数好很多
public final void lazySet(int i, long newValue)
// 以原子方式设置数组指定位置为新的值newValue
// 该过程会以自旋的形式循环执行，直到操作成功
// 该过程不会阻塞
// 返回更新前的值
public final long getAndSet(int i, long newValue)
// 以原子方式设置数组指定位置为新的值update
// 如果当前值等于expect，并设置成功，返回true
// 如果当前值不等于expect，则设置失败，返回false
// 该过程不阻塞
public final boolean compareAndSet(int i, long expect, long update)
// 以原子方式设置数组指定位置为新的值update
// 如果当前值等于expect，并设置成功，返回true
// 如果当前值不等于expect，则设置失败，返回false
// 该过程不阻塞
// 私有函数
private boolean compareAndSetRaw(long offset, long expect, long update)
// 以原子方式设置数组指定位置为新的值update
// 如果当前值等于expect，并设置成功，返回true
// 如果当前值不等于expect，则设置失败，返回false
// 该过程不阻塞
// 该过程不保证volatile成员的happens-before语义顺序
public final boolean weakCompareAndSet(int i, long expect, long update)
// 以原子方式设置数组指定位置为当前值加1
// 该过程不阻塞
// 返回更新前的值
public final long getAndIncrement(int i)
// 以原子方式设置数组指定位置为当前值减1
// 该过程不阻塞
// 返回更新前的值
public final long getAndDecrement(int i)
// 以原子方式设置数组指定位置为当前值+delta
// 该过程不阻塞
// 返回更新前的值
public final long getAndAdd(int i, long delta)
// 以原子方式设置数组指定位置为当前值加1
// 该过程不阻塞
// 返回更新前的值
public final long incrementAndGet(int i)
// 以原子方式设置数组指定位置为当前值减1
// 该过程不阻塞
// 返回更新前的值
public final long decrementAndGet(int i)
// 以原子方式设置数组指定位置为当前值+delta
// 该过程不阻塞
// 返回更新后的值
public long addAndGet(int i, long delta)
// 遍历数组中的每一个值，构造字符串
// 返回构造的字符串
public String toString()
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;重要函数分析&#34;&gt;重要函数分析&lt;/h2&gt;

&lt;h3 id=&#34;checkedbyoffset-int-i&#34;&gt;checkedByOffset(int i)&lt;/h3&gt;

&lt;p&gt;首先判断索引值&lt;code&gt;i&lt;/code&gt;是否越界，如果越界，则抛出越界异常。否则，调用byteOffset(int i)函数计算该索引值&lt;code&gt;i&lt;/code&gt;对应在数组中的内存偏移值，该偏移值被&lt;code&gt;sun.misc.Unsafe&lt;/code&gt;类的函数使用。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;private long checkedByteOffset(int i) {
    if (i &amp;lt; 0 || i &amp;gt;= array.length)
        throw new IndexOutOfBoundsException(&amp;quot;index &amp;quot; + i);

    return byteOffset(i);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;byteoffset-int-i&#34;&gt;byteOffset(int i)&lt;/h3&gt;

&lt;p&gt;根据索引值&lt;code&gt;i&lt;/code&gt;，计算数组中元素的地址，首地址偏移+每个元素的偏移&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;private static long byteOffset(int i) {
    return ((long) i &amp;lt;&amp;lt; shift) + base;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;lazyset-int-i-long-newvalue&#34;&gt;lazySet(int i, long newValue)&lt;/h3&gt;

&lt;p&gt;简单点说，lazySet优先保证数据的修改操作，而降低对可见性的要求。&lt;/p&gt;

&lt;p&gt;lazySet是使用Unsafe.putOrderedLong方法，这个方法在对低延迟代码是很有用的，它能够实现非堵塞的写入，这些写入不会被Java的JIT重新排序指令(&lt;a href=&#34;http://stackoverflow.com/questions/14321212/java-instruction-reordering-cache-in-threads&#34;&gt;instruction reordering&lt;/a&gt;)，这样它使用快速的存储-存储(store-store) barrier, 而不是较慢的存储-加载(store-load) barrier, 后者总是用在volatile的写操作上，这种性能提升是有代价的，虽然便宜，也就是写后结果并不会被其他线程看到，甚至是自己的线程，通常是几纳秒后被其他线程看到，这个时间比较短，所以代价可以忍受。&lt;/p&gt;

&lt;p&gt;类似Unsafe.putOrderedLong还有unsafe.putOrderedObject等方法，unsafe.putOrderedLong比使用 volatile long要快3倍左右。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;public final void lazySet(int i, long newValue) {
    unsafe.putOrderedLong(array, checkedByteOffset(i), newValue);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;getandset-int-i-long-newvalue&#34;&gt;getAndSet(int i, long newValue)&lt;/h3&gt;

&lt;p&gt;以原子方式设置数组指定位置为新的值newValue，该过程会以自旋的形式循环执行，直到操作成功。该过程不会阻塞。因为该函数包含两个操作(get和set)，因此需要使用自旋方式通过&lt;code&gt;sun.misc.Unsafe&lt;/code&gt;的CAS操作保证原子性。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;public final long getAndSet(int i, long newValue) {
    long offset = checkedByteOffset(i);
    while (true) {
        long current = getRaw(offset);
        if (compareAndSetRaw(offset, current, newValue))
            return current;
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;tostring&#34;&gt;toString()&lt;/h3&gt;

&lt;p&gt;通过遍历数组中元素来构造字符串，并返回。该函数是线程不安全的，在操作过程中内容可能会发生变化，使得AtomicLongArray具有若一致性。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;public String toString() {
    int iMax = array.length - 1;
    if (iMax == -1)
        return &amp;quot;[]&amp;quot;;

    StringBuilder b = new StringBuilder();
    b.append(&#39;[&#39;);
    for (int i = 0; ; i++) {
        b.append(getRaw(byteOffset(i)));
        if (i == iMax)
            return b.append(&#39;]&#39;).toString();
        b.append(&#39;,&#39;).append(&#39; &#39;);
    }
}
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>AtomicReference源码分析</title>
      <link>http://nituchao.com/post/juc.atomic/atomic-reference/</link>
      <pubDate>Thu, 23 Feb 2017 18:30:27 +0800</pubDate>
      
      <guid>http://nituchao.com/post/juc.atomic/atomic-reference/</guid>
      <description>

&lt;h2 id=&#34;概述&#34;&gt;概述&lt;/h2&gt;

&lt;p&gt;在原子变量相关类中，AtomicReference, AtomicStampedReference, AtomicMarkableReference三个类是对于引用类型的操作，其原理和用法类似。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;AtomicStampedReference&lt;/code&gt;是带了整型版本号(int stamp)的引用型原子变量，每次执行CAS操作时需要对比版本，如果版本满足要求，则操作成功，否则操作失败，用于防止CAS操作的ABA问题。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;AtomicMarkableReference&lt;/code&gt;则是带了布尔型标记位(Boolean mark)的引用型原子量，每次执行CAS操作是需要对比该标记位，如果标记满足要求，则操作成功，否则操作失败。&lt;/p&gt;

&lt;p&gt;Java原子变量的实现依赖于&lt;code&gt;sun.misc.Unsafe&lt;/code&gt;的CAS操作和volatile的内存可见性语义。&lt;/p&gt;

&lt;p&gt;本文基于JDK1.7.0_67&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;java version &amp;ldquo;1.7.0&lt;em&gt;67&amp;rdquo;&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;_Java&amp;trade; SE Runtime Environment (build 1.7.0_67-b01)&lt;/p&gt;

&lt;p&gt;Java HotSpot&amp;trade; 64-Bit Server VM (build 24.65-b04, mixed mode)&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&#34;成员变量&#34;&gt;成员变量&lt;/h2&gt;

&lt;p&gt;&lt;code&gt;AtomicReference&lt;/code&gt;通过泛型&lt;code&gt;T&lt;/code&gt;来声明成员值的类型，表示这是对引用类型的操作。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;// 成员变量unsafe是原子变量相关操作的基础
// 原子变量的修改操作最终有sun.misc.Unsafe类的CAS操作实现
private static final Unsafe unsafe = Unsafe.getUnsafe();
// 成员变量value的内存偏移值，在静态代码块中初始化
private static final long valueOffset;
// 通过volatile关键字保证可见性，用于保存值
private volatile V value;

static {
  try {
    valueOffset = unsafe.objectFieldOffset
      (AtomicReference.class.getDeclaredField(&amp;quot;value&amp;quot;));
  } catch (Exception ex) { throw new Error(ex); }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;函数列表&#34;&gt;函数列表&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;// 构造函数，初始化值为null
public AtomicReference()
// 构造函数，指定初始化值
public AtomicReference(V initialValue)
// 以原子方式获取当前值
public final V get()
// 以原子方式设置当前值为新的值newValue
public final void set(V newValue)
// 以原子方式设置当前值为新的值newValue
// 优先保证修改操作，而不保证volatile的可见性语义
// 效率较高
public final void lazySet(V newValue)
// 以原子方式设置当前值为update
// 如果当前值等于except，则设置成功，返回true
// 如果当前值不等于except，则设置失败，返回fase
// 该过程不阻塞
public final boolean compareAndSet(V expect, V update)
// 以原子方式设置当前值为update
// 如果当前值等于except，则设置成功，返回true
// 如果当前值不等于except，则设置失败，返回fase
// 该过程不阻塞
// 该过程不保证volatile成员的happens-before语义顺序
public final boolean weakCompareAndSet(V expect, V update)
// 以原子方式设置当前值为update
// 返回更新前的值
public final V getAndSet(V newValue)
// 返回当前值的string表达式
public String toString()
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;重点函数分析&#34;&gt;重点函数分析&lt;/h2&gt;

&lt;h3 id=&#34;set-v-newvalue&#34;&gt;set(V newValue)&lt;/h3&gt;

&lt;p&gt;以原子方式设置当前值为newValue，因为set方法只是一个单操作的赋值语句，因此是原子的。加上volatile的内存可见性保证，Set是原子操作无疑。&lt;/p&gt;

&lt;h3 id=&#34;lazyset-v-newvalue&#34;&gt;lazySet(V newValue)&lt;/h3&gt;

&lt;p&gt;简单点说，lazySet优先保证数据的修改操作，而降低对可见性的要求。&lt;/p&gt;

&lt;p&gt;lazySet是使用Unsafe.putOrderedObject方法，这个方法在对低延迟代码是很有用的，它能够实现非堵塞的写入，这些写入不会被Java的JIT重新排序指令(&lt;a href=&#34;http://stackoverflow.com/questions/14321212/java-instruction-reordering-cache-in-threads&#34;&gt;instruction reordering&lt;/a&gt;)，这样它使用快速的存储-存储(store-store) barrier, 而不是较慢的存储-加载(store-load) barrier, 后者总是用在volatile的写操作上，这种性能提升是有代价的，虽然便宜，也就是写后结果并不会被其他线程看到，甚至是自己的线程，通常是几纳秒后被其他线程看到，这个时间比较短，所以代价可以忍受。&lt;/p&gt;

&lt;p&gt;类似Unsafe.putOrderedObject还有unsafe.putOrderedLong等方法，unsafe.putOrderedLong比使用 volatile long要快3倍左右。&lt;/p&gt;

&lt;h2 id=&#34;compareandset-v-expect-v-update&#34;&gt;compareAndSet(V expect,V update)&lt;/h2&gt;

&lt;p&gt;以原子方式设置当前值为update。如果当前值等于expect，并设置成功，返回true。如果当前值不等于expect，则设置失败，返回false。该过程不阻塞。由于是使用了&lt;code&gt;sun.misc.Unsafe&lt;/code&gt;的CAS操作实现，它是原子操作无疑。&lt;/p&gt;

&lt;p&gt;_&lt;em&gt;set和compareAndSet都是原子操作，只是他们的目的不同，set只是单纯想设置一个新的值。而compareAndSet则是希望在满足一定条件的情况下(当前值等于except)再设置新的值。&lt;/em&gt;&lt;/p&gt;

&lt;h2 id=&#34;weakcompareandset-v-expect-v-update&#34;&gt;weakCompareAndSet(V expect,V update)&lt;/h2&gt;

&lt;p&gt;以原子方式设置当前值为update。它的实现与compareAndSet完全一致。JDK文档中说，weakCompareAndSet在更新变量时并不创建任何&lt;code&gt;happens-before&lt;/code&gt;顺序，因此即使要修改的值是volatile的，也不保证对该变量的读写操作的顺序（一般来讲，volatile的内存语义保证&lt;code&gt;happens-before&lt;/code&gt;顺序）。&lt;/p&gt;

&lt;p&gt;参考:&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;a href=&#34;https://developer.xamarin.com/api/type/Java.Util.Concurrent.Atomic.AtomicMarkableReference/&#34;&gt;Java.Util.Concurrent.Atomic.AtomicMarkableReference Class&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;
</description>
    </item>
    
  </channel>
</rss>