<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>泥土巢</title>
    <link>http://nituchao.com/</link>
    <description>Recent content on 泥土巢</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh-CN</language>
    <copyright>Copyright (c) 2017, nituchao | All rights reserved.</copyright>
    <lastBuildDate>Mon, 06 Mar 2017 09:34:07 +0800</lastBuildDate>
    
	<atom:link href="http://nituchao.com/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>YourKit远程连接线上服务器</title>
      <link>http://nituchao.com/post/2017/your-kit-yuan-cheng-lian-jie-xian-shang-fu-wu/</link>
      <pubDate>Mon, 06 Mar 2017 09:34:07 +0800</pubDate>
      
      <guid>http://nituchao.com/post/2017/your-kit-yuan-cheng-lian-jie-xian-shang-fu-wu/</guid>
      <description>YourKit是一款业内领先的性能分析工具，目前支持Java和.NET两个平台。该工具功能全面强悍，能通过本地连接或者远程连接的方式，对各种服务器，框架，平台的性能进行分析，并提供了多种由浅入深，针对开发环境或者生产环境的分析模式。该工具提供了高效的图形化显示方式，动动鼠标就可以对系统进行显微镜式的观察分析。
通过YourKit可以对以下内容进行分析：
 CPU profiling - investigate performace issues Memory profiling - memory leaks, usage, GC Threads and synchronization Exception profiling Web, Database, I/O  本文想总结一下，YourKit提供的两种连接到Java进程的方式，一种是attach方式，另一种是integrate方式。
通过attach方式连接到远程服务器 在控制台，attach方式可以通过进程号，连接到运行中的任何Java进程中，这种方式并不保证总能连接成功，而且会禁用某些分析功能。
线上环境  CentOS release 6.3 64-Bit Java 1.7.0_79 HotSpot&amp;trade; 64-Bit Server VM  下载安装包 # wget https://www.yourkit.com/download/yjp-2017.02-b53.zip # unzip yjp-2017.02-b53.zip # cd yjp-2017.02  确定服务进程号 # jps 2230 Resin 3959 Jps  Console连接进程 通过下面的命令来连接到Java进程。
# bin/yjp.sh -attach [YourKit Java Profiler 2017.02-b53] Log file: /root/.</description>
    </item>
    
    <item>
      <title>在CentOS上安装Rabbitmq集群</title>
      <link>http://nituchao.com/post/2017/centos-an-zhuang-rabbit-cluster/</link>
      <pubDate>Thu, 02 Mar 2017 17:35:54 +0800</pubDate>
      
      <guid>http://nituchao.com/post/2017/centos-an-zhuang-rabbit-cluster/</guid>
      <description>系统环境  CentOS 7 四台  安装包准备  wxBase-2.8.12-1.el6.centos.x86_64.rpm wxGTK-2.8.12-1.el6.centos.x86_64.rpm wxGTK-gl-2.8.12-1.el6.centos.x86_64.rpm esl-erlang_19.2.3~centos~6_amd64.rpm otp_src_19.1.tar.gz rabbitmq-server-3.6.6-1.el6.noarch.rpm  安装Erlang环境 # yum localinstall wxBase-2.8.12-1.el6.centos.x86_64.rpm # yum localinstall wxGTK-2.8.12-1.el6.centos.x86_64.rpm # yum localinstall wxGTK-gl-2.8.12-1.el6.centos.x86_64.rpm # yum localinstall esl-erlang_19.2.3~centos~6_amd64.rpm # yum install build-essential openssl openssl-devel unixODBC unixODBC-devel make gcc gcc-c++ kernel-devel m4 ncurses-devel tk tc # tar -zxvf otp_src_19.1.tar.gz # cd otp_src_19.1 # ./configure --prefix=/home/erlang --without-javac # make &amp;amp;&amp;amp; make install  安装完Erlang之后，修改/etc/profile增加
export PATH=$PATH:/home/erlang/bin
执行source /etc/profile使得环境变量生效</description>
    </item>
    
    <item>
      <title>jstack命令</title>
      <link>http://nituchao.com/post/2017/tong-guo-jstack-fen-xi/</link>
      <pubDate>Tue, 28 Feb 2017 19:01:58 +0800</pubDate>
      
      <guid>http://nituchao.com/post/2017/tong-guo-jstack-fen-xi/</guid>
      <description>Java程序在操作系统上是以单进程、多线程的形式运行。
[work@zc-stage1-miui-sec02 ~]$ jstack Usage: jstack [-l] &amp;lt;pid&amp;gt; (to connect to running process) jstack -F [-m] [-l] &amp;lt;pid&amp;gt; (to connect to a hung process) jstack [-m] [-l] &amp;lt;executable&amp;gt; &amp;lt;core&amp;gt; (to connect to a core file) jstack [-m] [-l] [server_id@]&amp;lt;remote server IP or hostname&amp;gt; (to connect to a remote debug server) Options: -F to force a thread dump. Use when jstack &amp;lt;pid&amp;gt; does not respond (process is hung) -m to print both java and native frames (mixed mode) -l long listing.</description>
    </item>
    
    <item>
      <title>解决Java进程占用CPU过高的问题</title>
      <link>http://nituchao.com/post/2017/ji-lu-yi-ci-cpu-guo-gao-chu-li/</link>
      <pubDate>Tue, 28 Feb 2017 09:16:18 +0800</pubDate>
      
      <guid>http://nituchao.com/post/2017/ji-lu-yi-ci-cpu-guo-gao-chu-li/</guid>
      <description></description>
    </item>
    
    <item>
      <title>Atomic变量</title>
      <link>http://nituchao.com/post/juc.atomic/atomic-summary/</link>
      <pubDate>Thu, 23 Feb 2017 18:39:27 +0800</pubDate>
      
      <guid>http://nituchao.com/post/juc.atomic/atomic-summary/</guid>
      <description>Java原子变量的诞生源自一个简单的需求 —— 多个线程共享某个变量或者对象时，需要对修改和读取操作进行同步。
同步包含两层含义：
 互斥访问 可见性  通常，多线程对临界资源的互斥访问通过对象锁(synchronized关键字)保证。对象锁是一种独占锁（悲观锁），会导致其它所有需要锁的线程挂起。而可见性则由volatile的内存语义保证。
Java 1.5开始提供了原子变量和原子引用，这些类放置在java.util.concurrent下。大概可以归为4类：
 基本类型：AtomicInteger, AtomicLong, AtomicBoolean; 数组类型：AtomicIntegerArray, AtomicLongArray, AtomicReferenceArray; 引用类型：AtomicReference, AtomicStampedReference, AtomicMarkableReference; 对象的属性修改类型：AtomicIntegerFieldUpdater, AtomicLongFieldUpdater, AtomicReferenceFieldUpdater;  Java原子变量的存在是为了对相应的数据进行原子操作。
所谓的原子操作包含下面几层含义：
 操作过程不会被中断。 操作过程不会被阻塞。 修改结果被其他线程可见。  </description>
    </item>
    
    <item>
      <title>Java锁之Unsafe类的理解</title>
      <link>http://nituchao.com/post/juc.lock/java-unsafe/</link>
      <pubDate>Thu, 23 Feb 2017 18:39:27 +0800</pubDate>
      
      <guid>http://nituchao.com/post/juc.lock/java-unsafe/</guid>
      <description>一言 sun.misc.Unsafe类是超越Java的存在，它违反了Java在内存管理上的设计初衷，却又是Java很多重要特性与功能得以实现的基础，它使Java的安全性受到威胁，却有使Java在很多方面的性能得到提升，它是魔鬼与天使的混合体。
概述 Java是一个安全的开发工具，它阻止开发人员犯很低级的错误，而大部分的错误都是基于内存管理的。Unsafe类突破了Java原生的内存管理体制，使用Unsafe类可以在系统内存的任意地址进行读写数据，而这些操作对于普通用户来说是非常危险的，Unsafe的操作粒度不是类，而是数据和地址。
从另一方讲，Java正被广泛应用于游戏服务器和高频率的交易应用。这些之所以能够实现主要归功于Java提供的这个非常便利的类sun.mics.Unsafe。Unsafe类为了速度，在Java严格的安全标准方法做了一些妥协。
Java在JUC包中提供了对sun.misc.Unsafe类的封装实现，这就是java.util.concurrent.LockSupport。
本文基于JDK1.7.0_67
 java version &amp;ldquo;1.7.067&amp;rdquo;
_Java&amp;trade; SE Runtime Environment (build 1.7.0_67-b01)
Java HotSpot&amp;trade; 64-Bit Server VM (build 24.65-b04, mixed mode)
 重要函数 sun.mics.Unsafe一共提供了106个函数，这些函数涵盖了以下五个方面的功能：
 对变量和数组内容的原子访问，自定义内存屏障 对序列化的支持 自定义内存管理/高效的内存布局 与原生代码和其他JVM进行互操作 对高级锁的支持  获取实例 sun.misc.Unsafe只有一个无参的私有构造函数，要想实例化sun.misc.Unsafe可以调用getUnsafe()方法。
@CallerSensitive public static Unsafe getUnsafe() { Class var0 = Reflection.getCallerClass(); if(var0.getClassLoader() != null) { throw new SecurityException(&amp;quot;Unsafe&amp;quot;); } else { return theUnsafe; } }  出于安全考虑，Unsafe类只能被系统类加载器实例化，否则会抛出SecurityException异常。普通用户如果想实例化sun.misc.Unsafe类的对象，需要通过类反射机制或者修改Java的安全策略。
内存操作 获取成员变量偏移量 // 返回对象中指定静态成员变量的内存偏移量(相对于类存储) public native long staticFieldOffset(Field f); // 返回对象中指定成员变量的内存偏移量(相对于对象实例) public native long objectFieldOffset(Field f); // 返回对象中指定成员变量 public native Object staticFieldBase(Field f);  sun.</description>
    </item>
    
    <item>
      <title>AtomicLong源码分析</title>
      <link>http://nituchao.com/post/juc.atomic/atomic-long/</link>
      <pubDate>Thu, 23 Feb 2017 18:30:28 +0800</pubDate>
      
      <guid>http://nituchao.com/post/juc.atomic/atomic-long/</guid>
      <description>概述 在原子变量相关类中，AtomicBoolean, AtomicInteger, AtomicLong三个类是对于基本数据类型的操作，其原理和用法类似，区别在于Boolean, Integer, Long分别是8位，32位，64位的类型，本文重点研究AtomicLong。
Boolean类型数据长度为8位，Integer类型数据是32位，在当前32位操作系统或者64位操作中都能够直接对其进行原子修改和读取。而Long类型数据是64位，在32位JVM上会当做两个分离的32位来进行操作，所以本身不具备原子性。
还好我们现在的JDK基本都已经更新到64位，对long型数据的直接修改不存在原子性问题，但是当出现运算操作(比如++, —等)时还是会出现性问题，AtomicLong的目的是实现Long类型数据的各种原子操作。
Java原子变量的实现依赖于sun.misc.Unsafe的CAS操作和volatile的内存可见性语义。
本文基于JDK1.7.0_67
 java version &amp;ldquo;1.7.067&amp;rdquo;
_Java&amp;trade; SE Runtime Environment (build 1.7.0_67-b01)
Java HotSpot&amp;trade; 64-Bit Server VM (build 24.65-b04, mixed mode)
 成员变量 // 成员变量unsafe是原子变量相关操作的基础 // 原子变量的修改操作最终有sun.misc.Unsafe类的CAS操作实现 private static final Unsafe unsafe = Unsafe.getUnsafe(); // 成员变量value的内存偏移值，在静态代码块中初始化 private static final long valueOffset; // 通过volatile关键字保证可见性，用于保存值 private volatile long value; // 记录当前虚拟机是否支持long的原子化操作，如果支持，可以使用CAS进行更新 // 这个问题主要是针对32位JVM对long的更新 static final boolean VM_SUPPORTS_LONG_CAS = VMSupportsCS8(); static { try { valueOffset = unsafe.</description>
    </item>
    
    <item>
      <title>AtomicLongArray源码分析</title>
      <link>http://nituchao.com/post/juc.atomic/atomic-long-array/</link>
      <pubDate>Thu, 23 Feb 2017 18:30:27 +0800</pubDate>
      
      <guid>http://nituchao.com/post/juc.atomic/atomic-long-array/</guid>
      <description>概述 在原子变量相关类中，AtomicIntegerArray, AtomicLongArray, AtomicReferenceArray三个类是对数组类型的原子类操作，其原理和用法类似，本文重点研究AtomicLongArray。
Java原子变量的实现依赖于sun.misc.Unsafe的CAS操作和volatile的内存可见性语义。
本文基于JDK1.7.0_67
 java version &amp;ldquo;1.7.067&amp;rdquo;
_Java&amp;trade; SE Runtime Environment (build 1.7.0_67-b01)
Java HotSpot&amp;trade; 64-Bit Server VM (build 24.65-b04, mixed mode)
 成员变量 // 成员变量unsafe是原子变量相关操作的基础 // 原子变量的修改操作最终有sun.misc.Unsafe类的CAS操作实现 private static final Unsafe unsafe = Unsafe.getUnsafe(); // arrayBaseOffset获取数组首个元素地址偏移 private static final int base = unsafe.arrayBaseOffset(long[].class); // shift就是数组元素的偏移量 private static final int shift; // 保存数据的数组，在构造函数中初始化 private final long[] array; static { // scale数组元素的增量偏移 int scale = unsafe.arrayIndexScale(long[].class); // 用二进制&amp;amp;操作判断是否是2的倍数，很精彩 // 对于int型数组，scale是4 // 对于lang型数组，scale是8 // 对于Reference型数组，scale是4 if ((scale &amp;amp; (scale - 1)) !</description>
    </item>
    
    <item>
      <title>AtomicReference源码分析</title>
      <link>http://nituchao.com/post/juc.atomic/atomic-reference/</link>
      <pubDate>Thu, 23 Feb 2017 18:30:27 +0800</pubDate>
      
      <guid>http://nituchao.com/post/juc.atomic/atomic-reference/</guid>
      <description>概述 在原子变量相关类中，AtomicReference, AtomicStampedReference, AtomicMarkableReference三个类是对于引用类型的操作，其原理和用法类似。
AtomicStampedReference是带了整型版本号(int stamp)的引用型原子变量，每次执行CAS操作时需要对比版本，如果版本满足要求，则操作成功，否则操作失败，用于防止CAS操作的ABA问题。
AtomicMarkableReference则是带了布尔型标记位(Boolean mark)的引用型原子量，每次执行CAS操作是需要对比该标记位，如果标记满足要求，则操作成功，否则操作失败。
Java原子变量的实现依赖于sun.misc.Unsafe的CAS操作和volatile的内存可见性语义。
本文基于JDK1.7.0_67
 java version &amp;ldquo;1.7.067&amp;rdquo;
_Java&amp;trade; SE Runtime Environment (build 1.7.0_67-b01)
Java HotSpot&amp;trade; 64-Bit Server VM (build 24.65-b04, mixed mode)
 成员变量 AtomicReference通过泛型T来声明成员值的类型，表示这是对引用类型的操作。
// 成员变量unsafe是原子变量相关操作的基础 // 原子变量的修改操作最终有sun.misc.Unsafe类的CAS操作实现 private static final Unsafe unsafe = Unsafe.getUnsafe(); // 成员变量value的内存偏移值，在静态代码块中初始化 private static final long valueOffset; // 通过volatile关键字保证可见性，用于保存值 private volatile V value; static { try { valueOffset = unsafe.objectFieldOffset (AtomicReference.class.getDeclaredField(&amp;quot;value&amp;quot;)); } catch (Exception ex) { throw new Error(ex); } }  函数列表 // 构造函数，初始化值为null public AtomicReference() // 构造函数，指定初始化值 public AtomicReference(V initialValue) // 以原子方式获取当前值 public final V get() // 以原子方式设置当前值为新的值newValue public final void set(V newValue) // 以原子方式设置当前值为新的值newValue // 优先保证修改操作，而不保证volatile的可见性语义 // 效率较高 public final void lazySet(V newValue) // 以原子方式设置当前值为update // 如果当前值等于except，则设置成功，返回true // 如果当前值不等于except，则设置失败，返回fase // 该过程不阻塞 public final boolean compareAndSet(V expect, V update) // 以原子方式设置当前值为update // 如果当前值等于except，则设置成功，返回true // 如果当前值不等于except，则设置失败，返回fase // 该过程不阻塞 // 该过程不保证volatile成员的happens-before语义顺序 public final boolean weakCompareAndSet(V expect, V update) // 以原子方式设置当前值为update // 返回更新前的值 public final V getAndSet(V newValue) // 返回当前值的string表达式 public String toString()  重点函数分析 set(V newValue) 以原子方式设置当前值为newValue，因为set方法只是一个单操作的赋值语句，因此是原子的。加上volatile的内存可见性保证，Set是原子操作无疑。</description>
    </item>
    
    <item>
      <title>AtomicStampedReference源码分析</title>
      <link>http://nituchao.com/post/juc.atomic/atomic-stamped-reference/</link>
      <pubDate>Thu, 23 Feb 2017 18:30:27 +0800</pubDate>
      
      <guid>http://nituchao.com/post/juc.atomic/atomic-stamped-reference/</guid>
      <description>概述 在原子变量相关类中，AtomicReference, AtomicStampedReference, AtomicMarkableReference三个类是对于引用类型的操作，其原理和用法类似。
AtomicStampedReference是带了整型版本号(int stamp)的引用型原子变量，每次执行CAS操作时需要对比版本，如果版本满足要求，则操作成功，否则操作失败，用于防止CAS操作的ABA问题。本文重点分析AtomicStampedReference。
AtomicMarkableReference则是带了布尔型标记位(Boolean mark)的引用型原子量，每次执行CAS操作是需要对比该标记位，如果标记满足要求，则操作成功，否则操作失败。
Java原子变量的实现依赖于sun.misc.Unsafe的CAS操作和volatile的内存可见性语义。
本文基于JDK1.7.0_67
 java version &amp;ldquo;1.7.067&amp;rdquo;
_Java&amp;trade; SE Runtime Environment (build 1.7.0_67-b01)
Java HotSpot&amp;trade; 64-Bit Server VM (build 24.65-b04, mixed mode)
 内部类 AtomicStampedReference是带整形版本号的原子引用类型，为了同时兼顾引用值和版本号，它定义了一个静态内部类Pair，AtomicStampedReference的相关操作都是对Pair内成员的操作。
private static class Pair&amp;lt;T&amp;gt; { final T reference; final int stamp; private Pair(T reference, int stamp) { this.reference = reference; this.stamp = stamp; } static &amp;lt;T&amp;gt; Pair&amp;lt;T&amp;gt; of(T reference, int stamp) { return new Pair&amp;lt;T&amp;gt;(reference, stamp); } }  成员变量 AtomicStampedReference除了常规的sun.</description>
    </item>
    
    <item>
      <title>AtomicMarkableReference源码分析</title>
      <link>http://nituchao.com/post/juc.atomic/atomic-markable-reference/</link>
      <pubDate>Thu, 23 Feb 2017 18:30:25 +0800</pubDate>
      
      <guid>http://nituchao.com/post/juc.atomic/atomic-markable-reference/</guid>
      <description>概述 在原子变量相关类中，AtomicReference, AtomicStampedReference, AtomicMarkableReference三个类是对于引用类型的操作，其原理和用法类似。
AtomicStampedReference是带了整型标记值(int stamp)的引用型原子变量，每次执行CAS操作时需要对比版本，如果版本满足要求，则操作成功，否则操作失败，用于防止CAS操作的ABA问题。
AtomicMarkableReference则是带了布尔型标记位(Boolean mark)的引用型原子量，每次执行CAS操作是需要对比该标记位，如果标记满足要求，则操作成功，否则操作失败。本文重点分析AtomicMarkableReference。
Java原子变量的实现依赖于sun.misc.Unsafe的CAS操作和volatile的内存可见性语义。
本文基于JDK1.7.0_67
 java version &amp;ldquo;1.7.0_67&amp;rdquo;
_Java&amp;trade; SE Runtime Environment (build 1.7.0_67-b01)
Java HotSpot&amp;trade; 64-Bit Server VM (build 24.65-b04, mixed mode)
 内部类 AtomicMarkableReference是带布尔型标记为的原子引用类型，为了同时兼顾引用值和标记位，它定义了一个静态内部类Pair，AtomicMarkableReference的相关操作都是对Pair内成员的操作。
private static class Pair&amp;lt;T&amp;gt; { final T reference; final boolean mark; private Pair(T reference, boolean mark) { this.reference = reference; this.mark = mark; } static &amp;lt;T&amp;gt; Pair&amp;lt;T&amp;gt; of(T reference, int mark) { return new Pair&amp;lt;T&amp;gt;(reference, mark); } }  成员变量 AtomicMarkableReference除了常规的sun.</description>
    </item>
    
    <item>
      <title>Java锁之自旋锁的原理</title>
      <link>http://nituchao.com/post/juc.lock/clh-spin-ticket-mcs-lock/</link>
      <pubDate>Thu, 23 Feb 2017 18:29:27 +0800</pubDate>
      
      <guid>http://nituchao.com/post/juc.lock/clh-spin-ticket-mcs-lock/</guid>
      <description>概述 锁作为数据同步工具，Java提供了两种实现：synchronized和AQS，这两种锁的实现根本不同，但是在加锁和解锁的过程中，也有很多共同点。它们在进行加锁/解锁时或多或少的用到自旋锁的设计思想。对于这几种自旋锁设计思想的研究，可以帮助我们更好的理解Java的Lock框架。
SPIN锁 Spin锁即自旋锁。自旋锁是采用让当前线程不停地在循环体内检测并设置临界资源的状态，直到状态满足条件并设置为指定的新状态。检测并设置临界资源操作必须是原子的，这样即使多个线程在给定时间自旋，也只有一个线程可获得该锁。
自旋锁的优点之一是自旋的线程不会被阻塞，一直处于活跃状态，对于锁保护的临界区较小的情况下，自旋获取锁和释放锁的成本都比较低，时间比较短。
Java中的自旋锁 在JAVA中，我们可以使用原子变量和Unsafe类的CAS操作来实现自旋锁：
public class SpinLock { private AtomicReference&amp;lt;Thread&amp;gt; atomic = new AtomicReference&amp;lt;Thread&amp;gt;(); public void lock() { Thread currentThread = Thread.currentThread(); // 如果锁未被占用，则设置当前线程为锁的拥有者。 while(!atomic.compareAndSet(null, currentThread)) {} } public void unlock() { Thread currentThread = Thread.currentThread(); // 只有锁的拥有者能释放锁 atomic.compareAndSet(currentThread, null); } }  缺点  CAS操作需要硬件的配合；
 保证各个CPU的缓存（L1、L2、L3、跨CPU Socket、主存）的数据一致性，通讯开销很大，在多处理器系统上更严重；
 没法保证公平性，不保证等待进程/线程按照FIFO顺序获得锁。
  ​
Linux中的自旋锁 自旋锁在Linux内核中广泛使用。在Linux操作系统中，自旋锁是一个互斥设备，它只有两个值锁定和解锁。
由于操作系统和CPU直接打交道，自旋锁又可分为在单核处理器上和多核处理器上。
单核处理器 用在单核处理器上，有可分为两种：
 系统不支持内核抢占  此时自旋锁什么也不做，确实也不需要做什么，因为单核处理器只有一个线程在执行，又不支持内核抢占，因此资源不可能会被其他的线程访问到。
 系统支持内核抢占  这种情况下，自旋锁加锁仅仅是禁止了内核抢占，解锁则是启用了内核抢占。</description>
    </item>
    
    <item>
      <title>Java锁之Lock框架概述</title>
      <link>http://nituchao.com/post/juc.lock/lock-summary/</link>
      <pubDate>Thu, 23 Feb 2017 18:28:27 +0800</pubDate>
      
      <guid>http://nituchao.com/post/juc.lock/lock-summary/</guid>
      <description> 在Java中关于锁有两个体系，一个是synchronized代表的对象监视器同步锁，一个是以AQS为基础的锁框架，该框架位于java.uti.concurrent包下。
本文基于JDK1.7.0_67
 java version &amp;ldquo;1.7.067&amp;rdquo;
_Java&amp;trade; SE Runtime Environment (build 1.7.0_67-b01)
Java HotSpot&amp;trade; 64-Bit Server VM (build 24.65-b04, mixed mode)
 AQS框架原理 JUC包中的锁 相比同步锁，JUC包中的锁的功能更加强大，它为锁提供了一个框架，该框架允许更灵活地使用锁，只是它的用法更难罢了。
JUC包中的锁，包括：
 Lock接口 ReadWriteLock接口 Condition接口 ReentrantLock独占锁 ReentrantReadWriteLock读写锁 CountDownLatch CyclicBarrier Semaphore AbstractOwnableSynchronizer抽象类 AbstractQueuedSynchronizer抽象类 AbstractQueuedLongSynchronizer抽象类  </description>
    </item>
    
    <item>
      <title>AtomicLongFieldUpdater源码分析</title>
      <link>http://nituchao.com/post/juc.atomic/atomic-long-field-updater/</link>
      <pubDate>Thu, 23 Feb 2017 18:27:27 +0800</pubDate>
      
      <guid>http://nituchao.com/post/juc.atomic/atomic-long-field-updater/</guid>
      <description>概述 在原子变量相关类中，AtomicIntegerFieldUpdater, AtomicLongFieldUpdater, AtomicReferenceFieldUpdater三个类是用于原子地修改对象的成员属性，它们的原理和用法类似，区别在于对Integer，Long，Reference类型的成员属性进行修改。本文重点研究AtomicLongFieldUpdater。
AtomicLongFieldUpdater的设计非常有意思。AtomicLongFieldUpdater本身是一个抽象类，只有一个受保护的构造函数，它本身不能被实例化。
AtomicLongFieldUpdater有两个私有的静态内部类CASUpdater和LockedUpdater，它们都是AtomicLongFieldUpdater的子类。
用户使用AtomicLongFieldUpdater的静态方法newUpdater实例化AtomicLongFieldUpdater子类对象，本质是上是根据条件实例化了子类CASUpdater或者LockedUpdater，然后通过子类来完成具体的工作。CASUpdater和LockedUpdater值的读取和更新最后都是使用sun.misc.Unsafe类的相关操作。
CASUpdater使用下面的方法：
public native Object getLongVolatile(Object o, long offset); public native void putLongVolatile(Object o, long offset, long x);  LockedUpdater使用下面的方法：
public native long getLong(Object o, long offset); public native void putLong(Object o, long offset, long x);  为了防止操作过程中的指令重排，LockedUpdater使用synchronized进行同步。
本文基于JDK1.7.0_67
 java version &amp;ldquo;1.7.0_67&amp;rdquo;
_Java™ SE Runtime Environment (build 1.7.0_67-b01)
Java HotSpot™ 64-Bit Server VM (build 24.65-b04, mixed mode)
 内部类 AtomicLongFieldUpdater本身是抽象类，通过两个私有的静态内部子类来完成具体的工作。
 CASUpdater：顾名思义，使用CAS操作对象的成员变量。 LockedUpdater：顾名思义，在更新和读取对象的成员变量时，使用对象锁来保证同步。  成员变量 AtomicLongFieldUpdater是个抽象类，具体的业务逻辑都是交给它的子类实现的，它本身没有包含任何成员变量。</description>
    </item>
    
    <item>
      <title>ConcurrentHashMap源码分析</title>
      <link>http://nituchao.com/post/juc.concurrent/concurrent-hasmap/</link>
      <pubDate>Thu, 23 Feb 2017 18:27:27 +0800</pubDate>
      
      <guid>http://nituchao.com/post/juc.concurrent/concurrent-hasmap/</guid>
      <description>一言 ConcurrentHashMap是线程安全的、高效的哈希表。默认支持16个并发级别，并发级别在初始化后不能扩展。
概述 HashMap是非线程安全的哈希表，常用于单线程程序中。
Hashtable是线程安全的哈希表，它是通过synchronized来保证线程安全的；多线程通过同一个“对象的同步锁”来实现并发控制。Hashtable在线程竞争激烈时，效率比较低(此时建议使用ConcurrentHashMap)！因为当一个线程访问Hashtable的同步方法时，其它线程就访问Hashtable的同步方法时，可能会进入阻塞状态。
ConcurrentHashMap是线程安全的哈希表，它是通过“锁分段”来保证线程安全的。ConcurrentHashMap将哈希表分成许多片段(Segment)，每一个片段除了保存哈希表之外，本质上也是一个“可重入的互斥锁”(ReentrantLock)。多线程对同一个片段的访问，是互斥的；但是，对于不同片段的访问，却是可以同步进行的。
本文基于JDK1.7.0_67
 java version &amp;ldquo;1.7.067&amp;rdquo;
_Java&amp;trade; SE Runtime Environment (build 1.7.0_67-b01)
Java HotSpot&amp;trade; 64-Bit Server VM (build 24.65-b04, mixed mode)
 ConcurrentHashMap数据结构 要想搞清ConcurrentHashMap，必须先弄清楚它的数据结构：
图
说明:
 ConcurrentHashMap继承于AbstractMap抽象类。 Setment是ConcurrentHashMap的内部类，它就是ConcurrentHashMap中的&amp;rdquo;锁分段&amp;rdquo;对应的数据结构。ConcurrentHashMap与Segment是组合关系，1个ConcurrentHashMap对象包含若干个Segment对象。在代码中，这表现为ConcurrentHashMap类中存在&amp;rdquo;Segment数组&amp;rdquo;成员。 Segment类继承于ReentrantLock类，所以Segment本质上是一个可重入的互斥锁。 HashEntry也是ConcurrentHashMap的内部类，是单向链表节点，存储着key-value键值对。Segment与HashEntry是组合关系，Segment类中存在“HashEntry数组”成员，“HashEntry数组”中的每个HashEntry就是一个单向链表。  对于多线程访问对一个“哈希表对象”竞争资源，Hashtable是通过一把锁来控制并发；而ConcurrentHashMap则是将哈希表分成许多片段，对于每一个片段分别通过一个互斥锁来控制并发。ConcurrentHashMap对并发的控制更加细腻，它也更加适应于高并发场景！
ConcurrentHashMap常量定义 // 默认初始容量(HashEntry的个数) static final int DEFAULT_INITIAL_CAPACITY = 16; // 默认负载因子 static final float DEFAULT_LOAD_FACTOR = 0.75f; // 默认并发级别 static final int DEFAULT_CONCURRENCY_LEVEL = 16; // 最大容量(HashEntry的个数) static final int MAXIMUM_CAPACITY = 1 &amp;lt;&amp;lt; 30; // 每个段(Segment)中HashEntry数组(table)的最小容量 // 设置最小为2，是为了防止构造完成后立即resize static final int MIN_SEGMENT_TABLE_CAPACITY = 2; // 段的最大个数 static final int MAX_SEGMENTS = 1 &amp;lt;&amp;lt; 16; // slightly conservative // 在计算size时，先尝试不获取段锁计算，最多尝试RETRIES_BEFORE_LOCK次。 // 如果重试超过RETRIES_BEFORE_LOCK次，则获取段锁后进行计算。 static final int RETRIES_BEFORE_LOCK = 2;  ConcurrentHashMap成员变量 // 制造一个随机值，使得在计算key的hash值时不容易出现冲突。 // 该值通过sun.</description>
    </item>
    
    <item>
      <title>AtomicIntegerFieldUpdater源码分析</title>
      <link>http://nituchao.com/post/juc.atomic/atomic-integer-field-updater/</link>
      <pubDate>Thu, 23 Feb 2017 18:27:25 +0800</pubDate>
      
      <guid>http://nituchao.com/post/juc.atomic/atomic-integer-field-updater/</guid>
      <description>概述 在原子变量相关类中，AtomicIntegerFieldUpdater, AtomicLongFieldUpdater, AtomicReferenceFieldUpdater三个类是用于原子地修改对象的成员属性，它们的原理和用法类似，区别在于对Integer，Long，Reference类型的成员属性进行修改。本文重点研究AtomicIntegerFieldUpdater。
AtomicIntegerFieldUpdater的设计非常有意思。AtomicIntegerFieldUpdater本身是一个抽象类，只有一个受保护的构造函数，它本身不能被实例化。在AtomicIntegerFieldUpdater中定义了一些基本的模板方法，然后通过一个静态内部子类AtomicIntegerFieldUpdaterImpl来实现具体的操作。AtomicIntegerFieldUpdaterImpl中的相关操作也都是基于Unsafe类来实现的。
本文基于JDK1.7.0_67
 java version &amp;ldquo;1.7.0_67&amp;rdquo;
_Java™ SE Runtime Environment (build 1.7.0_67-b01)
Java HotSpot™ 64-Bit Server VM (build 24.65-b04, mixed mode)
 内部类 AtomicIntegerFieldUpdater本身是一个抽象类，通过一个静态内部子类来实现相关的操作。
private static class AtomicIntegerFieldUpdaterImpl&amp;lt;T&amp;gt; extends AtomicIntegerFieldUpdater&amp;lt;T&amp;gt;  成员变量 AtomicIntegerFieldUpdater是个抽象类，具体的业务逻辑都是交给它的子类实现的，它本身没有包含任何成员变量。
函数列表 // 受保护的无操作构造函数，供子类使用 protected AtomicIntegerFieldUpdater() // 为对象创建并返回一个具有给定字段的更新器。 public static &amp;lt;U&amp;gt; AtomicIntegerFieldUpdater&amp;lt;U&amp;gt; newUpdater(Class&amp;lt;U&amp;gt; tclass, String fieldName) // 以原子方式设置当前值为update // 如果当前值等于expect，并设置成功，返回true // 如果当前值不等于expect，则设置失败，返回false // 该过程通过CAS实现，不阻塞 public abstract boolean compareAndSet(T obj, int expect, int update) // 以原子方式设置当前值为update // 如果当前值等于expect，并设置成功，返回true // 如果当前值不等于expect，则设置失败，返回false // 该过程通过CAS实现，不阻塞 // 该过程不保证volatile成员的happens-before语义顺序 public abstract boolean weakCompareAndSet(T obj, int expect, int update) // 以原子方式设置当前值为newValue // 使用Unsafe类的putIntVolatile进行操作，具有原子性 public abstract void set(T obj, int newValue) // 以原子方式设置当前值为newValue // 使用Unsafe类的putOrderedInt进行操作，所以本身具有原子性 public abstract void lazySet(T obj, int newValue) // 以原子方式获取当前值 // 使用Unsafe类的getIntVolatile进行操作，所以本身具有原子性 public abstract int get(T obj) // 以原子方式设置当前值为newValue，并返回更新前的值 // 使用Unsafe类的compareAndSwapInt进行操作，所以本身具有原子性 // 操作过程中使用自旋方式，直到操作成功 public int getAndSet(T obj, int newValue) // 以原子方式将当前值加1，并返回更新前的值 // 使用Unsafe类的compareAndSwapInt进行操作，所以本身具有原子性 // 操作过程中使用自旋方式，直到操作成功 public int getAndIncrement(T obj) // 以原子方式将当前值减1，并返回更新前的值 // 使用Unsafe类的compareAndSwapInt进行操作，所以本身具有原子性 // 操作过程中使用自旋方式，直到操作成功 public int getAndDecrement(T obj) // 以原子方式将当前值加上给定值delta，并返回更新前的值 // 使用Unsafe类的compareAndSwapInt进行操作，所以本身具有原子性 // 操作过程中使用自旋方式，直到操作成功 public int getAndAdd(T obj, int delta) // 以原子方式将当前值加1，并返回更新后的值 // 使用Unsafe类的compareAndSwapInt进行操作，所以本身具有原子性 // 操作过程中使用自旋方式，直到操作成功 public int incrementAndGet(T obj) // 以原子方式将当前值减1，并返回更新前的值 // 使用Unsafe类的compareAndSwapInt进行操作，所以本身具有原子性 // 操作过程中使用自旋方式，直到操作成功 public int decrementAndGet(T obj) // 以原子方式将当前值加上给定值delta，并返回更新后的值 // 使用Unsafe类的compareAndSwapInt进行操作，所以本身具有原子性 // 操作过程中使用自旋方式，直到操作成功 public int addAndGet(T obj, int delta)  重点函数分析 newUpdater 为对象创建并返回一个具有给定字段的更新器实例。在该方法中，直接构造一个AtomicIntegerFieldUpdaterImpl实例。</description>
    </item>
    
    <item>
      <title>CopyOnWriteArraySet源码分析</title>
      <link>http://nituchao.com/post/juc.concurrent/copy-on-write-array-set/</link>
      <pubDate>Thu, 23 Feb 2017 18:26:27 +0800</pubDate>
      
      <guid>http://nituchao.com/post/juc.concurrent/copy-on-write-array-set/</guid>
      <description>一言 CopyOnWriteArraySet是线程安全的无序集合，它是通过聚合了一个CopyOnWriteArray成员变量来实现的。
概要 CopyOnWriteArraySet是线程安全的无序集合，可以将它理解成线程安全的HashSet。有意思的是，CopyOnWriteArraySet和HashSet虽然都继承于共同的父类AbstractSet；但是，HashSet是通过&amp;rdquo;散列表(HashSet)&amp;ldquo;实现的，而CopyConWriteArraySet则是通过&amp;rdquo;动态数组(CopyOnWriteArrayList)&amp;ldquo;实现的，并不是散列表。
CopyOnWriteArraySet具有以下特性：
 它最适合于具有以下特征的应用程序：Set 大小通常保持很小，只读操作远多于可变操作，需要在遍历期间防止线程间的冲突。 它是线程安全的。它的线程安全通过volatile、互斥锁来实现。 因为通常需要复制整个基础数组，所以可变操作（add()、set() 和 remove() 等等）的开销很大。 迭代器支持hasNext(), next()等不可变操作，但不支持可变 remove()等 操作。 使用迭代器进行遍历的速度很快，并且不会与其他线程发生冲突。在构造迭代器时，迭代器依赖于不变的数组快照。  本文基于JDK1.7.0_67
 java version &amp;ldquo;1.7.067&amp;rdquo;
_Java&amp;trade; SE Runtime Environment (build 1.7.0_67-b01)
Java HotSpot&amp;trade; 64-Bit Server VM (build 24.65-b04, mixed mode)
 CopyOnWriteArraySet原理 CopyOnWriteArraySet的数据结构，如下图所示：
图
说明
 CopyOnWriteArraySet继承于AbstractSet，这就意味着它是一个集合。 CopyOnWriteArraySet聚合了一个CopyOnWriteArrayList对象，它是通过CopyOnWriteArrayList实现的。而CopyOnWriteArrayList本质是个动态数组队列，所以CopyOnWriteArraySet相当于通过动态数组实现的&amp;rdquo;集合&amp;rdquo;！ CopyOnWriteArraySet不允许有重复元素。因此，CopyOnWriteArrayList额外提供了addIfAbsent()和addAllAbsent()这两个添加元素的API，通过这些API来添加元素时，只有当元素不存在时才执行添加操作。 CopyOnWriteArraySet的&amp;rdquo;线程安全&amp;rdquo;机制是通过volatile和互斥锁来实现的。而它本身没有volatile变量和互斥锁，都是借由CopyOnWriteArrayList实现。  CopyOnWriteArraySet成员变量 CopyOnWriteArraySet只有下面一个成员变量
private final CopyOnWriteArrayList&amp;lt;E&amp;gt; al;  说明:
 成员变量al是final类型的，通过构造函数进行初始化后将不能再修改。 成员变量al里的添加/修改/删除操作都是通过互斥锁和volatile变量来保证现场安全的，因此，成员变量al不再用volatile修饰，也不再额外声明可重入锁lock。  CopyOnWriteArraySet函数列表 // 创建一个空 set。 CopyOnWriteArraySet() // 创建一个包含指定 collection 所有元素的 set。 CopyOnWriteArraySet(Collection&amp;lt;?</description>
    </item>
    
    <item>
      <title>CopyOnWriteArrayList源码分析</title>
      <link>http://nituchao.com/post/juc.concurrent/copy-on-write-array-list/</link>
      <pubDate>Thu, 23 Feb 2017 18:25:27 +0800</pubDate>
      
      <guid>http://nituchao.com/post/juc.concurrent/copy-on-write-array-list/</guid>
      <description>概述 CopyOnWriteArrayList相当于线程安全的ArrayList。和ArrayList一样，它是个可变数组；但是和ArrayList不同的是，它具有以下特性： 1. 它最适合于具有以下特征的应用程序：List大小通常保持很小，只读操作远多于可变操作，需要在遍历期间防止线程间的冲突。 2. 它是线程安全的。它的线程安全表现在两个方面，修改时使用锁进行同步，读取时使用数据快照。 3. 因为通常要复制整个基础数组，所以可变操作（add()、set()和remove()等操作）的开销很大。 4. 迭代器支持hasNext()、next等不可变操作，但不支持可变remove()等操作。 5. 使用迭代器进行遍历的速度很快，并且不会与其他线程发生冲突。在构造迭代器时，迭代器依赖于不变的数组快照。
本文基于JDK1.7.0_67
 java version &amp;ldquo;1.7.067&amp;rdquo;
_Java&amp;trade; SE Runtime Environment (build 1.7.0_67-b01)
Java HotSpot&amp;trade; 64-Bit Server VM (build 24.65-b04, mixed mode)
 CopyOnWriteArrayList原理和数据结构 CopyOnWriteArrayList的数据结构，如下图所示：
CopyOnWriteArrayList UML图
说明： 1. CopyOnWriteArrayList实现了List接口，因此可以认为它是一个有序的集合。 2. CopyOnWriteArrayList实现了RandomAccess接口，因此可以认为它的元素可以随机访问。 3. CopyOnWriteArrayList包含一个可重入锁Lock。每一个CopyOnWriteArrayList都和一个互斥锁lock绑定，通过lock，实现了对CopyOnWriteArrayList的互斥访问。 4. CopyOnWriteArrayList包含了成员array数组，这说明CopyOnWriteArrayList本质上通过数组实现的。而且，可存储的元素个数没有上限。
下面从&amp;rdquo;动态数组&amp;rdquo;和&amp;rdquo;线程安全&amp;rdquo;两个方面进一步对CopyOnWriteArrayList的原理进行说明。 1. CopyOnWriteArrayList的&amp;rdquo;动态数组&amp;rdquo;机制
它内部有个&amp;rdquo;volatile数组&amp;rdquo;(array)来保持数据。在&amp;rdquo;添加/修改/删除&amp;rdquo;数据时，都会新建一个数组，并将更新后的数据拷贝到新建的数组中，最后再将该数组赋值给&amp;rdquo;volatile数组&amp;rdquo;。这就是它叫做CopyOnWriteArrayList的原因！
CopyOnWriteArrayList就是通过这种方式实现的动态数组；不过正由于它在&amp;rdquo;添加/修改/删除&amp;rdquo;数据时，都会新建数组，所以涉及到修改数据的操作，CopyOnWriteArrayList效率很低。但是单单只是进行遍历的话，效率比较高。
 CopyOnWriteArrayList的&amp;rdquo;线程安全&amp;rdquo;机制  是通过volatile和互斥锁来实现的。 a. CopyOnWriteArrayList是通过&amp;rdquo;volatile数组&amp;rdquo;来保存数据的。
一个线程读取volatile数组时，总能看到其他线程对该volatile变量最后的写入。就这样，通过volatile提供了&amp;rdquo;读取到的数据总是最新的&amp;rdquo;这个机制的保证。 b. CopyOnWriteArrayList通过互斥锁来保护数据。
在&amp;rdquo;添加/修改/删除&amp;rdquo;数据时，会先&amp;rdquo;获取互斥锁&amp;rdquo;，在修改完毕后，先将数据更新到&amp;rdquo;volatile数组&amp;rdquo;中，然后再&amp;rdquo;释放互斥锁&amp;rdquo;；这样，就达到了保护数据的目的。
CopyOnWriteArrayList成员变量 /** 可重入锁，对数组进行添加/修改/删除操作时，通过lock来进行同步操作 */ transient final ReentrantLock lock = new ReentrantLock(); /** 数组，保存数据的地方。对数组array的操作都要通过getArray和setArray进行操作 */ private volatile transient Object[] array;  CopyOnWriteArrayList函数列表 // 创建一个空列表，默认大小为0。 CopyOnWriteArrayList() // 创建一个按 collection 的迭代器返回元素的顺序包含指定 collection 元素的列表。 CopyOnWriteArrayList(Collection&amp;lt;?</description>
    </item>
    
    <item>
      <title>Linux网络I/O模型整理</title>
      <link>http://nituchao.com/post/2017/linux-io-mode/</link>
      <pubDate>Wed, 22 Feb 2017 18:25:27 +0800</pubDate>
      
      <guid>http://nituchao.com/post/2017/linux-io-mode/</guid>
      <description>Linux的内核将所有外部设备都看做一个文件来操作，对一个文件的读写操作会调用内核提供的系统命令，返回一个file description(fd，文件描述符)。而对一个socket的读写也会有相应的描述符，称为socketfd(socket描述符)，描述符就是一个数字，它指向内核中的一个结构体(文件路径，数据区等一些属性)。
Linux文件类型 Linux操作系统定义了七种文件，对这些文件的操作都属于I/O操作。其中，操作TCP套接字文件时会产生网络I/O。
 d: 目录文件(directory file)  这种文件包含了其他文件的名字以及指向与这些文件有关信息的指针。对一个目录文件具有读权限的任一进程都可以读该目录的内容，但只有内核可以直接写目录文件。
 l: 符号链接文件(symbolic link)  这种类型的文件指向另一个文件。
 s: 套接字文件(socket)  这种类型的文件用于进程间的网络通信。套接字也可用于在一台宿主机上进程之间的非网络通信。
 b: 块设备文件，二进制文件(block special file)  这种为类型的文件提供对设备(如磁盘)带缓冲的访问，每次访问以固定长度为单位进行。
 c: 字符设备文件(character special file)  这种类型的文件提供对设备不带缓冲的访问，每次访问长度可变。系统中的所有设备要么是字符特殊文件，要么是块特殊文件。
 p: 命名管道文件(FIFO)  这种类型的文件用于进程间通信，有时被称为命名管道(named pipe)。
 -: 普通文件(regular file)  这是最常用的文件类型，这种文件包含了某种形式的数据。至于这种数据是文本还是二进制数据，对于UNIX内核而言并无区别。对普通文件内容的解释由处理该文件的应用程序进行。
 一个值得注意的例外是二进制可执行文件。为了执行程序，内核必须理解其格式。所有二进制可执行文件都遵循一种标准化的格式，这种格式使内核能够确定程序文本和数据的加载位置。
 Linux网络I/O模型 根据UNIX网络编程对I/O模型的分类，UNIX提供了五种I/O模型，服务器会根据自己的类型定位，使用其中一种或者多种I/O模型来处理网络请求。
阻塞I/O模型 最常用的I/O模型就是阻塞I/O模型，缺省情形下，所有文件操作都是阻塞的。我们以套接字借口为例来讲解此模型：在进程空间中调用recvfrom，其系统调用直到数据包到达且被复制到应用进程的缓冲区中或者发生错误时才返回，在此期间一直会等待，进程在从调用recvfrom开始到它返回的整段时间内都是被阻塞的，因此被称为阻塞I/O模型，如图1-1所示：
非阻塞I/O模型 recvfrom从应用层到内核的时候，如果该缓冲区没有数据的话，就直接返回一个EWORLDBLOCK错误，一般都对非阻塞I/O模型进行轮询检查这个状态，看内核是不是有数据到来，如图1-2所示：
I/O复用模型 Linux提供select/poll，进程通过将一个或者多个fd传递给select或者poll系统调用，阻塞在select操作上，这样select/poll可以帮我们侦测多个fd是否处于就绪状态。select/poll是顺序扫描fd是否就绪，而且支持的fd数量有限，因此它的使用受到了一些制约。
Linux还提供了一个epoll系统调用，epoll使用基于事件驱动方法代替顺序扫描，因此性能更高。当有fd就绪时，立即回调函数rollback，如图1-3所示：
信号驱动I/O模型 首先开启套接字接口信号驱动I/O功能，并通过系统调用sigaction执行一个信号处理函数(此系统调用立即返回，进程继续工作，它是非阻塞的)。当数据准备就绪时，就为该进程生成一个SIGIO信号，通过信号回调通知应用程序调用recvfrom来读取数据，并通知主循环函数处理数据，如图1-4所示：
异步I/O模型 告知内核启动某个操作，并让内核在整个操作完成后（包括将数据从内核复制到用户自己的缓冲区）通知我们。这种模型与信号驱动模型的主要区别是：信号驱动I/O由内核通过我们何时可以开始一个I/O操作；异步I/O模型由内核通知我们I/O操作何时已经完成，如图1-5所示：
常用服务器 目前流行的服务器大致分为普通应用服务器和高性能服务器两种。
应用服务器通常会运行具体的业务代码，比如：订单交易，网站管理等。这些业务通常使用基于MVC模式的框架，并进行数据库操作。应用服务器往往跟编程语言和应用框架绑定，提供上下文管理能力，单次业务的处理时间比较长，业务逻辑比较复杂。因此，应用服务器往往采用阻塞式I/O模型或者非阻塞I/O模型。基于请求/响应的方式工作。
高性能服务器往往需要面对极高的并发网络连接，并对内存分配、CPU使用提出更加苛刻的要求，比如：适用于反向代理的负载均衡服务器Nignx。因此，高性能服务器往往采用I/O复用模型或信号驱动I/O模型，有些对性能要求更高得服务器会采用纯异步I/O模型。相比较请求/响应的工作方式，使用后面三种I/O模型的服务器的处理方式更多样，也更复杂。
使用阻塞I/O模型或非阻塞I/O模型的服务器  Apache Tomcat Resin Caddy  使用多路复用I/O模型的服务器  Nginx Netty Mina  参考资料 1, 《Netty权威指南 第二版》，李林峰</description>
    </item>
    
    <item>
      <title>经济学人</title>
      <link>http://nituchao.com/te/</link>
      <pubDate>Mon, 20 Feb 2017 12:34:23 +0800</pubDate>
      
      <guid>http://nituchao.com/te/</guid>
      <description> 2017年2月  TE_2017.02.04.pdf TE_2017.02.04.epub TE_2017.02.04.mobi  
2017年1月  TE_2017.01.07.pdf TE_2017.01.07.epub TE_2017.01.07.mobi  
 TE_2017.01.14.pdf TE_2017.01.14.epub TE_2017.01.14.mobi  
 TE_2017.01.21.pdf TE_2017.01.21.epub TE_2017.01.21.mobi  
 TE_2017.01.28.pdf TE_2017.01.28.epub TE_2017.01.28.mobi  </description>
    </item>
    
    <item>
      <title>设备</title>
      <link>http://nituchao.com/device/</link>
      <pubDate>Sat, 18 Feb 2017 12:34:23 +0800</pubDate>
      
      <guid>http://nituchao.com/device/</guid>
      <description>工作以后，每年都会给自己买几件称心的电子设备，它们总是会给生活带来各种惊喜。
BOOX MAX 2016年底入手，13.3寸的电子墨水屏，Android系统，看PDF版的专业书的利器，另外它也支持MOBI，EPUB, TXT, DOC等常见文档格式。
Garmin Fenix 3HR 2016年初入手，当时是为了督促自己减肥，咬了咬牙买的，非常专业的运动手表，蓝宝石镜面，支持心率检测，支持GPS定位，做工精良。
Kindle Paperwhite 2 2015年初入手，6寸高分辨率电子墨水屏，自带背光灯，亚马逊原厂出品，看文史哲类的图书非常方便。
记得当时多看部门有个编辑工位在我边上，她手上有各种型号的Kindle设备，我看了非常喜欢，就果断入手了这款。中间还找多看的朋友给刷了多看系统。后来发现多看系统虽然方便，但是很多图书不能更改字体，于是又刷回来Kindle原生系统，而且Kindle原生系统经过几次大版本更新后，也越来越好用。希望这个设备能多用几年。
U-NAS Home NAS 2016年底入手，4盘位的家用NAS，自己配了一块西数4T红盘，运行的是群辉操作系统，整体还算稳定。现在，我把自己所有的照片，视频，文档，电子书等资料都保存在这台NAS上。
AOC U2879VF Display 2016年中入手，28寸4K显示器。当时自己DIY了一台基于华擎Z170-ITX小主板的机器，该主板有DP接口可以支持4K显示器，于是入手了这款显示器。电脑上安装了Mac OS X和Windows 10两个系统。Mac OS X对4K显示器的支持非常赞，文字和图片显示效果非常优秀。Windows 10对高分屏的支持一般，很多软件在使用过程中会出现很多显示问题。
MIWIFI MINI 小米路由器MINI，年会中的奖品，留着自用了。小米路由器给我最大的感受就是设置界面简洁易用，设计感很强。而且，能实时查看当前连接的设备信息，以及设备的网速状况。</description>
    </item>
    
    <item>
      <title>Paxos协议整理</title>
      <link>http://nituchao.com/post/2017/paxos-protocol/</link>
      <pubDate>Wed, 15 Feb 2017 10:13:27 +0800</pubDate>
      
      <guid>http://nituchao.com/post/2017/paxos-protocol/</guid>
      <description>Paxos是一种提高分布式系统容错性的一致性算法。
其算法描述如下：
阶段一 1，Proposer选择一个提案编号Mn，然后向Acceptor的某个超过半数的子集成员发送编号为Mn的Prepare请求。
2，如果一个Acceptor收到一个编号为Mn的Prepare请求，且编号Mn大于该Acctpor已经响应的所有Prepare请求的编号，那么它就会将它已经批准过的最大编号的提案作为响应反馈给Proposer，同时该Acceptor会承诺不会再批准任何编号小于Mn的提案。
举个例子来说，假定一个Acceptor已经响应过的所有Prepare请求对应的提案编号分别为1、2、&amp;hellip;、5和7，那么该Acceptor在接收一个编号为8的Prepare请求后，就会将编号为7的提案作为响应反馈给Proposer。
阶段二 1，如果Proposer收到来自半数以上的Acceptor对于其发出的编号为Mn的Prepare请求的响应，那么它就会发送一个针对[Mn, Vn]提案的Accept请求给Acceptor。注意，Vn的值就是收到的响应中编号最大的提案的值，如果响应中不包含任何提案，那么它就是任意值。
2，如果Acceptor收到这个针对[Mn, Vn]提案的Accept请求，只要改Acceptor尚未对编号大于Mn的Prepare请求作出响应，它就可以通过这个提案。
当然，在实际运行过程中，每一个Proposer都有可能会产生多个提案，但只要每个Proposer都遵循如何所述的算法运行，就一定能够保证算法执行的正确性。值得一提的是，每个Proposer都可以在任意时刻丢弃一个提案，哪怕针对该提案的请求和响应在提案被丢弃后会到达，但根据Paxos算法的一系列规约，依然可以保证其在提案选定上的正确性。事实上，如果某个Proposer已经在视图生成编号更大的提案，那么丢弃一些就的提案未尝不是一个好的选择。因此，如果一个Acceptor因为已经收到过更大编号的Prepare请求而忽略某个编号更小的Prepare或者Accept请求，那么它也应当通知其对应的Proposer，以便该Proposer也能够将该提案进行丢弃&amp;ndash;这和上面&amp;rdquo;算法优化&amp;rdquo;部分中提到的提案丢弃是一致的。
提案的获取 现在，我们再来看看如何让Learner获取提案，大体可以有以下几种方案。
方案一
Learner获取一个已经被选定的提案的前提是，该提案已经被半数以上的Acceptor批准。因此，最简单的做法就是一旦Acceptor批准了一个提案，就将该提案发送给所有的Leaner。
很显然，这种做法虽然可以让Leaner尽快地获取被选定的提案，但是却需要让每个Acceptor与所有的Leaner逐个进行一次通信，通信的次数至少为二者个数的乘积。
方案二
另一种可行的方案是，我们可以让所有的Acceptor将他们对提案的批准情况，统一发送给一个特定的Leaner(下文中我们将这样的Leaner称为&amp;rdquo;主Leaner&amp;rdquo;)，在不考虑拜占庭将军问题的前提下，我们假定Leaner之间可以通过消息通信来相互感知提案的选定情况。基于这样的前提，当主Leaner被通知一个提案已经被选定时，它会负责通知其他的Leaner。
这种方案中，Acceptor首先会将得到批准的提案发送给主Learner，再由其同步给其他Leaner，因此较方案一而言，方案二虽然需要多一个步骤才能将提案通知到所有的Leaner，但其通信次数却大大减少了，通常只是Acceptor和Learner的个数总和。但同时，该方案引入了一个新的不稳定因素：主Learner随时可能出现故障。
方案三
在讲解方案二的时候，我们提到，方案二最大的问题在于主Learner存在单点问题，即主Learner随时可能出现故障。因此，对方案二进行改进，可以将主Learner的范围扩大，即Acceptor可以将批准的提案发送给一个特定的Learner集合，该集合中的每个Learner都可以在一个提案被选定后通知所有其他的Learner。这个Learner集合中的Learner个数越多，可靠性就越好，但同时网络通信的复杂度也就越高。</description>
    </item>
    
    <item>
      <title>3PC协议整理</title>
      <link>http://nituchao.com/post/2017/three-phase-commit-protocol/</link>
      <pubDate>Wed, 15 Feb 2017 10:12:58 +0800</pubDate>
      
      <guid>http://nituchao.com/post/2017/three-phase-commit-protocol/</guid>
      <description>3PC，是Three-Phase Commit的缩写，即三阶段提交，是2PC的改进版，其将二阶段提交协议的&amp;rdquo;提交事务请求&amp;rdquo;过程一分为二，形成了由CanCommit、PreCommit和doCommit三个阶段组成的事务处理协议。
阶段一：CanCommit 1，事务询问
协调者向所有的参与者发送一个包含事务内容的canCommit请求，询问是否可以执行事务提交操作，并开始等待个参与者的响应。
2，各参与者向协调者反馈事务询问的响应
参与者在接收到来自协调者的canCommit请求后，正常情况下，如果其自身认为可以顺利执行事务，那么会反馈Yes响应，并进入预备状态，否则反馈No响应。
阶段二：PreCommit 在阶段二中，协调者会根据各参与者的反馈情况来决定是否可以进行事务的PreCommit操作，正常情况下，包含两种可能。
执行事务预提交
假设协调者从所有的参与者获得的反馈都是Yes响应，那么就会执行事务预提交。
1，发送预提交请求
协调者向所有参与者节点发出preCommit的请求，并进入Prepared阶段。
2，事务预提交
参与者接收到preCommit请求后，会执行事务操作，并将Undo和Redo信息记录到事务日志中。
3，各参与者向协调者反馈事务执行的响应
如果参与者成功执行事务操作，那么就会反馈给协调者Ack响应，同时等待最终的指令：提交(commit)或终止(abort)。
中断事务
假如任何一个参与者向协调者反馈了No响应，或者在等待超时之后，协调者尚无法接收到所有参与者的反馈响应，那么就会中断事务。
1，发送中断请求
协调者向所有参与者节点发出abort请求。
2，中断事务
无论是收到来自协调者的abort请求，或者是在等待协调者过程中出现超时，参与者都会中断事务。
阶段三：doCommit 该阶段将进行真正的事务提交，会存在以下两种可能的情况。
执行提交
1，发送提交请求
进入这一阶段，假设协调者处于正常工作状态，并且它接收到了来自所有参与者的Ack响应，那么它将从&amp;rdquo;预提交&amp;rdquo;状态转换到&amp;rdquo;提交&amp;rdquo;状态，并向所有的参与者发送doCommit请求。
2，事务提交
参与者接收到doCommit请求后，会正式执行事务提交操作，并在完成提交之后释放在整个事务执行期间占用的事务资源。
3，反馈事务提交结果
参与者在完成事务提交之后，相协调者发送Ack消息。
4，完成事务
协调者接收到所有参与者反馈的Ack消息后，完成事务。
中断事务
进入这一阶段，假设协调者处于正常工作状态，并且有任意一个参与者向协调者反馈了No响应，或者在等待超时之后，协调者尚无法接收到所有参与者的反馈响应，那么就会中断事务。
1，发送中断请求。
协调者向所有的参与者节点发送abort请求。
2，事务回滚。
参与者接收到abort请求后，会利用其在阶段二中记录的Undo信息来执行事务回滚操作，并在完成回滚之后释放在整个事务执行期间占用的资源。
3，反馈事务回滚结果。
参与者在完成事务回滚之后，向协调者发送Ack消息。
4，中断事务。
协调者接收到所有参与者反馈的Ack消息后，中断事务。
需要注意的是，一旦进入阶段三，可能会存在以下两种故障：
 协调者出现问题 协调者和参与者之间的网络出现故障。  无论出现哪种情况，最终都会导致参与者无法及时接收老子协调者的doCommit或者abort请求，针对这样的异常情况，参与者都会在等待超时之后，继续进行事务提交。
优缺点 三阶段提交协议的优点：相较于二阶段提交协议，三阶段提交协议最大的优点就是降低了参与者的阻塞范围，并且能够出现单点故障后继续达成一致。
三阶段提交协议的缺点：三阶段提交协议在去除阻塞的同时也引入了新的问题，那就是在参与者接收到preCommit消息后，如果网络出现分区，此时协调者所在的节点和参与者无法进行正常的网络通信，在这种情况下，该参与者依然会进行事务的提交，这必然出现数据不一致性。</description>
    </item>
    
    <item>
      <title>2PC协议整理</title>
      <link>http://nituchao.com/post/2017/two-phase-commit-protocol/</link>
      <pubDate>Wed, 15 Feb 2017 10:12:41 +0800</pubDate>
      
      <guid>http://nituchao.com/post/2017/two-phase-commit-protocol/</guid>
      <description>2PC，是Two-Phase Commit的缩写，即二阶段提交，是计算机网络尤其是在数据库领域内，为了使基于分布式系统架构下的所有节点在进行事务处理的过程中能够保持原子性和一致性而设计的一种算法。通常，二阶段提交协议也被认为是一种一致性协议，用来保证分布式系统数据的一致性。目前，绝大部分的关系型数据库都是采用二阶段提交协议来完成分布式事务处理的，利用该协议能够非常方便地完成所有分布式事务参与者的协调，统一决定事务的提交或回滚，从而能够有效地保证分布式数据一致性，因此二阶段提交协议被广泛地应用在许多分布式系统中。
协议说明 顾名思义，二阶段提交协议是将事务的提交过程分成了两个阶段来进行处理，其执行流程如下：
阶段一：提交事务请求 1，事务询问
协调者向所有的参与者发送事务内容，询问是否可以执行事务提交操作，并开始等待各参与者的响应。
2，执行事务
各参与者节点执行事务操作，并将Undo和Redo信息记入事务日志中。
3，各参与者向协调者反馈事务询问的响应。
如果参与者成功执行了事务操作，那么就反馈给协调者Yes响应，表示事务可以执行；如果参与者没有成功执行事务，那么就反馈给协调者No响应，表示事务不可以执行。
由于上面讲述的内容在形式上近似是协调者组织各参与者对一次事务操作的投标表态过程，因此二阶段提交协议的阶段一也被称为&amp;rdquo;投票阶段&amp;rdquo;，即各参与者投票表明是否要继续执行接下去的事务操作。
阶段二：执行事务提交 在阶段二，协调者会根据各参与者的反馈情况来决定最终是否可以进行事务提交操作，正常情况下，包含以下两种可能。
执行事务提交
加入协调者从所有的参与者获得的反馈都是Yes响应，那么就会执行事务提交。
1，发送提交请求。
协调者向所有参与者节点发出Commit请求。
2，事务提交。
参与者接收到Commit请求后，会正式执行事务提交操作，并在完成提交之后释放在整个事务执行期间占用的事务资源。
3，反馈事务提交结果。
参与者在完成事务提交之后，向协调者发送Ack消息。
4，完成事务。
协调者收到所有参与者反馈的Ack消息后，完成事务。
中断事务
假如任何一个参与者向协调者反馈了No响应，或者在等待超时之后，协调者尚无法接收到所有参与者的反馈响应，那么就会中断事务。
1，发送回滚请求
协调者向所有参与者节点发出Rollback请求。
2，事务回滚
参与者接收到Rollback请求后，会利用其在阶段一中记录的Undo信息来执行事务回滚操作，并在完成回滚后释放在整个事务执行期间占用的资源。
3，反馈事务回滚结果。
参与者在完成事务回滚之后，向协调者发送Ack消息。
4，中断事务
协调者接收到所有参与者反馈的Ack消息后，完成事务中断。
以上就是二阶段提交过程，前后两个阶段分别进行的处理逻辑。简单地讲，二阶段提交讲一个事务的处理过程分为了投票和执行两个阶段，其核心是对每个事务都采用先尝试后提交的处理方式，因此也可以将二阶段提交看做一个强一致性的算法。
优缺点 二阶段提交协议的优点：原理简单，实现方便。
二阶段提交协议的缺点：同步阻塞，单点问题，脑裂，太过保守。
同步阻塞
二阶段提交协议的最明显也是最大的一个问题就是同步阻塞，这会极大地限制分布式系统的性能。在二阶段提交的执行过程中，所有参与该事务操作的逻辑都处于阻塞状态，也就是说，各个参与者在等待其他参与者相应的额过程中，将无法进行其他任何操作。
单点问题
在上面的讲解过程中，相信读者可以看出，协调者的角色在整个二阶段提交协议中起到了非常重要的作用。一旦协调者出现问题，那么整个二阶段提交流程将无法运转，更为严重的是，如果协调者是在阶段二中出现问题的话，那么其他参与者将会一直处于锁定事务资源的状态中，而无法继续完成事务操作。
数据不一致
在二阶段提交协议的阶段二，即执行事务提交的时候，当协调者向所有的参与者发送Commit请求之后，发生了局部网络异常或者是协调者在尚未发送完Commit请求之前自身发生了崩溃，导致最终只有部分参与者收到了Commit请求。于是，这部分收到了Commit请求的参与者就会进行事务的提交，而其他没有收到Commit请求的参与者则无法进行事务提交，于是整个分布式系统便出现了数据不一致的现象。
太过保守
如果协调者指示参与者进行事务提交询问的过程中，参与者出现故障而导致协调者始终无法获取到所有参与者的相应信息的话，这时协调者只能依靠其自身的超时机制来判断是否需要中断事务，这样的策略显得比较保守。换句话说，二阶段提交协议咩有设计较为完善的容错机制，任意一个节点的失败都会导致整个事务的失败。</description>
    </item>
    
    <item>
      <title>MySQL提供的事务控制语句</title>
      <link>http://nituchao.com/post/2017/mysql-shi-wu-kong-zhi-yu-ju/</link>
      <pubDate>Tue, 14 Feb 2017 14:09:01 +0800</pubDate>
      
      <guid>http://nituchao.com/post/2017/mysql-shi-wu-kong-zhi-yu-ju/</guid>
      <description>在MySQL命令行的默认设置下，事务都是自动提交的，即执行SQL语句后就会马上执行COMMIT操作。因此要显式地开启一个事务需要使用命令BEGIN, START TRANSACTION, 或者执行命令SET AUTOCOMMIT=0, 禁用当前会话的自动提交。
每个数据库厂商自动提交的设置都会不相同，每个DBA或开发人员需要非常明白这一点，这对之后的SQL编程会有非凡的意义，因此用户不能以之前的经验来判断MySQL数据库的运行方式。
MySQL为开发者提供了三种类型的事务，分别是扁平化事务，带保存点的事务，链式事务。通过带保存点的事务还可以模拟实现嵌套事务。
START TRANSACTION | BEGIN 显式地开启一个事务。
COMMIT 要想使用这个语句的最简形式，只需要发出COMMIT。也可以更详细一点，写为COMMIT WORK, 不过这两者几乎是等价的。COMMIT会提交事务，并使得已对数据库做的修改称为永久性的。
ROLLBACK 要想使用这个语句的最简形式，只需要发出ROLLBACK。同样地，也可以写为ROLLBACK WORK，但两者几乎是等价的。回滚会结束用户的事务，并撤销正在进行的所有未提交的修改。
SAVEPOINT identity SAVEPOINT允许在事务中创建一个保存点，一个事务中可以有多个SAVEPOINT。
RELEASE SAVEPOINT identity 删除一个事务的保存点，当没有一个保存点执行这语句时，会抛出一个异常。
ROLLBACK TO [SAVEPOINT] identity 这个语句与SAVEPOINT命令一起使用。可以把事务回滚到标记点，而不回滚在此标记点之前的任何工作。
例如，可以发出两调UPDATE语句，后面跟一个SAVEPOINT, 然后又是两条DELETE语句。如果执行DELETE语句期间出现了某种异常情况，并且捕获到这个异常，同时发出了ROLLBACK TO SAVEPOINT命令，事务就会回滚到指定的SAVEPOINT，撤销DELETE完成的所有工作，而UPDATE语句完成的工作不受影响。
SET TRANSACTION 这个语句用来设置事务的隔离级别。
InnoDB存储引擎提供的事务隔离级别有：
 READ UNCOMMITED READ COMMITTED REPEATABLE READ SERIALIZABLE  START TRANSACTION, BEGIN语句都可以在MySQL命令行下显示地开启一个事务。但是在存储过程中，MySQL数据库的分析器会自动将BEGIN识别为BEGIN&amp;hellip;END, 因此在存储过程中只能使用START TRANSACTION语句来开启一个事务。
COMMIT和COMMIT WORK语句基本是一致的，都是用来提交事务。不同之处在于COMMIT WORK用来控制事务结束后的行为是CHAIN还是RELEASE的。如果是CHAIN方式，那么事务就变成了链事务。
用户可以通过参数completion_type来进行控制，该参数默认为0，表示没有任何操作。
当参数completion_type的值为1时，COMMIT WORK等同于COMMIT AND CHAIN, 表示马上自动开启一个相同隔离级别的事务。
当参数completion_type的值为2时，COMMIT WORK等同于COMMIT AND RELEASE, 在事务提交后会自动断开与服务器的连接。</description>
    </item>
    
    <item>
      <title>计算机</title>
      <link>http://nituchao.com/book/</link>
      <pubDate>Sun, 12 Feb 2017 17:51:45 +0800</pubDate>
      
      <guid>http://nituchao.com/book/</guid>
      <description>最近几年，大大小小的项目开发了不少，越来越觉得理论知识不够用，于是决心利用空余时间学习行业内的权威书籍。
这些列出来的书，都完整读过，有些在不同年份读过多次，也都一一列出。
Java    名称 作者 页数 评分 年份     Java虚拟机精讲 高翔龙 280 ※※※ 2016\2017   Effective Java中文版 俞黎敏 287 ※※※※ 2016   Java并发编程的艺术 方腾飞/魏鹏/程晓明 422 ※※※※ 2016\2017   Java并发编程实战 Brian Goetz/董云兰 293 ※※※ 2017   Java多线程编程核心技术 高洪岩 306 ※※※ 2016   Java 7并发编程实战手册 申邵勇/俞黎敏 339 ※※※ 2016   Spring揭秘 王福强 680 ※※※ 2016   Servlet 3.1 规范 穆茂强/张开涛 167 ※※※※ 2017   Netty权威指南 李林峰 572 ※※※※ 2015\2016    MySQL    名称 作者 页数 评分 年份     MySQL技术内幕 : InnoDB存储引擎 姜承尧 436 ※※※※ 2017   MySQL性能调优与架构设计 简朝阳 392 ※※※※ 2016   高性能MySQL Baron Schwartz/宁海元 764 ※※※※ 2017   高可用MySQL Charles Bell/宁青 680 ※※※※ 2017   Effective MySQL之备份与恢复 Ronald Bradford/张骏温 283 ※※※ 2017   Effective MySQL之SQL语句最优化 Ronald Bradford/李雪锋 201 ※※※ 2017   Effective MySQL之深入理解复制技术 Ronald Bradford/李雪锋 309 ※※※ 2017    Redis    名称 作者 页数 评分 年份     Redis设计与实现 黄建宏 388 ※※※※ 2017   Redis实战 Josiah L.</description>
    </item>
    
    <item>
      <title>JVM调试相关的配置参数</title>
      <link>http://nituchao.com/post/2016/jvm-tiao-shi-xiang-guan-de-pei-zhi-can-shu/</link>
      <pubDate>Thu, 29 Dec 2016 20:15:12 +0800</pubDate>
      
      <guid>http://nituchao.com/post/2016/jvm-tiao-shi-xiang-guan-de-pei-zhi-can-shu/</guid>
      <description>本文将详细分析JVM配置参数中，与调试相关的配置参数，这些配置参数将方便开发人员跟踪JVM运行，查看JVM日志等相关工作。</description>
    </item>
    
    <item>
      <title>JVM行为相关的配置参数</title>
      <link>http://nituchao.com/post/2016/jvm-xing-wei-xiang-guan-de-pei-zhi-can-shu/</link>
      <pubDate>Thu, 29 Dec 2016 13:53:12 +0800</pubDate>
      
      <guid>http://nituchao.com/post/2016/jvm-xing-wei-xiang-guan-de-pei-zhi-can-shu/</guid>
      <description>文本将分析与JVM行为相关的配置参数。</description>
    </item>
    
    <item>
      <title>JVM G1收集器配置参数</title>
      <link>http://nituchao.com/post/2016/jvm-g1-shou-ji-qi-pei-zhi-can-shu/</link>
      <pubDate>Thu, 29 Dec 2016 12:22:12 +0800</pubDate>
      
      <guid>http://nituchao.com/post/2016/jvm-g1-shou-ji-qi-pei-zhi-can-shu/</guid>
      <description>G1收集器配置参数</description>
    </item>
    
    <item>
      <title>JVM常用的非标准配置参数</title>
      <link>http://nituchao.com/post/2016/jvm-chan-yong-de-fei-biao-zhun-pei-zhi-can-shu/</link>
      <pubDate>Thu, 29 Dec 2016 10:18:12 +0800</pubDate>
      
      <guid>http://nituchao.com/post/2016/jvm-chan-yong-de-fei-biao-zhun-pei-zhi-can-shu/</guid>
      <description>本文将研究JVM常见常见的非标准配置参数。</description>
    </item>
    
    <item>
      <title>JVM性能相关的配置参数</title>
      <link>http://nituchao.com/post/2016/jvm-xing-neng-xiang-guan-de-pei-zhi-can-shu/</link>
      <pubDate>Thu, 29 Dec 2016 09:30:12 +0800</pubDate>
      
      <guid>http://nituchao.com/post/2016/jvm-xing-neng-xiang-guan-de-pei-zhi-can-shu/</guid>
      <description>本问将介绍JVM性能相关的配置参数。</description>
    </item>
    
    <item>
      <title>JVM配置参数-X与-XX的区别</title>
      <link>http://nituchao.com/post/2016/jvm-options-x-vs-xx/</link>
      <pubDate>Wed, 28 Dec 2016 13:14:12 +0800</pubDate>
      
      <guid>http://nituchao.com/post/2016/jvm-options-x-vs-xx/</guid>
      <description>启动JVM时通过指定配置参数来指导虚拟机按照我们的要求提供服务，这一点对大多数的Java程序员来说已经是司空见惯。
在指定配置参数时，会有-X和-XX两种形式，那么它们两者有什么区别呢，今天我想借这篇文章总结一下。
下面是我们的某个Java项目在正式环境上启动JVM时的一个典型命令，在该命令中指定了各种启动参数：
java -Xmx15G \ -Xms10G \ -Xmn3G \ -Xss512k \ -XX:MaxPermSize=512M \ -XX:PermSize=512M \ -XX:+PrintFlagsFinal \ -XX:MaxTenuringThreshold=1 \ -XX:SurvivorRatio=23 \ -XX:TargetSurvivorRatio=80 \ -Xnoclassgc \ -XX:+UseParNewGC \ -XX:+UseConcMarkSweepGC \ -XX:CMSInitiatingOccupancyFraction=80 \ -XX:ParallelGCThreads=24 \ -XX:ConcGCThreads=24 \ -XX:+CMSParallelRemarkEnabled \ -XX:+CMSScavengeBeforeRemark \ -XX:+ExplicitGCInvokesConcurrent \ -XX:+UseTLAB \ -XX:TLABSize=64K, -verbose:gc \ -XX:+PrintGCDetails \ -XX:+PrintGCDateStamps \ -XX:+PrintGCTimeStamps \ -XX:+PrintGCApplicationStoppedTime \ -Xloggc:./gc.log  Java HotSpot VM的官方文档中将启动参数分为如下两类：
   配置 参数 类型 说明 举例     -X non-standard 非标准参数。这些参数不是虚拟机规范规定的。因此，不是所有VM的实现(如:HotSpot,JRockit,J9等)都支持这些配置参数。 -Xmx、-Xms、-Xmn、-Xss   -XX not-stable 不稳定参数。这些参数是虚拟机规范中规定的。这些参数指定虚拟机实例在运行时的各种行为，从而对虚拟机的运行时性能有很大影响。 -XX:SurvivorRatio、-XX:+UseParNewGc    补充: -X和-XX两种参数都可能随着JDK版本的变更而发生变化，有些参数可以能会被废弃掉，有些参数的功能会发生改变，但是JDK官方不会通知开发者这些变化，需要使用者注意。</description>
    </item>
    
    <item>
      <title>Java通过信号量机制实现生产者消费者</title>
      <link>http://nituchao.com/post/2016/java-xin-hao-liang-ji-zhi-shi-xian-sheng-chan-zhe-xiao-fei-zhe/</link>
      <pubDate>Tue, 27 Dec 2016 16:12:12 +0800</pubDate>
      
      <guid>http://nituchao.com/post/2016/java-xin-hao-liang-ji-zhi-shi-xian-sheng-chan-zhe-xiao-fei-zhe/</guid>
      <description>信号量是一种计数器，用来保护一个或者多个共享资源的访问。Java提供了Semaphore类来实现信号量机制。
如果线程要访问一个共享资源，它必须先获得信号量。如果信号量的内部计数器大于0，信号量将减1，然后允许访问这个共享资源。计数器大于0意味着有可以使用的资源，因此线程将被允许使用其中一个资源。
否则，如果信号量的计数器等于0，信号量将会把线程置入休眠直至计数器大于0.计数器等于0的时候意味着所有的共享资源已经被其他线程使用了，所以需要访问这个共享资源的线程必须等待。
当线程使用完某个共享资源时，信号量必须被释放，以便其他线程能够访问共享资源。释放操作将使信号量的内部计数器增加1。
设计思想 为了使用信号量机制来实现生产者VS消费者模型，我们需要实例化一个二进制信号量对象，即内部计数器只有0和1两个值。多个生产者线程和多个消费者线程竞争这个信号量来互斥访问共享缓冲区。
另外，由于共享缓冲区是有空间限制的，生产者在生产前要判断共享缓冲区空间是否充足。消费者在消费前要判断共享缓冲区内的元素是否足够消费。
代码实现 基于上面的设计思想，我们需要实现共享缓冲区，生产者线程，消费者线程和主程序四部分。
共享缓冲区
package com.nituchao.jvm.prosumer.semaphore; import java.util.ArrayList; import java.util.List; import java.util.concurrent.Semaphore; /** * 缓冲区 * Created by liang on 2016/12/29. */ public class Buffer { private int MAX_SIZE = 100; private final List&amp;lt;String&amp;gt; list; private final Semaphore semaphore; public Buffer() { this.list = new ArrayList&amp;lt;&amp;gt;(); this.semaphore = new Semaphore(1); } /** * 生产Buffer元素 * * @param num */ public boolean BufferProduct(int num) { boolean result = true; try { // 获取信号量 semaphore.</description>
    </item>
    
    <item>
      <title>Java通过重入锁实现生产者消费者</title>
      <link>http://nituchao.com/post/2016/java-chong-ru-suo-shi-xian-sheng-chan-zhe-xiao-fei-zhe/</link>
      <pubDate>Tue, 27 Dec 2016 16:12:12 +0800</pubDate>
      
      <guid>http://nituchao.com/post/2016/java-chong-ru-suo-shi-xian-sheng-chan-zhe-xiao-fei-zhe/</guid>
      <description>ReentrantLock是一个可重入的互斥锁，又被称为&amp;rdquo;独占锁&amp;rdquo;，ReentrantLock锁在同一个时间点只能被一个线程锁持有，而可重入的意思是，ReentrantLock可以被单个线程多次获取，ReentrantLock的性能并不高，优点是比价灵活。ReentrantLock比Synchronized关键词更加灵活，并且能支持条件变量，后面我还会单独介绍使用条件变量实现生产者消费者模型的方法。
设计思想 本文希望同ReentrantLock来实现一个共享缓冲区，生产者线程和消费者线程通过该共享缓冲区来实现相关的生产和消费操作，每个线程对共享缓冲区的访问是互斥的。
另外，由于共享缓冲区是有空间限制的，生产者在生产前要判断共享缓冲区空间是否充足。消费者在消费前要判断共享缓冲区内的元素是否足够消费。
代码实现 根据上面的设计思想，我们需要实现共享缓冲区，生产者线程，消费者线程，主程序等四个部分。
共享缓冲区
package com.nituchao.jvm.prosumer.reentrant; import java.util.ArrayList; import java.util.List; import java.util.concurrent.locks.Lock; import java.util.concurrent.locks.ReentrantLock; /** * 共享缓冲区 * Created by liang on 2016/12/30. */ public class Buffer { private final List&amp;lt;String&amp;gt; list; private int MAX_SIZE = 10; private final Lock lock; public Buffer() { this.list = new ArrayList&amp;lt;String&amp;gt;(); this.lock = new ReentrantLock(); } /** * 生产num个元素 * * @param num * @return */ public boolean bufferProduct(int num) { boolean result = true; try { lock.</description>
    </item>
    
    <item>
      <title>Java通过阻塞队列实现生产者消费者</title>
      <link>http://nituchao.com/post/2016/java-zu-se-dui-lie-shi-xian-sheng-chan-xiao-fei-zhe/</link>
      <pubDate>Tue, 27 Dec 2016 16:10:12 +0800</pubDate>
      
      <guid>http://nituchao.com/post/2016/java-zu-se-dui-lie-shi-xian-sheng-chan-xiao-fei-zhe/</guid>
      <description>Java通过阻塞队列实现生产者消费者。</description>
    </item>
    
    <item>
      <title>Java通过条件变量实现生产者消费者</title>
      <link>http://nituchao.com/post/2016/java-tiao-jian-bian-liang-shi-xian-sheng-chan-zhe-xiao-fei-zhe/</link>
      <pubDate>Tue, 27 Dec 2016 16:00:12 +0800</pubDate>
      
      <guid>http://nituchao.com/post/2016/java-tiao-jian-bian-liang-shi-xian-sheng-chan-zhe-xiao-fei-zhe/</guid>
      <description>Java通过条件变量来实现生产者消费者。</description>
    </item>
    
    <item>
      <title>Java通过读写锁实现生产者消费者</title>
      <link>http://nituchao.com/post/2016/java-du-xie-suo-shi-xian-sheng-chan-zhe-xiao-fei-zhe/</link>
      <pubDate>Tue, 27 Dec 2016 15:12:12 +0800</pubDate>
      
      <guid>http://nituchao.com/post/2016/java-du-xie-suo-shi-xian-sheng-chan-zhe-xiao-fei-zhe/</guid>
      <description>Java通过读写锁实现生产者消费者。</description>
    </item>
    
    <item>
      <title>Java通过对象同步机制实现生产者消费者</title>
      <link>http://nituchao.com/post/2016/java-dui-xiang-suo-shi-xian-sheng-chan-zhe-xiao-fei-zhe/</link>
      <pubDate>Tue, 27 Dec 2016 12:54:28 +0800</pubDate>
      
      <guid>http://nituchao.com/post/2016/java-dui-xiang-suo-shi-xian-sheng-chan-zhe-xiao-fei-zhe/</guid>
      <description>每个Java类都是从Object类派生出来的，Object类原生提供了wait(),notify(),notifyAll()等方法来实现线程间的同步控制。
进一步讲，每个对象都能当做一个锁，每个对象也能当做一个条件队列，对象中的wait(), notify(), notifyAll()方法构成了内部条件队列的API，而队列正是生产者消费者模型的一个关键元素。当对象调用wait()方法时，当前线程会释放获得的对象锁，同时，当前对象会请求操作系统挂起当前线程，此时对象的对象锁就可用了，允许其他等待线程进入。当对象调用notify()或者notifyAll()方法时，当前线程也会释放获得的对象锁，同时，操作系统会结束当前线程的执行，并从阻塞在该对象上的线程列表中选择一个进行唤醒，该线程会获得对线锁并被让操作系统调度。
设计思想 为了设计基于Java对象同步机制的生产者消费者程序，并且是多个生产者线程VS多个消费者线程，可以从以下三点出发。
首先，我们需要有一个缓冲区来充当生产者和消费者之间交换数据的媒介，这个缓冲区可以是一个普通的列表对象，我们在该列表对象上进行生产者和消费者的互斥访问控制。本质上讲，这个缓冲器就相当于一个队列，一方面允许生产者往里面添加数据，一方面允许消费者从里面取走数据。这个列表对象非常重要，所有的wait()和notify()操作以及对象锁的控制都是针对该对象的。因此，这是一个共享对象，在各个生产者线程和消费者线程之间充当媒介。
其次，我们需要有若干个生产者线程。生产者线程要争夺缓冲区对象锁，如果未得到锁则wait()进入阻塞等待被唤醒。如果得到了对象锁，还要判断缓冲区是否已满。如果缓冲区已满，则要wait()进入阻塞等待被唤醒，并释放缓冲区对象锁。如果缓冲区未满，则可以进行生产活动，结束后释放缓冲区对象锁，并唤醒一个阻塞的线程。
最后，我们需要有若干个消费者线程。消费者线程要争夺缓冲区对象锁，如果未得到锁则wait()进行阻塞等待被唤醒。如果得到了对象锁，还要判断缓冲区里的元素是否满足自己的需要。如果缓冲区里的元素不够自己消费，则要wait()进入阻塞等待被唤醒，并释放缓冲区对象锁。如果缓冲区里的元素满足自己的需要，则进行消费操作，结束后释放缓冲区对象锁，并唤醒一个阻塞的线程。
代码实现 基于上面的设计，我们需要实现共享缓冲区，生产者线程，消费者线程和主程序四部分。
共享缓冲区
package com.nituchao.jvm.prosumer.objectsync; import java.util.Date; import java.util.LinkedList; /** * 共享缓冲区 * Created by liang on 2016/12/15. */ public class Buffer { private static final int MAX_SIZE = 100; private LinkedList&amp;lt;String&amp;gt; list; public Buffer(LinkedList&amp;lt;String&amp;gt; list) { this.list = list; } /** * 生产n个产品 * * @param num * @throws InterruptedException */ public void BufferProduce(int num) throws InterruptedException { synchronized (list) { while (list.</description>
    </item>
    
    <item>
      <title>Java通过Exchange机制实现生产者消费者</title>
      <link>http://nituchao.com/post/2016/java-exchange-shi-xian-sheng-chan-zhe-xiao-fei-zhe/</link>
      <pubDate>Sat, 26 Nov 2016 22:17:12 +0800</pubDate>
      
      <guid>http://nituchao.com/post/2016/java-exchange-shi-xian-sheng-chan-zhe-xiao-fei-zhe/</guid>
      <description>Java并发API提供了一个同步辅助类&amp;mdash;Exchanger，它允许并发线程之间交换数据。具体来说，Exchanger类允许在两个线程之间定义同步点(Synchronization Point)。当两个线程都达到同步点时，它们交换数据结构，因此第一个线程的数据结构进入到第二个线程中，同时第二个线程的数据结构进入到第一个线程。
生产者VS消费者模型本质上就是两个线程交换数据。因此，对于只有一个生产者和一个消费者的场景，就可以使用Exchanger类。
设计思想 为了通过Exchanger类实现生产者VS消费者模型，我们在设计的时候需要考虑以下三点：
1, 生产者线程和消费者线程需要各自持有一个自己的缓冲区对象。
2, 生产者线程和消费者线程需要持有一个共同的Exchanger对象，通过该对象实现两个线程的同步和数据结构交换。
3, 消费者每次交换前，需要清空自己的数据结构，因为消费者不需要给生产者传递数据。
代码实现 基于上面的设计，分别实现了生产者线程，消费者线程，主程序。
生产者线程
package com.nituchao.jvm.prosumer.exchanger; import java.util.List; import java.util.concurrent.Exchanger; /** * 生产者 * Created by liang on 2016/11/26. */ public class BufferProducer implements Runnable { private List&amp;lt;String&amp;gt; buffer; private final Exchanger&amp;lt;List&amp;lt;String&amp;gt;&amp;gt; exchanger; public BufferProducer(List&amp;lt;String&amp;gt; buffer, Exchanger&amp;lt;List&amp;lt;String&amp;gt;&amp;gt; exchanger) { this.buffer = buffer; this.exchanger = exchanger; } @Override public void run() { // 循环10次数据交换 int cycle = 1; for (int i = 0; i &amp;lt; 10; i++) { System.</description>
    </item>
    
    <item>
      <title>关于</title>
      <link>http://nituchao.com/about/</link>
      <pubDate>Thu, 11 Feb 2016 12:34:23 +0800</pubDate>
      
      <guid>http://nituchao.com/about/</guid>
      <description>姓名：张亮
职业：软件工程师
简介：一直在从事Java服务器端的相关工作，不断涉猎计算机相关的各个领域。
喜欢辩证法，喜欢发展地看问题，时间能改变一切。
看过很多书，也忘掉很多书，接着看很多书。
浪过15年股市，还挣了钱。
英雄联盟只钟爱剑圣，四杀一大把，五杀还没有，一秒七刀⑥到没朋友。
锵锵三人行、晓松奇谈、嘟嘟。
烤鱼，重庆小面，黄焖鸡，岐山臊子面。
Fenix 3 HR可以戴十年。
Kindle Paperwhite 3, BOOX MAX 13.3, Synology, 28&amp;rdquo; 4K Display
德普入门
May the force be with you</description>
    </item>
    
    <item>
      <title>MySQL数据类型之实数</title>
      <link>http://nituchao.com/post/2014/mysql-shu-ju-lei-xing-zhi-shi-shu/</link>
      <pubDate>Fri, 12 Sep 2014 10:30:00 +0800</pubDate>
      
      <guid>http://nituchao.com/post/2014/mysql-shu-ju-lei-xing-zhi-shi-shu/</guid>
      <description>Mysql使用浮点数类型和定点数类型来表示小数。浮点数类型包括单精度浮点数(FLOAT类型)和双精度浮点数(DOUBLE类型)。定点数类型就是DECIMAL型。
实数有分数部分。然而，它们并不仅仅是分数。可以使用DECIMAL保存比BIGINT还大的整数。MySQL同时支持精确与非精确类型。
FLOAT和DOUBLE类型支持使用标准的浮点运算进行近似计算。如果想知道浮点运算到底如何进行，则要研究平台浮点数的具体实现。
DECIMAL类型用于保存精确的小数。在MySQL5.0及以上版本，DECIMAL类型支持精确的数学运算。MySQL4.1和早期版本对DECIMAL值执行浮点运算，它会因为丢失精度而导致奇怪的结果。在这些MySQL版本中，DECIMAL仅仅是“存储类型”。
在MySQL5.0及以上版本中，服务器进行了DECIMAL运算，因为CPU并不支持对它进行直接计算。浮点运算会快一点，因为计算直接在CUP上进行。
可以定义浮点类型和DECIMAL类型的精度。对于DECIMAL列，可以定义小数点之前和之后的最大位数，这影响了所需的存储空间。MySQL5.0和以上版本把数字保存到了一个二进制字符串中(每个4字节保存9个数字)。例如，DECIMAL(18,9)将会在小数点前后都保存9位数字，总共使用9个字节: 小数点前4个字节，小数点占一个字节，小数点后4个字节。
MySQL5.0及以上版本中的DECIMAL类型最多允许65个数字。在较早的版本中，DECIMAL最多可以有254个数字，并且保存为未压缩的字符串(一个数字占一个字节)。然而，这些版本的MySQL根本不能在计算中使用如此大的数字，因为DECIMAL只是一种存储格式。DECIMAL在计算时会被转换为DOUBLE类型。
可以用多重方式定义浮点数列的精度，它会导致MySQL悄悄采用不同的数据类型，或者在保存的时候进行圆整。这些精度定义符不是标准的，因此我们建议定义需要的类型，而不是精度。
比起DECIMAL类型，浮点类型保存同样大小的值使用的空间通常更少。FLOAT占用4个字节。DOUBLE 占用8个字节，而且精度更高，范围更大。和整数一样，你选择的仅仅是存储类型。MySQL在内部对浮点类型使用DOUBLE进行计算。
由于需要额外的空间和计算开销，只有在需要对小数进行精确计算的时候才使用DECIMAL，比如保存金融数据。</description>
    </item>
    
    <item>
      <title>MySQL数据类型之整数</title>
      <link>http://nituchao.com/post/2014/mysql-shu-ju-lei-xing-zhi-zheng-shu/</link>
      <pubDate>Fri, 12 Sep 2014 10:20:00 +0800</pubDate>
      
      <guid>http://nituchao.com/post/2014/mysql-shu-ju-lei-xing-zhi-zheng-shu/</guid>
      <description>数字有两种类型：整数(Whole Number)和实数(Real Number)。
如果存储整数，就可以使用这几种整数类型：
 TINYINT : 8位, [-128, 127]。 SMALLINT : 16位, [-65536, 65535]。 MEDIUMINT : 24位, [-16777216, 16777215]。 INT : 32位, [-4294967296, 4294967295]。 BIGINT : 64位, [-1.84467440737096E19 + 1, 1.84467440737096E19]。  整数类型有可选的UNSIGNED属性，表示不允许负数，并大致把正上限提高了一倍。
MySQL还可以对整数类型的定义宽度，比如INT(11)。这对于大多数应用程序都是没有意义的：它不会限制值的范围，只规定了MySQL的交互工具(例如，命令行客户端)来显示字符的个数。对于存储和计算，INT(1)和INT(20)是一样的。
提示：
 Falcon 存储引擎和MSQLAB提供的其他存储引擎内部存储整数的机制是不同的。用户不能控制存储数据的实际大小。第三方存储引擎，例如Brighthouse，也有自己的存储过时和压缩方法。
 </description>
    </item>
    
    <item>
      <title>Mac OS Mavericks下安装单机版Hadoop</title>
      <link>http://nituchao.com/post/2014/macos-an-zhuang-hadoop/</link>
      <pubDate>Fri, 15 Aug 2014 17:17:17 +0800</pubDate>
      
      <guid>http://nituchao.com/post/2014/macos-an-zhuang-hadoop/</guid>
      <description>以下记录了我在Mac OS Mavericks下安装单机版Hadoop的经历。中间遇见了好多在Linux上没有遇到过的错误，尤其是因为主机名(HostName)等网络设置导致各种错误，真是太考验耐心了，不过，最后总算是跑起来了～～
一、计算机配置如下 二、软件版本 1.Java版本，使用OS系统自带的就可以 java version &amp;quot;1.6.0_65&amp;quot; Java(TM) SE Runtime Environment (build 1.6.0_65-b14-462-11M4609) Java HotSpot(TM) 64-Bit Server VM (build 20.65-b04-462, mixed mode)  2.SSH版本，使用系统自带的就可以 OpenSSH_6.2p2, OSSLShim 0.9.8r 8 Dec 2011 Bad escape character &#39;rsion&#39;.  3.Hadoop版本 hadoop.1.0.3.tar.gz  三、安装过程 1.安装Java 看过很多教程，都推荐用Java 1.6版本，系统自带的就可以，使用以下命令查看Java版本
$java -version  2.安装SSH Mac OS X自带了Open-SSH不用再手动安装。接下来设置SSH免密码登录。
 使用以下命令生成RSA私钥和公钥(如果已经生成过的，请跳过)  $ssh-keygen -t rsa -P &amp;quot;&amp;quot; –f $HOME/.ssh/id_rsa   将公钥内容添加到authorized_keys列表里(如果已经添加过的，请跳过)  $cat $HOME/.ssh/id_rsa.pub &amp;gt;&amp;gt; $HOME/.ssh/authorized_keys   测试登录  $ssh localhost $ssh USERNAME@HOST_NAME  _ps:USERNAME表示用户名，HOSTNAME表示主机名</description>
    </item>
    
    <item>
      <title>服务器端与客户端加密通信设计</title>
      <link>http://nituchao.com/post/2014/fu-wu-duan-yu-ke-hu-duan-jia-mi-tong-xin-she-ji/</link>
      <pubDate>Sat, 12 Jul 2014 19:19:00 +0800</pubDate>
      
      <guid>http://nituchao.com/post/2014/fu-wu-duan-yu-ke-hu-duan-jia-mi-tong-xin-she-ji/</guid>
      <description>最近的一个项目涉及到服务器与Android客户端交换一些敏感数据，这部分数据必须要经过安全加密后才能在Android与服务器间传递，然后再解密后进行相关的业务操作，而且要做到，即使客户端被恶意反编译，已经发送的数据也不会被破解。
我们首先想到的是对称加密算法AES和DES,但是，如果客户端被恶意反编译，客户端写死的密钥就会被拿到，已经发送的数据就很容易被破解了，因此，安全上，对称加密不满足我们的需求。
我们很快想到了非对称加密算法RSA，即使黑客拿到了客户端的公钥，没有私钥还是无法破解已经发送的数据包，但是，RSA算法速度非常慢，而且一次最多加密128位的数据，虽然安全上满足需求，速度和操作复杂度上还是存在一些硬伤。
于是，我们的解决办法是联合使用RSA和AES算法，具体的做法是，客户端提交的正文内容使用AES加密，AES加密时的密钥由客户端随机生成，然后把随机生成的密钥使用RSA算法加密后与正文内容加密后的密文一起提交给服务器端，服务器端先用自己的RSA私钥解密AES算法的密钥，然后用AES算法配合解密出的密钥解密正文内容。
交互过程 客户端提交内容如下:
 { msgkey: &amp;quot;f7l1mKVA3TVUf9F/lUIM30bzHG+PxXEOoO3vZ0N8ulsyPu8IaO/wmKAlOqUyIHwLtQnCOU2&amp;quot;, msgtxt: &amp;quot;MuoJ+HrOJzneiFwvBcOV8loBhRS0LjbmRyWkvSs0C2w=&amp;quot; }  其中：
 msgtxt是客户端提交的正文内容经过AES算法加密后的密文，AES加密时的密钥key由客户端随机生成。 msgkey是AES算法加密时用到的密钥key经过客户端RSA算法加密后的密文，RSA加密时的公钥由服务器端提供并固定内置的客户端。  以下是交互图:
RSA工具类 以下是我们用到的RSA加密/解密算法，该算法服务器端和客户端必须同时使用:
package com.xiaomi.miui.sec.common; import java.io.FileInputStream; import java.io.FileOutputStream; import java.io.ObjectInputStream; import java.io.ObjectOutputStream; import java.math.BigInteger; import java.security.KeyFactory; import java.security.KeyPair; import java.security.KeyPairGenerator; import java.security.NoSuchAlgorithmException; import java.security.interfaces.RSAPrivateKey; import java.security.interfaces.RSAPublicKey; import java.security.spec.RSAPrivateKeySpec; import java.security.spec.RSAPublicKeySpec; import java.util.HashMap; import javax.crypto.Cipher; /** * RSA工具类 * Created by liang on 7/9/14. */ public class RSAUtils { /** * 生成公钥和私钥 * * @throws NoSuchAlgorithmException */ public static HashMap&amp;lt;String, Object&amp;gt; getKeys() throws NoSuchAlgorithmException { HashMap&amp;lt;String, Object&amp;gt; map = new HashMap&amp;lt;String, Object&amp;gt;(); KeyPairGenerator keyPairGen = KeyPairGenerator.</description>
    </item>
    
    <item>
      <title>终端Session管理工具整理</title>
      <link>http://nituchao.com/post/2014/byobu-kuai-jie-jian-zheng-li/</link>
      <pubDate>Tue, 24 Jun 2014 15:19:00 +0800</pubDate>
      
      <guid>http://nituchao.com/post/2014/byobu-kuai-jie-jian-zheng-li/</guid>
      <description> Tmux 2017年2月22日更新
最近一直在用Tmux作为默认的终端Session管理工具。Tmux可以轻松的完成窗口创建，屏幕切分，文本模式，命令行模式等功能。
最让我满意的是多屏幕的同步操作功能。每次需要ssh到服务器查看日志时，我会将屏幕切割成四块，分别登陆到4个服务器上，然后开启sync模式，这样输入的命令将同时在4台服务器上一起执行，大大提高了操作效率。
Tmux的Session支持后台运行，可以通过attache随时进入Tmux，并立即恢复工作状态。
同步操作 Byoby byoby是Ubuntu团队开发的screen的替代产品，支持session管理，屏幕切分，SSH管理。配置和使用也非常简单，一直是我非常喜欢的系统Terminal的替代产品，大赞。
帮助菜单 </description>
    </item>
    
    <item>
      <title>逐浪者必将永生</title>
      <link>http://nituchao.com/post/2014/lang-chao-zhi-dian-you-gan/</link>
      <pubDate>Sun, 22 Jun 2014 13:32:00 +0800</pubDate>
      
      <guid>http://nituchao.com/post/2014/lang-chao-zhi-dian-you-gan/</guid>
      <description>《浪潮之巅》是Google黑板报里的一个系列，我从两年前第一次看到吴军的这个连载文章，当时也是一下子就被吸引住了，因为我了解到了一个更加真实，残酷，同时充满生机的信息技术产业。
记得当时读的第一篇是《“水果”公司的复兴–传奇小子》，讲的是乔布斯的硅谷传奇人生，然后我就一发不可收拾，一口气读完了所有的章节，从AT&amp;amp;T到IBM，再到MOTO，苹果，微软，雅虎，一直到现在的Google，计算机产业的发展史让我的观念发生了很大的变化。
为什么说IT领域非常残酷呢。信息技术从20世纪70年代走出实验室，紧接着走入寻常人家到现在只不过短短的40年，在段时间里，有很多公司取得了成功，通常在短短的时间里就迅速发展成为巨无霸企业，比如苹果，微软。但是，不可否认的是，在IT领域没有永远的赢家，比如当年牛气冲天的AT&amp;amp;T，后来硬是被分拆，最终走向了没落，AT&amp;amp;T名下最有名的贝尔实验室(发明了C语言，UNIX操作系统)曾是无数科学家心中的天堂，但是也随之被分拆，走向没落。再比如， 摩托罗拉，一个没落的贵族，也是还记得我的第一部手机就是MOTO V3IE，当年最薄的手机，贝克汉姆亲自给做的广告，但也阻止不了他在几年内迅速没落，最终被后起之秀GOOGLE收购，至今我听到”Hello MOTO”还有些许的伤感…
另外，IT领域更是充满了活力和机会。在21世纪，信息技术发展迅速，新技术层出不穷，新的理念也不断推出，信息技术造就了诸如Apple，Google，Facebook这样的科技巨头，更是造就了诸如比尔盖茨这样的科技界的拿破仑。能进入这样的一个快速发展而又充满机会的行业我真的感到非常自豪。
另外，我有一些体会，我有个同学现在在读化学材料方面的研究生，通过与他的交流，我发现他们学习的专业其实发展非常缓慢，诸如水泥的配方之类的东西几十年不会变，而且这些技术通常也被国外垄断，因此他们能做的事情本身就非常少，他有个同学找了工作，在一个厂子里，没多少事情做，厂里的领导不舍得让这些本科生下车间，但又没有多少技术活交给他们做，于是他们几乎每天都在办公室里闲着，拿死工资，然后等着拿养老金…
王小波说我们的人生终将走向平庸(结婚生子就是走向平庸？)，但是话说回来，我们更应该珍惜青春，来做一些更具价值的事情，而信息技术(IT)恰恰能够为我们提供这个机会，信息技术就是生产力，我们可以竭尽全力掌握这一生产力，做一些真正能产生影响力的事情。 最后引用《浪潮之巅》里的一段话结个尾:
 计算机产业发展更新速度极快，历史上产生了一个又一个IT帝国，这些帝国经历了短暂的辉煌后总会被时代的浪潮退下巅峰，然后是新的时代宠儿被推上浪潮的巅峰。
 </description>
    </item>
    
    <item>
      <title>Emacs常用快捷键</title>
      <link>http://nituchao.com/post/2014/emacs-shot-key/</link>
      <pubDate>Fri, 04 Apr 2014 09:19:00 +0800</pubDate>
      
      <guid>http://nituchao.com/post/2014/emacs-shot-key/</guid>
      <description> 复制粘贴  复制: Option + W 剪切: Ctrl + W 粘贴: Ctrl + Y 选中区域: Ctrl + Shift + 2/Ctrl + Space  </description>
    </item>
    
    <item>
      <title>Apache CXF解析Map/HashMap</title>
      <link>http://nituchao.com/post/2013/apache-cxf-parse-hash-map/</link>
      <pubDate>Wed, 11 Dec 2013 14:06:00 +0800</pubDate>
      
      <guid>http://nituchao.com/post/2013/apache-cxf-parse-hash-map/</guid>
      <description>项目中WebService框架用的是Apache CXF，但是在使用中发现Apache CXF不支持解析Map和HashMap，而且SOAP报文(XML)和JavaBean的转化是通过JAXB实现的，没办法，自己写了个Map到XML的适配器，来实现两者的转化。
Map适配器 MapAdapter用来完成Java的Map类型与XML中对应节点的转换。
以MapAdatper为中心，一边是XML类型的SOAP报文，一边是以HashMap为元素的list列表。通过以下两个方法完成双向转换:
 unmarshal: 完成XML到JAVA的转换。 marshal: 完成JAVA到XML的转换。  该适配器会通过注解在具体的实体类上指定。
import java.util.HashMap; import java.util.Map; import javax.xml.bind.annotation.adapters.XmlAdapter; /** * Map适配器，完成Java中map与XML中对应节点的转换 * * &amp;lt;p&amp;gt; * detailed comment * @author zWX184091 2013-8-15 * @see * @since 1.0 */ public class MapAdapter extends XmlAdapter&amp;lt;MapConvertor, HashMap&amp;lt;String, String&amp;gt;&amp;gt; { /** * XML to JAVA * * @param map * @return HashMap&amp;lt;String, String&amp;gt; * @throws Exception */ @Override public HashMap&amp;lt;String, String&amp;gt; unmarshal(MapConvertor map) throws Exception { // TODO Auto-generated method stub HashMap&amp;lt;String, String&amp;gt; result = new HashMap&amp;lt;String, String&amp;gt;(); // 遍历MapConvertor，将XML节点内容写入JavaBean Map对象 for (MapConvertor.</description>
    </item>
    
    <item>
      <title>KK编辑器</title>
      <link>http://nituchao.com/kk/</link>
      <pubDate>Tue, 10 Dec 2013 12:34:23 +0800</pubDate>
      
      <guid>http://nituchao.com/kk/</guid>
      <description> 截图 源码  Github源码  下载  kk for windows 32bit  介绍  这是一个Markdown编辑器，通过QT实现，可以跨平台编译，支持Windows，Linux，Mac OS。  界面  markplus的图形用户界面是实用QT实现的，提供编辑，预览，分栏三种模式，界面是自定义的，包括 自定义缩放 自定义拖动 自定义标题栏 自定义快捷菜单 自定义背景样式  Google V8 Engine  markplus内置了一个Goolge Javascrip V8 Engine 的实例，以动态链接库的形式调用，来执行Js脚本，完成markdow语法的解析。 主页  Markd.js  markplus对markdown语法的解析是通过markd来完成的,markd是一个开源的Markdow Js实现，效率很高。 主页  Sqllite3  markplus的数据库使用的是sqllite3。 主页  Log4cpp  日志使用的是log4cpp 主页  License  GPL (GNU GENERAL PUBLIC LICENSE) 主页  </description>
    </item>
    
    <item>
      <title>换个角度看西游的故事</title>
      <link>http://nituchao.com/post/2012/zhu-jiu-tan-xi-you-you-gan/</link>
      <pubDate>Fri, 22 Jun 2012 22:23:00 +0800</pubDate>
      
      <guid>http://nituchao.com/post/2012/zhu-jiu-tan-xi-you-you-gan/</guid>
      <description>前两天同学给推荐了一本奇书 – 《吴闲云-煮酒探西游》,说是能颠覆我的世界观。
这本书不长，pdf版的只有167页，虽然很短，但是我看了两页就有种相见恨晚的感觉，一口气读完后，我深深觉得自己的世界观的确发生了变化，不是说我的世界观就这么容易就变化，实在是，这本书给出的观点真的是太玄妙，太精彩了。但凡是那些与个人认识强烈冲突的东西总会逼迫一个人去改变，换句话说是去成长。
在这本书之后，我承认自己之前对《西游记》的认识不超过十分之一，《西游记》对社会黑暗和人性复杂的刻画远远超出我的想象。
大致介绍一下这本书。
这本书包含82个小标题，大部分篇幅是在解答《西游记》原著里一些看似矛盾的现象。比如该书在开头提出的几个疑问:
  大闹天宫的孙悟空,连玉皇大帝、十万天兵天将都奈何不了他,可为什么后来在西天路上反而还斗不过一些妖怪呢? 孙悟空被关在太上老君的八卦炉里烧了49日也没有烧死。可为什么差点被红孩儿吐的一把火给烧死了？ 神仙们既然可以长生不死,那么,为什么一个个的还要跑去吃王母娘娘的蟠桃呢? 玉皇大帝真的是昏庸无能吗?那么,他又怎么可能成为万神的主宰呢? 妖精抓到唐僧后,总是不急着吃掉,他们究竟在等什么呢?为什么就没有一个急性子抢了 就咬一口吃的?   毫不掩饰的说，这几个问题也是我在看《西游记》时的疑问，我一直抱怨导演拍戏太毛糙了，留下了这么多的bug。 看了这本书后，我终于明白，我可以说导演拍的太粗糙，但是原著作者吴承恩一点都不毛糙。《西游记》里的每一个角色，每一个故事都是有理有据，有因有果的，每一个看似矛盾的现象背后都藏着很多故事，而这些背后的故事真的一点都不比我们看到的东西差，甚至更精彩。
《探西游》不仅仅是在解答一些疑问，作者从道家和佛家为争夺势力范围的角度出发，几乎重新演绎了一遍《西游记》。这本书让我们抛开对人物的好恶，从理性的角度去认识每个重要角色，于是，我们看到观音菩萨是多么居心险恶的人，如来佛为了扩充自己的势力范围是多么的不择手段，牛魔王竟然靠吃软饭来谋求长生不老，唐僧不再是一本正经，猪八戒不再是懒懒的呆子…每一个人物都不一样了，但是却更真实了，真实到可怕的地步，仿佛书里的人物，书里的故事就发生在我们身边，甚至比我们身边的故事还真实，还实在。
当然，《探西游》对《西游记》的解读虽然是一家之言，但是，能名列中国古典四大名著之一，《西游记》真的没有我们想象的那么简单，以后有时间，我一定要好好再看看这本书。</description>
    </item>
    
    <item>
      <title>Chameleon引导ubuntu</title>
      <link>http://nituchao.com/post/2012/chameleon-yin-dao-ubuntu/</link>
      <pubDate>Sun, 03 Jun 2012 18:18:18 +0800</pubDate>
      
      <guid>http://nituchao.com/post/2012/chameleon-yin-dao-ubuntu/</guid>
      <description>现在，我的笔记本上同时运行着3个系统，Windows 7，Mac OS 10.7和Ubuntu 10.10。Ubuntu 10.10主要是用来编译调试我的Egg Boiler系统。
Ubuntu的grub2不能引导Mac OS X系统，所以用chameleon来引导三个系统是非常好的选择，同时chameleon是完全的图形化引导，非常漂亮。
我的做法非常简单，首先要安装好三个系统，特别要注意的是安装Ubuntu时，要选择把gurb2安装到Ubuntu的/分区，而不能将boot loader安在整个硬盘上，否则变色龙不能识别Ubuntu。
然后在Mac OS下安装Mac版变色龙到Mac OS系统分区。
最后，用Ubuntu的live-cd中的Gparted分区工具把Mac OS X所在分区的标记更改为”boot”，也就是开机从Mac OS X所在分区引导。
最后附一个变色龙主题:传送门</description>
    </item>
    
    <item>
      <title>Windows下硬盘安装Mac OS Lion</title>
      <link>http://nituchao.com/post/2012/windows-ying-pan-an-zhuang-mac/</link>
      <pubDate>Sun, 20 May 2012 20:20:00 +0800</pubDate>
      
      <guid>http://nituchao.com/post/2012/windows-ying-pan-an-zhuang-mac/</guid>
      <description>经过一年多的尝试，建议大家安装Mac OS X 10.7原版，这个版本的Mac OS 系统对硬件的兼容性非常好，安装出现的问题也最少。建议大家驱动都自己手动安装，这样子才能更清楚自己装了哪些驱动，将来遇见诸如”五国”，”无限风火轮”的问题时才能更容易找到问题的原因。
此日志讨论的是在Windows系统下通过原版Mac OS X 10.7的dmg镜像来安装Mac OS系统的方法。
文章有点长，请耐心看完~~
 理论上说，该方法也可以用来在Windows系统下制作U盘系统安装盘。 理论上说，该方法也可以用来在Windows系统下安装10.7.1,10.7.2,10.7.3,10.7.4甚至是10.8的原版镜像。   准备工作  系统:Windows 7，Windows XP Mac OS X 10.7原版dmg镜像 dmg镜像浏览工具HFSExplorer-0.21版 磁盘分区工具Paragon Partition Manager 11版 硬盘安装助手HD Install Helper v0.3版 Mac Driver 8版 Windows版变色龙 必要的驱动和破解文件  适合自己机型的dsdt.aml 修改过的适合10.7的OSInstall和OSInstall.mpkg，有需要的可以下载我准备好的传送门 FakeSMC.kext 破解补丁，用于破解Mac OS内核，必须 AppleACPIPS2Nub.kext ApplePS2Controller.kext NullCPUPowerManagement.kext 禁用电源管理功能，解决HPET错误   说明:以上的文件，除了dsdt.aml是要适合自己机型的外，其他的文件都是通用的，都可以在远景论坛上找到，想吃黑苹果，趴贴的精神和毅力必须是有的~~
制作安装盘  安装Mac Driver 8备用，安装完后需要重启。
 留出3个分区
 系统盘，20G,主分区，Mac OS X系统要安装在这个分区。建议该分区尽量大一点，因为装上Mac OS后我们还要装很多软件，比如我分了42G给该分区 安装盘，至少2G,主分区(或逻辑分区)，Mac OS X的安装盘要安装在这个分区。 备用盘，至少3G,不创建分区，该分区的目的是为了扩充安装盘分区，因为Mac OS X的镜像写入到安装盘分区后，安装盘分区只剩下300M左右，不能进行接下来的操作，这时候需要把这3G空白分区合进安装盘分区。    修改分区ID = AF。这一步很重要，ID = AF表示这是一个Apple HFS+分区，Mac OS只能安装在HFS+分区上。  强烈建议: 用下面的命令来修改系统盘和安装盘的分区ID，因为经过实践发现，用磁盘分区工具来修改ID失败的概率很大，通过命令行来修改通常不会出错，运行cmd打开命令行窗口后，一次执行下面的命令,看到success就ok了，这个时候在资源管理器里就看不到这个分区了。</description>
    </item>
    
    <item>
      <title>编译自己的Linux系统</title>
      <link>http://nituchao.com/post/2012/bian-yi-zi-ji-de-linux-xi-tong/</link>
      <pubDate>Fri, 18 May 2012 20:20:00 +0800</pubDate>
      
      <guid>http://nituchao.com/post/2012/bian-yi-zi-ji-de-linux-xi-tong/</guid>
      <description>LFS，全称是Linux from Scratch，是一个教科书项目的名称，由 Gerard Beekmans 所发展并维护。这个项目旨在教人们完全从零开始编译自己的linux系统，所有的软件都是通过源码包安装，每个人都可以按照自己的需要定制自己的linux，这样可以做出来最小，最快也最满足自己需要的linux，我的这个linux就是按照LFS的思想来编译构建的。
LFS官网
在高中时我就想过将来有机会一定要做一个自己的操作系统出来，后来发现这并不是一件容易的事情，当然，也不是完全不可能，三年前接触了linux后，我就在构思如何能编译一个linux出来。后来，在研究破解无线网的过程中我接触到Beini Linux(奶瓶操作系统)，只有不到60M(ps:据说这个系统的作者是为了庆祝自己女儿的出生写下的这个操作系统),这让我觉得linux是完全可以自己定制并做的很小很小。
言归正传，我第一次接触LFS是在一年前，当时对linux的底层原理和库依赖关系等还是非常不清楚，对整个LFS的过程云里雾里的，所以就搁浅了。
最近又拿起来LFS，细细读了读，发现很多东西已经理解很透了，于是就在着手在自己的笔记本上构建LFS系统，说实话这个过程很费精力，我前后总共用了四天时间，几乎每天醒着的时间都在搞这个系统，当然，最后做出来后，很是自豪，这个系统我称之为”Egg Boiler 1.0“，吼吼~~。
基本的LFS系统构建好以后，开机只要3s左右就到登陆界面了，真是快的一塌糊涂，爽啊。之后，我又在这个系统上安装了DHCP和pppoe，使得他可以自动获取IP地址，由于没有GUI界面，我安装了lynx浏览器，这样就可以通过文本方式访问互联网。
由于是第一次编译linux系统，下面说说自己遇到的困难:
首先是宿主系统的选择，最初用的是Fadero 16，因为他是基于Rad hat的，应该会很稳定，结果它搭载的Gnome3.4界面在root用户登陆的情况下总是崩溃，而且崩溃之后就进不了系统，在这种情况下重装了好几次，最后还是决定放弃Fadero。之后试用了Arch Linux也不是很顺利，最后还是决定用ubuntu 10.10，ubuntu果然不负众望，基本没出什么问题直到新系统的诞生…
其次是宿主系统环境的设置，LFS对GCC，Glib的环境的要求非常苛刻，刚开始不清楚，有些就没有按照官方给的配置设置环境，结果编译到一半，尤其是GCC的编译，总是出错，几近崩溃了都，最后还是老老实实按照官方给的要求重新配置了ubuntu的软件环境，总算是一步一步进行下去了…
再者是LFS版本的选择。早一点的LFS版本有中文翻译，我最早就是用的LFS 6.3，因为文档又中文，但是在编译GCC时总是出错，看了论坛上前人的经验才最后决定用LFS 6.8，虽然文档全是英文，但是基本上都能看懂能理解，结果LFS 6.8在我的ubuntu上果然一路顺利。可见，LFS的版本还是很重要的，一定要选对LFS版本，并严格按照文档来才能成功。
我还没有想好我做的这个系统究竟用来做什么，不过有了这个基础，将来根据需要把它改成服务器系统或嵌入式系统就很轻松了。
 oo$$$$$$$$$$oo oooo$$$$$$$$$$$$oooo oo$$$$$$$$$$$$$$$$$$$$$$$$o oo$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$o o$ $$ o$ o $ oo o$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$o $$ $$ $$o$ oo $ $ &amp;quot;$ o$$$$$$$$$ $$$$$$$$$$$$$ $$$$$$$$$o $$$o$$o$ &amp;quot;$$$$$$o$ o$$$$$$$$$ $$$$$$$$$$$ $$$$$$$$$$o $$$$$$$$ $$$$$$$ $$$$$$$$$$$ $$$$$$$$$$$ $$$$$$$$$$$$$$$$$$$$$$$ $$$$$$$$$$$$$$$$$$$$$$$ $$$$$$$$$$$$$ $$$$$$$$$$$$$$ &amp;quot;&amp;quot;&amp;quot;$$$ &amp;quot;$$$&amp;quot;&amp;quot;&amp;quot;&amp;quot;$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$ &amp;quot;$$$ $$$ o$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$ &amp;quot;$$$o o$$&amp;quot; $$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$ $$$o $$$ $$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$&amp;quot; &amp;quot;$$$$$$ooooo$$$$o o$$$oooo$$$$$ $$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$ o$$$$$$$$$$$$$$$$$ $$$$$$$$&amp;quot;$$$$ $$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$ $$$$&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot; &amp;quot;&amp;quot;&amp;quot;&amp;quot; $$$$ &amp;quot;$$$$$$$$$$$$$$$$$$$$$$$$$$$$&amp;quot; o$$$ &amp;quot;$$$o &amp;quot;&amp;quot;&amp;quot;$$$$$$$$$$$$$$$$$$&amp;quot;$$&amp;quot; $$$ $$$o &amp;quot;$$&amp;quot;&amp;quot;$$$$$$&amp;quot;&amp;quot;&amp;quot;&amp;quot; o$$$ $$$$o o$$$&amp;quot; &amp;quot;$$$$o o$$$$$$o&amp;quot;$$$$o o$$$$ &amp;quot;$$$$$oo &amp;quot;&amp;quot;$$$$o$$$$$o o$$$$&amp;quot;&amp;quot; &amp;quot;&amp;quot;$$$$$oooo &amp;quot;$$$o$$$$$$$$$&amp;quot;&amp;quot;&amp;quot; &amp;quot;&amp;quot;$$$$$$$oo $$$$$$$$$$ &amp;quot;&amp;quot;&amp;quot;&amp;quot;$$$$$$$$$$$ $$$$$$$$$$$$ $$$$$$$$$$&amp;quot; &amp;quot;$$$&amp;quot;&amp;quot;&amp;quot;&amp;quot; &amp;quot;$$$&amp;quot;&amp;quot;&amp;quot;&amp;quot;  </description>
    </item>
    
  </channel>
</rss>