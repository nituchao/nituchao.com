<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Java on 泥土巢</title>
    <link>http://nituchao.com/tags/java/index.xml</link>
    <description>Recent content in Java on 泥土巢</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh-CN</language>
    <copyright>Copyright (c) 2017, nituchao | All rights reserved.</copyright>
    <atom:link href="http://nituchao.com/tags/java/index.xml" rel="self" type="application/rss+xml" />
    
    <item>
      <title>jstack命令</title>
      <link>http://nituchao.com/post/2017/tong-guo-jstack-fen-xi/</link>
      <pubDate>Tue, 28 Feb 2017 19:01:58 +0800</pubDate>
      
      <guid>http://nituchao.com/post/2017/tong-guo-jstack-fen-xi/</guid>
      <description>

&lt;p&gt;Java程序在操作系统上是以单进程、多线程的形式运行。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;[work@zc-stage1-miui-sec02 ~]$ jstack
Usage:
    jstack [-l] &amp;lt;pid&amp;gt;
        (to connect to running process)
    jstack -F [-m] [-l] &amp;lt;pid&amp;gt;
        (to connect to a hung process)
    jstack [-m] [-l] &amp;lt;executable&amp;gt; &amp;lt;core&amp;gt;
        (to connect to a core file)
    jstack [-m] [-l] [server_id@]&amp;lt;remote server IP or hostname&amp;gt;
        (to connect to a remote debug server)

Options:
    -F  to force a thread dump. Use when jstack &amp;lt;pid&amp;gt; does not respond (process is hung)
    -m  to print both java and native frames (mixed mode)
    -l  long listing. Prints additional information about locks
    -h or -help to print this help message
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;jstack参数说明&#34;&gt;jstack参数说明&lt;/h2&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;连接到运行中的进程&lt;/p&gt;

&lt;p&gt;&amp;ldquo;jstack pid&amp;rdquo;，pid为进程号，可以通过jps或者top命令查到。&lt;/p&gt;

&lt;p&gt;命令执行成功则堆栈信息打印在控制台，可以通过&amp;rdquo;jstack 7023 &amp;gt; stack.log&amp;rdquo;这种方式将内容输出文件。&lt;/p&gt;

&lt;p&gt;导出的文本中包含线程号，线程号状态，线程调用栈等信息，结合ps命令中查询出的线程号，可以分析出CPU使用率比较高的线程，以及该线程中的调用堆栈，进而可以定位到项目代码。&lt;/p&gt;

&lt;p&gt;```
Thread 1091: (state = BLOCKED)&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;sun.misc.Unsafe.park(boolean, long) @bci=0 (Compiled frame; information may be imprecise)&lt;/li&gt;
&lt;li&gt;java.util.concurrent.locks.LockSupport.park() @bci=5, line=315 (Interpreted frame)&lt;/li&gt;
&lt;li&gt;com.caucho.env.thread2.ResinThread2.park() @bci=29, line=196 (Compiled frame)&lt;/li&gt;
&lt;li&gt;com.caucho.env.thread2.ResinThread2.runTasks() @bci=65, line=147 (Compiled frame)&lt;/li&gt;
&lt;li&gt;com.caucho.env.thread2.ResinThread2.run() @bci=15, line=118 (Interpreted frame)
```&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;Thread 1089: (state = BLOCKED)
    - sun.misc.Unsafe.park(boolean, long) @bci=0 (Compiled frame; information may be imprecise)
    - java.util.concurrent.locks.LockSupport.park() @bci=5, line=315 (Interpreted frame)
    - com.caucho.env.thread2.ResinThread2.park() @bci=29, line=196 (Compiled frame)
    - com.caucho.env.thread2.ResinThread2.runTasks() @bci=65, line=147 (Compiled frame)
    - com.caucho.env.thread2.ResinThread2.run() @bci=15, line=118 (Interpreted frame)&lt;/p&gt;

&lt;p&gt;Thread 1088: (state = IN_NATIVE)
    - java.net.SocketInputStream.socketRead0(java.io.FileDescriptor, byte[], int, int, int) @bci=0 (Compiled frame; information may be imprecise)
    - java.net.SocketInputStream.read(byte[], int, int, int) @bci=79, line=150 (Compiled frame)
    - java.net.SocketInputStream.read(byte[], int, int) @bci=11, line=121 (Compiled frame)
    - java.net.SocketInputStream.read(byte[]) @bci=5, line=107 (Compiled frame)
    - redis.clients.util.RedisInputStream.ensureFill() @bci=20, line=195 (Compiled frame)
    - redis.clients.util.RedisInputStream.readByte() @bci=1, line=40 (Compiled frame)
    - redis.clients.jedis.Protocol.process(redis.clients.util.RedisInputStream) @bci=1, line=141 (Compiled frame)
    - redis.clients.jedis.Protocol.read(redis.clients.util.RedisInputStream) @bci=1, line=205 (Compiled frame)
    - redis.clients.jedis.Connection.readProtocolWithCheckingBroken() @bci=4, line=297 (Compiled frame)
    - redis.clients.jedis.Connection.getBinaryBulkReply() @bci=15, line=216 (Compiled frame)
    - redis.clients.jedis.Connection.getBulkReply() @bci=1, line=205 (Compiled frame)
    - redis.clients.jedis.Jedis.get(java.lang.String) @bci=27, line=101 (Compiled frame)
    - redis.clients.jedis.JedisCluster$3.execute(redis.clients.jedis.Jedis) @bci=5, line=79 (Compiled frame)
    - redis.clients.jedis.JedisCluster$3.execute(redis.clients.jedis.Jedis) @bci=2, line=76 (Compiled frame)
    - redis.clients.jedis.JedisClusterCommand.runWithRetries(byte[], int, boolean, boolean) @bci=78, line=119 (Compiled frame)
    - redis.clients.jedis.JedisClusterCommand.run(java.lang.String) @bci=25, line=30 (Compiled frame)
    - redis.clients.jedis.JedisCluster.get(java.lang.String) @bci=18, line=81 (Compiled frame)
    - com.xiaomi.miui.sec.service.RedisCacheService$14.call(redis.clients.jedis.RedisCluster) @bci=5, line=667 (Compiled frame)
    - com.xiaomi.miui.sec.service.RedisCacheService$14.call(java.lang.Object) @bci=5, line=663 (Compiled frame)
    - com.xiaomi.miui.cache.rediscluster.DefaultRedisClusterCache.get(java.lang.Object, com.xiaomi.miui.cache.rediscluster.RedisClusterCallable) @bci=22, line=68 (Compiled frame)
    - com.xiaomi.miui.sec.service.RedisCacheService.getSettingAdv(java.lang.String, java.lang.String, java.lang.String) @bci=49, line=663 (Compiled frame)
    - com.xiaomi.miui.sec.service.CacheService.getSettingAdv(java.lang.String, java.lang.String, java.lang.String) @bci=7, line=113 (Compiled frame)
    - com.xiaomi.miui.sec.bizLogic.SettingBiz.postHandlerMiCom(net.sf.json.JSONObject, com.xiaomi.miui.sec.thrift.Device, net.paoding.rose.web.Invocation) @bci=55, line=119 (Compiled frame)
    - com.xiaomi.miui.sec.bizLogic.SettingBiz.postHandler(net.sf.json.JSONObject, com.xiaomi.miui.sec.thrift.Device, net.paoding.rose.web.Invocation) @bci=118, line=65 (Compiled frame)
    - com.xiaomi.miui.sec.bizLogic.BasicBiz.mainHandler(net.paoding.rose.web.Invocation) @bci=29, line=59 (Compiled frame)
    - com.xiaomi.miui.sec.controllers.InfoController.setting(net.paoding.rose.web.Invocation, java.lang.String) @bci=73, line=252 (Compiled frame)
    - sun.reflect.GeneratedMethodAccessor31.invoke(java.lang.Object, java.lang.Object[]) @bci=48 (Compiled frame)
    - sun.reflect.DelegatingMethodAccessorImpl.invoke(java.lang.Object, java.lang.Object[]) @bci=6, line=43 (Compiled frame)
    - java.lang.reflect.Method.invoke(java.lang.Object, java.lang.Object[]) @bci=57, line=606 (Compiled frame)&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;
   ​

## jstack分析java线程的CPU使用率和使用时长



## jstack分析分析已有的javacore文件



## jstack连接到远程调试服务器进行分析
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>解决Java进程占用CPU过高的问题</title>
      <link>http://nituchao.com/post/2017/ji-lu-yi-ci-cpu-guo-gao-chu-li/</link>
      <pubDate>Tue, 28 Feb 2017 09:16:18 +0800</pubDate>
      
      <guid>http://nituchao.com/post/2017/ji-lu-yi-ci-cpu-guo-gao-chu-li/</guid>
      <description></description>
    </item>
    
    <item>
      <title>CopyOnWriteArrayList源码分析</title>
      <link>http://nituchao.com/post/juc.concurrent/copy-on-write-array-list/</link>
      <pubDate>Thu, 23 Feb 2017 18:25:27 +0800</pubDate>
      
      <guid>http://nituchao.com/post/juc.concurrent/copy-on-write-array-list/</guid>
      <description>

&lt;h2 id=&#34;概述&#34;&gt;概述&lt;/h2&gt;

&lt;p&gt;CopyOnWriteArrayList相当于线程安全的ArrayList。和ArrayList一样，它是个可变数组；但是和ArrayList不同的是，它具有以下特性：
1. 它最适合于具有以下特征的应用程序：List大小通常保持很小，只读操作远多于可变操作，需要在遍历期间防止线程间的冲突。
2. 它是线程安全的。它的线程安全表现在两个方面，修改时使用锁进行同步，读取时使用数据快照。
3. 因为通常要复制整个基础数组，所以可变操作（add()、set()和remove()等操作）的开销很大。
4. 迭代器支持hasNext()、next等不可变操作，但不支持可变remove()等操作。
5. 使用迭代器进行遍历的速度很快，并且不会与其他线程发生冲突。在构造迭代器时，迭代器依赖于不变的数组快照。&lt;/p&gt;

&lt;h2 id=&#34;copyonwritearraylist原理和数据结构&#34;&gt;CopyOnWriteArrayList原理和数据结构&lt;/h2&gt;

&lt;p&gt;CopyOnWriteArrayList的数据结构，如下图所示：&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;CopyOnWriteArrayList UML图&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;说明：
1. CopyOnWriteArrayList实现了List接口，因此可以认为它是一个有序的集合。
2. CopyOnWriteArrayList实现了RandomAccess接口，因此可以认为它的元素可以随机访问。
3. CopyOnWriteArrayList包含一个可重入锁Lock。每一个CopyOnWriteArrayList都和一个互斥锁lock绑定，通过lock，实现了对CopyOnWriteArrayList的互斥访问。
4. CopyOnWriteArrayList包含了成员array数组，这说明CopyOnWriteArrayList本质上通过数组实现的。而且，可存储的元素个数没有上限。&lt;/p&gt;

&lt;p&gt;下面从&amp;rdquo;动态数组&amp;rdquo;和&amp;rdquo;线程安全&amp;rdquo;两个方面进一步对CopyOnWriteArrayList的原理进行说明。
1. &lt;strong&gt;CopyOnWriteArrayList的&amp;rdquo;动态数组&amp;rdquo;机制&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;它内部有个&amp;rdquo;volatile数组&amp;rdquo;(array)来保持数据。在&amp;rdquo;添加/修改/删除&amp;rdquo;数据时，都会新建一个数组，并将更新后的数据拷贝到新建的数组中，最后再将该数组赋值给&amp;rdquo;volatile数组&amp;rdquo;。这就是它叫做CopyOnWriteArrayList的原因！&lt;/p&gt;

&lt;p&gt;CopyOnWriteArrayList就是通过这种方式实现的动态数组；不过正由于它在&amp;rdquo;添加/修改/删除&amp;rdquo;数据时，都会新建数组，所以涉及到修改数据的操作，CopyOnWriteArrayList效率很低。但是单单只是进行遍历的话，效率比较高。&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;CopyOnWriteArrayList的&amp;rdquo;线程安全&amp;rdquo;机制&lt;/strong&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;是通过volatile和互斥锁来实现的。
 a. CopyOnWriteArrayList是通过&amp;rdquo;volatile数组&amp;rdquo;来保存数据的。&lt;/p&gt;

&lt;p&gt;一个线程读取volatile数组时，总能看到其他线程对该volatile变量最后的写入。就这样，通过volatile提供了&amp;rdquo;读取到的数据总是最新的&amp;rdquo;这个机制的保证。
 b. CopyOnWriteArrayList通过互斥锁来保护数据。&lt;/p&gt;

&lt;p&gt;在&amp;rdquo;添加/修改/删除&amp;rdquo;数据时，会先&amp;rdquo;获取互斥锁&amp;rdquo;，在修改完毕后，先将数据更新到&amp;rdquo;volatile数组&amp;rdquo;中，然后再&amp;rdquo;释放互斥锁&amp;rdquo;；这样，就达到了保护数据的目的。&lt;/p&gt;

&lt;h2 id=&#34;copyonwritearraylist成员变量&#34;&gt;CopyOnWriteArrayList成员变量&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;/** 可重入锁，对数组进行添加/修改/删除操作时，通过lock来进行同步操作 */
transient final ReentrantLock lock = new ReentrantLock();

/** 数组，保存数据的地方。对数组array的操作都要通过getArray和setArray进行操作 */
private volatile transient Object[] array;
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;copyonwritearraylist函数列表&#34;&gt;CopyOnWriteArrayList函数列表&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;// 创建一个空列表，默认大小为0。
CopyOnWriteArrayList()
// 创建一个按 collection 的迭代器返回元素的顺序包含指定 collection 元素的列表。
CopyOnWriteArrayList(Collection&amp;lt;? extends E&amp;gt; c)
// 创建一个保存给定数组的副本的列表。 
CopyOnWriteArrayList(E[] toCopyIn)
// 将指定元素添加到此列表的尾部。
boolean add(E e)
// 在此列表的指定位置上插入指定元素。
void add(int index, E element)
// 按照指定 collection 的迭代器返回元素的顺序，将指定 collection 中的所有元素添加此列表的尾部。
boolean addAll(Collection&amp;lt;? extends E&amp;gt; c)
// 从指定位置开始，将指定 collection 的所有元素插入此列表。
boolean addAll(int index, Collection&amp;lt;? extends E&amp;gt; c)
// 按照指定 collection 的迭代器返回元素的顺序，将指定 collection 中尚未包含在此列表中的所有元素添加列表的尾部。
int addAllAbsent(Collection&amp;lt;? extends E&amp;gt; c)
// 添加元素（如果不存在）。
boolean addIfAbsent(E e)
// 从此列表移除所有元素。
void clear()
// 返回此列表的浅表副本。
Object clone()
// 如果此列表包含指定的元素，则返回 true。
boolean contains(Object o)
// 如果此列表包含指定 collection 的所有元素，则返回 true。
boolean containsAll(Collection&amp;lt;?&amp;gt; c)
// 比较指定对象与此列表的相等性。
boolean equals(Object o)
// 返回列表中指定位置的元素。
E get(int index)
// 返回此列表的哈希码值。
int hashCode()
// 返回第一次出现的指定元素在此列表中的索引，从 index 开始向前搜索，如果没有找到该元素，则返回 -1。
int indexOf(E e, int index)
// 返回此列表中第一次出现的指定元素的索引；如果此列表不包含该元素，则返回 -1。
int indexOf(Object o)
// 如果此列表不包含任何元素，则返回 true。
boolean isEmpty()
// 返回以恰当顺序在此列表元素上进行迭代的迭代器。
Iterator&amp;lt;E&amp;gt; iterator()
// 返回最后一次出现的指定元素在此列表中的索引，从 index 开始向后搜索，如果没有找到该元素，则返回 -1。
int lastIndexOf(E e, int index)
// 返回此列表中最后出现的指定元素的索引；如果列表不包含此元素，则返回 -1。
int lastIndexOf(Object o)
// 返回此列表元素的列表迭代器（按适当顺序）。
ListIterator&amp;lt;E&amp;gt; listIterator()
// 返回列表中元素的列表迭代器（按适当顺序），从列表的指定位置开始。
ListIterator&amp;lt;E&amp;gt; listIterator(int index)
// 移除此列表指定位置上的元素。
E remove(int index)
// 从此列表移除第一次出现的指定元素（如果存在）。
boolean remove(Object o)
// 从此列表移除所有包含在指定 collection 中的元素。
boolean removeAll(Collection&amp;lt;?&amp;gt; c)
// 只保留此列表中包含在指定 collection 中的元素。
boolean retainAll(Collection&amp;lt;?&amp;gt; c)
// 用指定的元素替代此列表指定位置上的元素。
E set(int index, E element)
// 返回此列表中的元素数。
int size()
// 返回此列表中 fromIndex（包括）和 toIndex（不包括）之间部分的视图。
List&amp;lt;E&amp;gt; subList(int fromIndex, int toIndex)
// 返回一个按恰当顺序（从第一个元素到最后一个元素）包含此列表中所有元素的数组。
Object[] toArray()
// 返回以恰当顺序（从第一个元素到最后一个元素）包含列表所有元素的数组；返回数组的运行时类型是指定数组的运行时类型。
&amp;lt;T&amp;gt; T[] toArray(T[] a)
// 返回此列表的字符串表示形式。
String toString()
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;copyonwritearraylist重点函数分析&#34;&gt;CopyOnWriteArrayList重点函数分析&lt;/h2&gt;

&lt;h3 id=&#34;构造函数&#34;&gt;构造函数&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;// 初始化一个大小为0的对象数组
public CopyOnWriteArrayList() {
    setArray(new Object[0]);
}

// 使用一个集合里的元素来初始化一个对象数组
public CopyOnWriteArrayList(Collection&amp;lt;? extends E&amp;gt; c) {
    Object[] elements = c.toArray();
    if (elements.getClass() != Object[].class)
        elements = Arrays.copyOf(elements, elements.length, Object[].class);
    setArray(elements);
}

// 使用一个数组里元素来初始化一个对象数组
public CopyOnWriteArrayList(E[] toCopyIn) {
    setArray(Arrays.copyOf(toCopyIn, toCopyIn.length, Object[].class));
}

final Object[] getArray() {
    return array;
}

final void setArray(Object[] a) {
    array = a;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;CopyOnWriteArrayList的三个构造函数都调用了setArray()，将新创建的数组赋值给CopyOnWriteArrayList的成员变量array。&lt;/p&gt;

&lt;h3 id=&#34;添加&#34;&gt;添加&lt;/h3&gt;

&lt;h4 id=&#34;直接添加&#34;&gt;直接添加&lt;/h4&gt;

&lt;p&gt;以add(E e)为例来分析&lt;code&gt;CopyOnWriteArrayList&lt;/code&gt;的添加操作。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public boolean add(E e) {
    final ReentrantLock lock = this.lock;
    // 获取“锁”
    lock.lock();
    try {
        // 获取原始”volatile数组“中的数据和数据长度。
        Object[] elements = getArray();
        int len = elements.length;
        // 新建一个数组newElements，并将原始数据拷贝到newElements中；
        // newElements数组的长度=“原始数组的长度”+1
        Object[] newElements = Arrays.copyOf(elements, len + 1);
        // 将“新增加的元素”保存到newElements中。
        newElements[len] = e;
        // 将newElements赋值给”volatile数组“。
        setArray(newElements);
        return true;
    } finally {
        // 释放“锁”
        lock.unlock();
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;说明&lt;/strong&gt;：&lt;/p&gt;

&lt;p&gt;add(E e)的作用就是将数据e添加到”volatile数组“中。它的实现方式是，新建一个数组，接着将原始的”volatile数组“的数据拷贝到新数组中，然后将新增数据也添加到新数组中；最后，将新数组赋值给”volatile数组“。&lt;/p&gt;

&lt;p&gt;在add(E e)中有两点需要关注。&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;在”添加操作“开始前，获取独占锁(lock)，若此时有需要线程要获取锁，则必须等待；在操作完毕后，释放独占锁(lock)，此时其它线程才能获取锁。通过独占锁，来防止多线程同时修改数据！lock的定义如下：&lt;/li&gt;
&lt;/ol&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;transient final ReentrantLock lock = new ReentrantLock();
&lt;/code&gt;&lt;/pre&gt;

&lt;ol&gt;
&lt;li&gt;操作完毕时，会通过setArray()来更新”volatile数组“。而且，前面我们提过”即对一个volatile变量的读，总是能看到（任意线程）对这个volatile变量最后的写入“；这样，每次添加元素之后，其它线程都能看到新添加的元素。&lt;/li&gt;
&lt;/ol&gt;

&lt;h4 id=&#34;不重复添加&#34;&gt;不重复添加&lt;/h4&gt;

&lt;p&gt;由于CopyOnWriteArraySet是通过聚合了一个CopyOnWriteArrayList实现的，而CopyOnWriteArraySet是不包含重复元素的，因此CopyOnWriteArrayList提供了一个不添加重复元素的方法&lt;code&gt;addIfAbsent&lt;/code&gt;，该方法每次从头遍历数组，如果发现元素已经存在，则直接返回false，如果遍历后待添加元素不存在，则添加到新数组的末尾，然后将新数组设置为成员数组。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public boolean addIfAbsent(E e) {
        final ReentrantLock lock = this.lock;
        lock.lock();
        try {
            // Copy while checking if already present.
            // This wins in the most common case where it is not present
            Object[] elements = getArray();
            int len = elements.length;
            Object[] newElements = new Object[len + 1];
            for (int i = 0; i &amp;lt; len; ++i) {
                if (eq(e, elements[i]))
                    return false; // exit, throwing away copy
                else
                    newElements[i] = elements[i];
            }
            newElements[len] = e;
            setArray(newElements);
            return true;
        } finally {
            lock.unlock();
        }
    }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;有在检查待添加元素是否已经存在时要从头遍历数组，因此随着元素个数递增，该方法的效率线性下降。&lt;/p&gt;

&lt;h3 id=&#34;获取&#34;&gt;获取&lt;/h3&gt;

&lt;p&gt;以get(int index)为例，来对&lt;code&gt;CopyOnWriteArrayList&lt;/code&gt;的删除操作进行说明。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public E get(int index) {
    return get(getArray(), index);
}

private E get(Object[] a, int index) {
    return (E) a[index];
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;说明:&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;get(int index)的实现非常简单，就是返回&amp;rdquo;volatile数组&amp;rdquo;中的第index个元素。读取元素的过程不需要加锁，是读取时array的镜像。&lt;/p&gt;

&lt;h4 id=&#34;删除&#34;&gt;删除&lt;/h4&gt;

&lt;p&gt;以remove(int index)为例，来说明&lt;code&gt;CopyOnWriteArrayList&lt;/code&gt;的删除操作。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public E remove(int index) {
    final ReentrantLock lock = this.lock;
    // 获取“锁”
    lock.lock();
    try {
        // 获取原始”volatile数组“中的数据和数据长度。
        Object[] elements = getArray();
        int len = elements.length;
        // 获取elements数组中的第index个数据。
        E oldValue = get(elements, index);
        int numMoved = len - index - 1;
        // 如果被删除的是最后一个元素，则直接通过Arrays.copyOf()进行处理，而不需要新建数组。
        // 否则，新建数组，然后将”volatile数组中被删除元素之外的其它元素“拷贝到新数组中。
        // 最后，将新数组赋值给”volatile数组“。
        if (numMoved == 0)
            setArray(Arrays.copyOf(elements, len - 1));
        else {
            Object[] newElements = new Object[len - 1];
            System.arraycopy(elements, 0, newElements, 0, index);
            System.arraycopy(elements, index + 1, newElements, index,
                             numMoved);
            setArray(newElements);
        }
        return oldValue;
    } finally {
        // 释放“锁”
        lock.unlock();
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;说明&lt;/strong&gt;：&lt;/p&gt;

&lt;p&gt;remove(int index)的作用就是将”volatile数组“中第index个元素删除。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;em&gt;它的实现方式是，如果被删除的是最后一个元素，则直接通过Arrays.copyOf()进行处理，而不需要新建数组。&lt;/em&gt;&lt;/strong&gt;否则，新建数组，然后将”volatile数组中被删除元素之外的其它元素“拷贝到新数组中。最后，将新数组赋值给”volatile数组“。
和add(E e)一样，remove(int index)也是”在操作之前，获取独占锁；操作完成之后，释放独占是“；并且”在操作完成时，会通过将数据更新到volatile数组中“。&lt;/p&gt;

&lt;p&gt;remove操作没有检查index的合法性，有可能会抛出IndexOutOfBoundsExceptions&lt;/p&gt;

&lt;h3 id=&#34;遍历&#34;&gt;遍历&lt;/h3&gt;

&lt;p&gt;以&lt;code&gt;iterator()&lt;/code&gt;为例，来说明&lt;code&gt;CopyOnWriteArrayList&lt;/code&gt;的遍历操作。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public Iterator&amp;lt;E&amp;gt; iterator() {
  return new COWIterator&amp;lt;E&amp;gt; (getArray(), 0);
}

private static class COWIterator&amp;lt;E&amp;gt; implements ListIterator&amp;lt;E&amp;gt; {
    private final Object[] snapshot;
    private int cursor;

    private COWIterator(Object[] elements, int initialCursor) {
        cursor = initialCursor;
        snapshot = elements;
    }

    public boolean hasNext() {
        return cursor &amp;lt; snapshot.length;
    }

    public boolean hasPrevious() {
        return cursor &amp;gt; 0;
    }

    // 获取下一个元素
    @SuppressWarnings(&amp;quot;unchecked&amp;quot;)
    public E next() {
        if (!hasNext())
            throw new NoSuchElementException();
        return (E) snapshot[cursor++];
    }

    // 获取上一个元素
    @SuppressWarnings(&amp;quot;unchecked&amp;quot;)
    public E previous() {
        if (!hasPrevious())
            throw new NoSuchElementException();
        return (E) snapshot[--cursor];
    }

    public int nextIndex() {
        return cursor;
    }

    public int previousIndex() {
        return cursor-1;
    }

    public void remove() {
        throw new UnsupportedOperationException();
    }

    public void set(E e) {
        throw new UnsupportedOperationException();
    }

    public void add(E e) {
        throw new UnsupportedOperationException();
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;说明&lt;/strong&gt;：&lt;/p&gt;

&lt;p&gt;COWIterator不支持修改元素的操作。例如，对于&lt;code&gt;remove()&lt;/code&gt;,&lt;code&gt;set()&lt;/code&gt;,&lt;code&gt;add()&lt;/code&gt;等操作，&lt;code&gt;COWIterator&lt;/code&gt;都会抛出异常！
另外，需要提到的一点是，CopyOnWriteArrayList返回迭代器不会抛出&lt;code&gt;ConcurrentModificationException&lt;/code&gt;异常，即它不是fail-fast机制的！&lt;/p&gt;

&lt;p&gt;参考：&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;http://www.cnblogs.com/skywang12345/p/3498483.html&#34;&gt;Java多线程系列之CopyOnWriteArrayList&lt;/a&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>CopyOnWriteArraySet源码分析</title>
      <link>http://nituchao.com/post/juc.concurrent/copy-on-write-array-set/</link>
      <pubDate>Thu, 23 Feb 2017 18:25:27 +0800</pubDate>
      
      <guid>http://nituchao.com/post/juc.concurrent/copy-on-write-array-set/</guid>
      <description>

&lt;h2 id=&#34;一句话&#34;&gt;一句话&lt;/h2&gt;

&lt;p&gt;&lt;code&gt;CopyOnWriteArraySet&lt;/code&gt;是线程安全的无序集合，它是通过聚合了一个&lt;code&gt;CopyOnWriteArray&lt;/code&gt;成员变量来实现的。&lt;/p&gt;

&lt;h2 id=&#34;概要&#34;&gt;概要&lt;/h2&gt;

&lt;p&gt;&lt;code&gt;CopyOnWriteArraySet&lt;/code&gt;是线程安全的无序集合，可以将它理解成线程安全的HashSet。有意思的是，&lt;code&gt;CopyOnWriteArraySet&lt;/code&gt;和HashSet虽然都继承于共同的父类AbstractSet；但是，HashSet是通过&amp;rdquo;散列表(HashSet)&amp;ldquo;实现的，而CopyConWriteArraySet则是通过&amp;rdquo;动态数组(CopyOnWriteArrayList)&amp;ldquo;实现的，并不是散列表。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;CopyOnWriteArraySet&lt;/code&gt;具有以下特性：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;它最适合于具有以下特征的应用程序：Set 大小通常保持很小，只读操作远多于可变操作，需要在遍历期间防止线程间的冲突。&lt;/li&gt;
&lt;li&gt;它是线程安全的。它的线程安全通过volatile、互斥锁来实现。&lt;/li&gt;
&lt;li&gt;因为通常需要复制整个基础数组，所以可变操作（add()、set() 和 remove() 等等）的开销很大。&lt;/li&gt;
&lt;li&gt;迭代器支持hasNext(), next()等不可变操作，但不支持可变 remove()等 操作。&lt;/li&gt;
&lt;li&gt;使用迭代器进行遍历的速度很快，并且不会与其他线程发生冲突。在构造迭代器时，迭代器依赖于不变的数组快照。&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&#34;copyonwritearrayset原理&#34;&gt;CopyOnWriteArraySet原理&lt;/h2&gt;

&lt;p&gt;CopyOnWriteArraySet的数据结构，如下图所示：&lt;/p&gt;

&lt;p&gt;&lt;code&gt;图&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;说明&lt;/strong&gt;&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;CopyOnWriteArraySet继承于AbstractSet，这就意味着它是一个集合。&lt;/li&gt;
&lt;li&gt;CopyOnWriteArraySet聚合了一个CopyOnWriteArrayList对象，它是通过CopyOnWriteArrayList实现的。而CopyOnWriteArrayList本质是个动态数组队列，所以CopyOnWriteArraySet相当于通过动态数组实现的&amp;rdquo;集合&amp;rdquo;！&lt;/li&gt;
&lt;li&gt;CopyOnWriteArraySet不允许有重复元素。因此，CopyOnWriteArrayList额外提供了addIfAbsent()和addAllAbsent()这两个添加元素的API，通过这些API来添加元素时，只有当元素不存在时才执行添加操作。&lt;/li&gt;
&lt;li&gt;CopyOnWriteArraySet的&amp;rdquo;线程安全&amp;rdquo;机制是通过volatile和互斥锁来实现的。而它本身没有volatile变量和互斥锁，都是借由CopyOnWriteArrayList实现。&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&#34;copyonwritearrayset函数列表&#34;&gt;CopyOnWriteArraySet函数列表&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;// 创建一个空 set。
CopyOnWriteArraySet()
// 创建一个包含指定 collection 所有元素的 set。
CopyOnWriteArraySet(Collection&amp;lt;? extends E&amp;gt; c)

// 如果指定元素并不存在于此 set 中，则添加它。
boolean add(E e)
// 如果此 set 中没有指定 collection 中的所有元素，则将它们都添加到此 set 中。
boolean addAll(Collection&amp;lt;? extends E&amp;gt; c)
// 移除此 set 中的所有元素。
void clear()
// 如果此 set 包含指定元素，则返回 true。
boolean contains(Object o)
// 如果此 set 包含指定 collection 的所有元素，则返回 true。
boolean containsAll(Collection&amp;lt;?&amp;gt; c)
// 比较指定对象与此 set 的相等性。
boolean equals(Object o)
// 如果此 set 不包含任何元素，则返回 true。
boolean isEmpty()
// 返回按照元素添加顺序在此 set 中包含的元素上进行迭代的迭代器。
Iterator&amp;lt;E&amp;gt; iterator()
// 如果指定元素存在于此 set 中，则将其移除。
boolean remove(Object o)
// 移除此 set 中包含在指定 collection 中的所有元素。
boolean removeAll(Collection&amp;lt;?&amp;gt; c)
// 仅保留此 set 中那些包含在指定 collection 中的元素。
boolean retainAll(Collection&amp;lt;?&amp;gt; c)
// 返回此 set 中的元素数目。
int size()
// 返回一个包含此 set 所有元素的数组。
Object[] toArray()
// 返回一个包含此 set 所有元素的数组；返回数组的运行时类型是指定数组的类型。
&amp;lt;T&amp;gt; T[] toArray(T[] a)
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;copyonwritearrayset成员变量&#34;&gt;CopyOnWriteArraySet成员变量&lt;/h2&gt;

&lt;p&gt;CopyOnWriteArraySet只有下面一个成员变量&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;private final CopyOnWriteArrayList&amp;lt;E&amp;gt; al;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;说明:&lt;/strong&gt;&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;成员变量al是&lt;code&gt;final&lt;/code&gt;类型的，通过构造函数进行初始化后将不能再修改。&lt;/li&gt;
&lt;li&gt;成员变量al里的&lt;code&gt;添加/修改/删除&lt;/code&gt;操作都是通过互斥锁和volatile变量来保证现场安全的，因此，成员变量al不再用&lt;code&gt;volatile&lt;/code&gt;修饰，也不再额外声明可重入锁lock。&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&#34;copyonwritearrayset重点函数&#34;&gt;CopyOnWriteArraySet重点函数&lt;/h2&gt;

&lt;h3 id=&#34;构造函数&#34;&gt;构造函数&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public CopyOnWriteArraySet() {
        al = new CopyOnWriteArrayList&amp;lt;E&amp;gt;();
}
public CopyOnWriteArraySet(Collection&amp;lt;? extends E&amp;gt; c) {
        al = new CopyOnWriteArrayList&amp;lt;E&amp;gt;();
        al.addAllAbsent(c);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;CopyOnWriteArraySet允许初始化一个空的集合，也允许通过复制一个集合里的元素来进行初始化。本质上将，CopyOnWriteArraySet的初始化是通过初始化成员变量CopyOnWriteArrayList al来实现的。&lt;/p&gt;

&lt;h3 id=&#34;添加&#34;&gt;添加&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public boolean add(E e) {
        return al.addIfAbsent(e);
}

public boolean addAll(Collection&amp;lt;? extends E&amp;gt; c) {
        return al.addAllAbsent(c) &amp;gt; 0;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;CopyOnWriteArraySet不允许重复元素。因此，添加操作都是调用CopyOnWriteArrayList的&lt;code&gt;addIfAbsent&lt;/code&gt;方法或者&lt;code&gt;addAllAbsent&lt;/code&gt;方法实现的。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>JVM行为相关的配置参数</title>
      <link>http://nituchao.com/post/2016/jvm-xing-wei-xiang-guan-de-pei-zhi-can-shu/</link>
      <pubDate>Thu, 29 Dec 2016 13:53:12 +0800</pubDate>
      
      <guid>http://nituchao.com/post/2016/jvm-xing-wei-xiang-guan-de-pei-zhi-can-shu/</guid>
      <description>&lt;p&gt;文本将分析与JVM行为相关的配置参数。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>JVM G1收集器配置参数</title>
      <link>http://nituchao.com/post/2016/jvm-g1-shou-ji-qi-pei-zhi-can-shu/</link>
      <pubDate>Thu, 29 Dec 2016 12:22:12 +0800</pubDate>
      
      <guid>http://nituchao.com/post/2016/jvm-g1-shou-ji-qi-pei-zhi-can-shu/</guid>
      <description>&lt;p&gt;G1收集器配置参数&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>JVM常用的非标准配置参数</title>
      <link>http://nituchao.com/post/2016/jvm-chan-yong-de-fei-biao-zhun-pei-zhi-can-shu/</link>
      <pubDate>Thu, 29 Dec 2016 10:18:12 +0800</pubDate>
      
      <guid>http://nituchao.com/post/2016/jvm-chan-yong-de-fei-biao-zhun-pei-zhi-can-shu/</guid>
      <description>&lt;p&gt;本文将研究JVM常见常见的非标准配置参数。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>JVM性能相关的配置参数</title>
      <link>http://nituchao.com/post/2016/jvm-xing-neng-xiang-guan-de-pei-zhi-can-shu/</link>
      <pubDate>Thu, 29 Dec 2016 09:30:12 +0800</pubDate>
      
      <guid>http://nituchao.com/post/2016/jvm-xing-neng-xiang-guan-de-pei-zhi-can-shu/</guid>
      <description>&lt;p&gt;本问将介绍JVM性能相关的配置参数。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>JVM配置参数-X与-XX的区别</title>
      <link>http://nituchao.com/post/2016/jvm-options-x-vs-xx/</link>
      <pubDate>Wed, 28 Dec 2016 13:14:12 +0800</pubDate>
      
      <guid>http://nituchao.com/post/2016/jvm-options-x-vs-xx/</guid>
      <description>

&lt;p&gt;启动JVM时通过指定配置参数来指导虚拟机按照我们的要求提供服务，这一点对大多数的Java程序员来说已经是司空见惯。&lt;/p&gt;

&lt;p&gt;在指定配置参数时，会有-X和-XX两种形式，那么它们两者有什么区别呢，今天我想借这篇文章总结一下。&lt;/p&gt;

&lt;p&gt;下面是我们的某个Java项目在正式环境上启动JVM时的一个典型命令，在该命令中指定了各种启动参数：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;java -Xmx15G \
-Xms10G \
-Xmn3G \
-Xss512k \
-XX:MaxPermSize=512M \
-XX:PermSize=512M \
-XX:+PrintFlagsFinal \
-XX:MaxTenuringThreshold=1 \
-XX:SurvivorRatio=23 \
-XX:TargetSurvivorRatio=80 \
-Xnoclassgc \
-XX:+UseParNewGC \
-XX:+UseConcMarkSweepGC \
-XX:CMSInitiatingOccupancyFraction=80 \
-XX:ParallelGCThreads=24 \
-XX:ConcGCThreads=24 \
-XX:+CMSParallelRemarkEnabled \
-XX:+CMSScavengeBeforeRemark \
-XX:+ExplicitGCInvokesConcurrent \
-XX:+UseTLAB \
-XX:TLABSize=64K, -verbose:gc \
-XX:+PrintGCDetails \
-XX:+PrintGCDateStamps \
-XX:+PrintGCTimeStamps \
-XX:+PrintGCApplicationStoppedTime \
-Xloggc:./gc.log
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Java HotSpot VM的官方文档中将启动参数分为如下两类：&lt;/p&gt;

&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th align=&#34;center&#34;&gt;配置 参数&lt;/th&gt;
&lt;th align=&#34;center&#34;&gt;类型&lt;/th&gt;
&lt;th align=&#34;left&#34;&gt;说明&lt;/th&gt;
&lt;th align=&#34;center&#34;&gt;举例&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;

&lt;tbody&gt;
&lt;tr&gt;
&lt;td align=&#34;center&#34;&gt;-X&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;non-standard&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;非标准参数。&lt;br/&gt;&lt;br/&gt;这些参数不是虚拟机规范规定的。因此，不是所有VM的实现(如:HotSpot,JRockit,J9等)都支持这些配置参数。&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;-Xmx、-Xms、-Xmn、-Xss&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;center&#34;&gt;-XX&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;not-stable&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;不稳定参数。&lt;br/&gt;&lt;br/&gt;这些参数是虚拟机规范中规定的。这些参数指定虚拟机实例在运行时的各种行为，从而对虚拟机的运行时性能有很大影响。&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;-XX:SurvivorRatio、-XX:+UseParNewGc&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;补充: -X和-XX两种参数都可能随着JDK版本的变更而发生变化，有些参数可以能会被废弃掉，有些参数的功能会发生改变，但是JDK官方不会通知开发者这些变化，需要使用者注意。&lt;/p&gt;

&lt;p&gt;-XX参数被称为不稳定参数，是因为这类参数的设置会引起JVM运行时性能上的差异，配置得当可以提高JVM性能，配置不当则会使JVM出现各种问题, 甚至造成JVM崩溃。&lt;/p&gt;

&lt;p&gt;国外有个哥们从HotSpot VM的源码里发现了934个此类型的配置参数，因此能对JVM做出很多组合配置，对JVM的调优也没有统一的标准，需要我们在实践中不断总结经验，并结合实际业务来进行操作，最终找到最适合当前业务的那些配置。&lt;/p&gt;

&lt;h2 id=&#34;一些有用的-xx配置&#34;&gt;一些有用的-XX配置&lt;/h2&gt;

&lt;p&gt;对于-XX类型的配置选项，虚拟机规范有一些惯例，针对不同的平台虚拟机也会提供不同的默认值。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;对于布尔(Boolean)类型的配置选项，通过&lt;code&gt;-XX:+&amp;lt;option&amp;gt;&lt;/code&gt;来开启，通过&lt;code&gt;-XX:-&amp;lt;option&amp;gt;&lt;/code&gt;来关闭。&lt;/li&gt;
&lt;li&gt;对于数字(Numberic)类型的配置选项，通过&lt;code&gt;-XX:&amp;lt;option&amp;gt;=&amp;lt;number&amp;gt;&lt;/code&gt;来配置。&lt;code&gt;&amp;lt;number&amp;gt;&lt;/code&gt;后面可以携带单位字母，比如: &amp;lsquo;k&amp;rsquo;或者&amp;rsquo;K&amp;rsquo;代表千字节，&amp;rsquo;m&amp;rsquo;或者&amp;rsquo;M&amp;rsquo;代表兆字节，&amp;rsquo;g&amp;rsquo;或者&amp;rsquo;G&amp;rsquo;代表千兆字节。&lt;/li&gt;
&lt;li&gt;对于字符串(String)类型的配置选项，通过&lt;code&gt;-XX:&amp;lt;option&amp;gt;=&amp;lt;string&amp;gt;&lt;/code&gt;来配置。这种配置通过用来指定文件，路径或者命令列表。&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;参考文献&#34;&gt;参考文献&lt;/h2&gt;

&lt;p&gt;1, &lt;a href=&#34;http://jvm-options.tech.xebia.fr/&#34;&gt;JVM Options - The complete reference&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;2, &lt;a href=&#34;http://www.oracle.com/technetwork/java/javase/tech/vmoptions-jsp-140102.html&#34;&gt;Java HotSpot VM Options&lt;/a&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Java通过信号量机制实现生产者消费者</title>
      <link>http://nituchao.com/post/2016/java-xin-hao-liang-ji-zhi-shi-xian-sheng-chan-zhe-xiao-fei-zhe/</link>
      <pubDate>Tue, 27 Dec 2016 16:12:12 +0800</pubDate>
      
      <guid>http://nituchao.com/post/2016/java-xin-hao-liang-ji-zhi-shi-xian-sheng-chan-zhe-xiao-fei-zhe/</guid>
      <description>

&lt;p&gt;信号量是一种计数器，用来保护一个或者多个共享资源的访问。Java提供了Semaphore类来实现信号量机制。&lt;/p&gt;

&lt;p&gt;如果线程要访问一个共享资源，它必须先获得信号量。如果信号量的内部计数器大于0，信号量将减1，然后允许访问这个共享资源。计数器大于0意味着有可以使用的资源，因此线程将被允许使用其中一个资源。&lt;/p&gt;

&lt;p&gt;否则，如果信号量的计数器等于0，信号量将会把线程置入休眠直至计数器大于0.计数器等于0的时候意味着所有的共享资源已经被其他线程使用了，所以需要访问这个共享资源的线程必须等待。&lt;/p&gt;

&lt;p&gt;当线程使用完某个共享资源时，信号量必须被释放，以便其他线程能够访问共享资源。释放操作将使信号量的内部计数器增加1。&lt;/p&gt;

&lt;h3 id=&#34;设计思想&#34;&gt;设计思想&lt;/h3&gt;

&lt;p&gt;为了使用信号量机制来实现生产者VS消费者模型，我们需要实例化一个二进制信号量对象，即内部计数器只有0和1两个值。多个生产者线程和多个消费者线程竞争这个信号量来互斥访问共享缓冲区。&lt;/p&gt;

&lt;p&gt;另外，由于共享缓冲区是有空间限制的，生产者在生产前要判断共享缓冲区空间是否充足。消费者在消费前要判断共享缓冲区内的元素是否足够消费。&lt;/p&gt;

&lt;h3 id=&#34;代码实现&#34;&gt;代码实现&lt;/h3&gt;

&lt;p&gt;基于上面的设计思想，我们需要实现共享缓冲区，生产者线程，消费者线程和主程序四部分。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;共享缓冲区&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;package com.nituchao.jvm.prosumer.semaphore;

import java.util.ArrayList;
import java.util.List;
import java.util.concurrent.Semaphore;

/**
 * 缓冲区
 * Created by liang on 2016/12/29.
 */
public class Buffer {
    private int MAX_SIZE = 100;
    private final List&amp;lt;String&amp;gt; list;
    private final Semaphore semaphore;

    public Buffer() {
        this.list = new ArrayList&amp;lt;&amp;gt;();
        this.semaphore = new Semaphore(1);
    }

    /**
     * 生产Buffer元素
     *
     * @param num
     */
    public boolean BufferProduct(int num) {
        boolean result = true;

        try {
            // 获取信号量
            semaphore.acquire();

            // 如果缓冲区能够容纳要生成的元素，允许生产
            if (list.size() + num &amp;lt;= MAX_SIZE) {
                // 开始生产
                for (int i = 1; i &amp;lt;= num; i++) {
                    list.add(0, Thread.currentThread().getName() + &amp;quot; : &amp;quot; + i);
                }

                result = true;

                System.out.printf(&amp;quot;Thread %s: Buffer Product succ, num is %d, buffer size is %d\n&amp;quot;, Thread.currentThread().getName(), num, list.size());
            } else {
                // 缓冲区无法容纳要生成的元素，禁止生产
                result = false;

                System.out.printf(&amp;quot;Thread %s: Buffer Product fail, num is %d, buffer size is %d\n&amp;quot;, Thread.currentThread().getName(), num, list.size());
            }
        } catch (InterruptedException e) {
            e.printStackTrace();
        } finally {
            semaphore.release();
        }

        return result;
    }

    /**
     * 消费Buffer元素
     *
     * @param num
     * @return
     */
    public boolean BufferConsume(int num) {
        boolean result = true;

        try {
            // 获取信号量
            semaphore.acquire();

            // 如果缓冲区中有足够的元素消费，允许消费
            if (list.size() - num &amp;gt;= 0) {
                // 开始消费
                for (int i = 1; i &amp;lt;= num; i++) {
                    String element = list.remove(0);
                }

                result = true;

                System.out.printf(&amp;quot;Thread: %s, Buffer Consume succ, num is %d, buffer size is %d\n&amp;quot;, Thread.currentThread().getName(), num, list.size());
            } else {
                // 缓冲取没有足够的元素供消费，禁止消费
                result = false;

                System.out.printf(&amp;quot;Thread: %s, Buffer Consume fail, num is %d, buffer size is %d\n&amp;quot;, Thread.currentThread().getName(), num, list.size());
            }
        } catch (InterruptedException e) {
            e.printStackTrace();
        } finally {
            semaphore.release();
        }

        return result;
    }
}

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;生产者线程&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;package com.nituchao.jvm.prosumer.semaphore;

import java.util.Random;
import java.util.concurrent.TimeUnit;

/**
 * 生产者线程
 * Created by liang on 2016/12/29.
 */
public class BufferProducer implements Runnable {
    private Buffer buffer;
    private int num;

    public BufferProducer(Buffer buffer, int num) {
        this.buffer = buffer;
        this.num = num;
    }

    @Override
    public void run() {
        while (!buffer.BufferProduct(num)) {
            try {
                TimeUnit.MILLISECONDS.sleep(new Random(1000).nextInt());
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
        }
    }
}


&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;消费者线程&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;package com.nituchao.jvm.prosumer.semaphore;

import java.util.Random;
import java.util.concurrent.TimeUnit;

/**
 * 消费者线程
 * Created by liang on 2016/12/29.
 */
public class BufferConsumer implements Runnable {
    private Buffer buffer;
    private int num;

    public BufferConsumer(Buffer buffer, int num) {
        this.buffer = buffer;
        this.num = num;
    }

    @Override
    public void run() {
        while (!buffer.BufferConsume(num)) {
            try {
                TimeUnit.MILLISECONDS.sleep(new Random(1000).nextInt());
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
        }
    }
}

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;主程序&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;package com.nituchao.jvm.prosumer.semaphore;

/**
 * 主程序
 * Created by liang on 2016/12/29.
 */
public class BufferMain {

    public static void main(String[] args) {
        int num = 10;

        // 初始化Buffer对象
        Buffer buffer = new Buffer();

        // 实例化num个生产者和消费者线程
        Thread[] threadProducers = new Thread[num];
        Thread[] threadConsumers = new Thread[num];

        for (int i = 0; i &amp;lt; num; i++) {
            threadProducers[i] = new Thread(new BufferProducer(buffer, i + 1));
            threadConsumers[i] = new Thread(new BufferConsumer(buffer, i + 1));
        }

        // 分别启动生产者和消费者线程
        for (int i = 0; i &amp;lt; num; i++) {
            // 故意先开始消费
            threadConsumers[i].start();

            // 故意后开始生产
            threadProducers[i].start();
        }
    }
}

&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;运行结果&#34;&gt;运行结果&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;Connected to the target VM, address: &#39;127.0.0.1:61012&#39;, transport: &#39;socket&#39;
Thread: Thread-1, Buffer Consume fail, num is 1, buffer size is 0
Thread Thread-0: Buffer Product succ, num is 1, buffer size is 1
Thread: Thread-3, Buffer Consume fail, num is 2, buffer size is 1
Thread Thread-2: Buffer Product succ, num is 2, buffer size is 3
Thread: Thread-5, Buffer Consume succ, num is 3, buffer size is 0
Thread Thread-4: Buffer Product succ, num is 3, buffer size is 3
Thread: Thread-7, Buffer Consume fail, num is 4, buffer size is 3
Thread: Thread-7, Buffer Consume fail, num is 4, buffer size is 3
Thread: Thread-7, Buffer Consume fail, num is 4, buffer size is 3
Thread: Thread-7, Buffer Consume fail, num is 4, buffer size is 3
Thread: Thread-7, Buffer Consume fail, num is 4, buffer size is 3
Thread: Thread-7, Buffer Consume fail, num is 4, buffer size is 3
Thread Thread-6: Buffer Product succ, num is 4, buffer size is 7
Thread: Thread-9, Buffer Consume succ, num is 5, buffer size is 2
Thread Thread-8: Buffer Product succ, num is 5, buffer size is 7
Thread: Thread-11, Buffer Consume succ, num is 6, buffer size is 1
Thread Thread-10: Buffer Product succ, num is 6, buffer size is 7
Thread: Thread-13, Buffer Consume succ, num is 7, buffer size is 0
Thread Thread-12: Buffer Product succ, num is 7, buffer size is 7
Thread: Thread-15, Buffer Consume fail, num is 8, buffer size is 7
Thread: Thread-15, Buffer Consume fail, num is 8, buffer size is 7
Thread: Thread-15, Buffer Consume fail, num is 8, buffer size is 7
Thread: Thread-15, Buffer Consume fail, num is 8, buffer size is 7
Thread: Thread-15, Buffer Consume fail, num is 8, buffer size is 7
Thread Thread-14: Buffer Product succ, num is 8, buffer size is 15
Thread: Thread-17, Buffer Consume succ, num is 9, buffer size is 6
Thread Thread-16: Buffer Product succ, num is 9, buffer size is 15
Thread: Thread-19, Buffer Consume succ, num is 10, buffer size is 5
Thread Thread-18: Buffer Product succ, num is 10, buffer size is 15
Thread: Thread-3, Buffer Consume succ, num is 2, buffer size is 13
Thread: Thread-1, Buffer Consume succ, num is 1, buffer size is 12
Thread: Thread-7, Buffer Consume succ, num is 4, buffer size is 8
Thread: Thread-15, Buffer Consume succ, num is 8, buffer size is 0
Disconnected from the target VM, address: &#39;127.0.0.1:61012&#39;, transport: &#39;socket&#39;

Process finished with exit code 0
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;工作原理&#34;&gt;工作原理&lt;/h3&gt;

&lt;p&gt;主程序首先实例化一个二进制信号量对象semaphore，指定该信号量内部计数器只有0和1，这样可以保证同一时间只有一个线程能够访问共享缓冲区。这样一来，共享缓冲区buffer本质上就成为一个队列。&lt;/p&gt;

&lt;p&gt;主程序实例化num个生产者线程和num个消费者线程。&lt;/p&gt;

&lt;p&gt;生产者线程负责向缓冲区里生产元素，每个生产者生产的数量都各不相同，从而能更好的观察效果。生产者首先会去尝试获取信号量(acquire)，然后检查当前共享缓冲区是否有足够空间容纳自己可生产的元素。如果有，则进行生产，如果没有，则不进行生产。最后，释放信号量(release)并把生产的结果返回(boolen)。生产者线程如果发现自己生产失败，则会随机休眠一段时间再重复上面的操作，直到生产操作成功。&lt;/p&gt;

&lt;p&gt;消费者线程负责从缓冲区里消费元素，每个消费者消费的数量都各不相同，从而能更好的观察效果。消费者首先回去尝试获取信号量(acquire)，然后检查当前共享缓冲区中是否有足够的元素供自己消费。如果有，则进行消费，如果没有，则不进行消费。最后，释放信号量(release)并把消费的结果返回(boolean)。消费者线程如果发现自己消费失败，则会随机休眠一段时间再重复上面的操作，直到消费操作成功。&lt;/p&gt;

&lt;p&gt;生产者线程和消费者线程访问是信号量是公平竞争，第一个获取信号量的线程将能够访问临界区，其余的线程将被信号量阻塞，直到信号量被释放。一旦信号量被释放，被被阻塞的线程就可以重新竞争信号量并访问临界区。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Java通过重入锁实现生产者消费者</title>
      <link>http://nituchao.com/post/2016/java-chong-ru-suo-shi-xian-sheng-chan-zhe-xiao-fei-zhe/</link>
      <pubDate>Tue, 27 Dec 2016 16:12:12 +0800</pubDate>
      
      <guid>http://nituchao.com/post/2016/java-chong-ru-suo-shi-xian-sheng-chan-zhe-xiao-fei-zhe/</guid>
      <description>

&lt;p&gt;ReentrantLock是一个可重入的互斥锁，又被称为&amp;rdquo;独占锁&amp;rdquo;，ReentrantLock锁在同一个时间点只能被一个线程锁持有，而可重入的意思是，ReentrantLock可以被单个线程多次获取，ReentrantLock的性能并不高，优点是比价灵活。ReentrantLock比Synchronized关键词更加灵活，并且能支持条件变量，后面我还会单独介绍使用条件变量实现生产者消费者模型的方法。&lt;/p&gt;

&lt;h3 id=&#34;设计思想&#34;&gt;设计思想&lt;/h3&gt;

&lt;p&gt;本文希望同ReentrantLock来实现一个共享缓冲区，生产者线程和消费者线程通过该共享缓冲区来实现相关的生产和消费操作，每个线程对共享缓冲区的访问是互斥的。&lt;/p&gt;

&lt;p&gt;另外，由于共享缓冲区是有空间限制的，生产者在生产前要判断共享缓冲区空间是否充足。消费者在消费前要判断共享缓冲区内的元素是否足够消费。&lt;/p&gt;

&lt;h3 id=&#34;代码实现&#34;&gt;代码实现&lt;/h3&gt;

&lt;p&gt;根据上面的设计思想，我们需要实现共享缓冲区，生产者线程，消费者线程，主程序等四个部分。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;共享缓冲区&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;package com.nituchao.jvm.prosumer.reentrant;

import java.util.ArrayList;
import java.util.List;
import java.util.concurrent.locks.Lock;
import java.util.concurrent.locks.ReentrantLock;

/**
 * 共享缓冲区
 * Created by liang on 2016/12/30.
 */
public class Buffer {
    private final List&amp;lt;String&amp;gt; list;
    private int MAX_SIZE = 10;
    private final Lock lock;

    public Buffer() {
        this.list = new ArrayList&amp;lt;String&amp;gt;();
        this.lock = new ReentrantLock();
    }

    /**
     * 生产num个元素
     *
     * @param num
     * @return
     */
    public boolean bufferProduct(int num) {
        boolean result = true;
        try {
            lock.lock();

            // 检查缓冲区是否能够容纳要生产的元素
            if (list.size() + num &amp;lt;= MAX_SIZE) {
                // 开始生产
                for (int i = 0; i &amp;lt; num; i++) {
                    list.add(0, Thread.currentThread().getName() + &amp;quot;:&amp;quot; + (i + 1));
                }

                result = true;

                System.out.printf(&amp;quot;Thread %s: Buffer Product succ, num is %d, buffer size is %d\n&amp;quot;, Thread.currentThread().getName(), num, list.size());
            } else {
                result = false;

                System.out.printf(&amp;quot;Thread %s: Buffer Product succ, num is %d, buffer size is %d\n&amp;quot;, Thread.currentThread().getName(), num, list.size());
            }
        } catch (Exception e) {
            e.printStackTrace();
            result = false;
        } finally {
            lock.unlock();
        }

        return result;
    }

    /**
     * 消费num个元素
     *
     * @param num
     * @return
     */
    public boolean bufferConsume(int num) {
        boolean result = false;
        try {
            lock.lock();

            // 检查缓冲区是否有足够的元素供消费
            if (list.size() &amp;gt;= num) {
                // 开始消费
                for (int i = 0; i &amp;lt; num; i++) {
                    list.remove(0);
                }

                result = true;

                System.out.printf(&amp;quot;Thread: %s, Buffer Consume succ, num is %d, buffer size is %d\n&amp;quot;, Thread.currentThread().getName(), num, list.size());
            } else {
                result = false;

                System.out.printf(&amp;quot;Thread: %s, Buffer Consume fail, num is %d, buffer size is %d\n&amp;quot;, Thread.currentThread().getName(), num, list.size());
            }
        } catch (Exception e) {
            e.printStackTrace();
            result = false;
        } finally {
            lock.unlock();
        }

        return result;
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;生产者线程&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;package com.nituchao.jvm.prosumer.reentrant;

import java.util.Random;
import java.util.concurrent.TimeUnit;

/**
 * 生产者线程
 * Created by liang on 2016/12/30.
 */
public class BufferProducer implements Runnable {
    private int num;
    private Buffer buffer;

    public BufferProducer(Buffer buffer, int num) {
        this.num = num;
        this.buffer = buffer;
    }

    @Override
    public void run() {
        // 生产num个元素，如果生产失败，则休眠一段时间重新生产
        while (!buffer.bufferProduct(num)) {
            try {
                TimeUnit.MILLISECONDS.sleep(new Random(1000).nextInt());
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
        }
    }
}

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;消费者线程&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;package com.nituchao.jvm.prosumer.reentrant;

import java.util.Random;
import java.util.concurrent.TimeUnit;

/**
 * 消费者线程
 * Created by liang on 2016/12/30.
 */
public class BufferConsumer implements Runnable {
    private int num;
    private Buffer buffer;

    public BufferConsumer(Buffer buffer, int num) {
        this.num = num;
        this.buffer = buffer;
    }

    @Override
    public void run() {
        // 消费num个产品，如果消费失败，则休眠一段时间再重新消费
        while (!buffer.bufferConsume(num)) {
            try {
                TimeUnit.MILLISECONDS.sleep(new Random(1000).nextInt());
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
        }
    }
}

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;主程序&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;package com.nituchao.jvm.prosumer.reentrant;

/**
 * 主程序
 * Created by liang on 2016/12/30.
 */
public class BufferMain {

    public static void main(String[] args) {
        int num = 10;
        // 实例化Buffer
        Buffer buffer = new Buffer();

        // 实例化生产者和消费者线程集合
        Thread[] threadProducers = new Thread[num];
        Thread[] threadConsumers = new Thread[num];

        // 实例化生产者和消费者线程
        for (int i = 0; i &amp;lt; num; i++) {
            Thread threadProducer = new Thread(new BufferProducer(buffer, i + 1));
            Thread threadConsumer = new Thread(new BufferConsumer(buffer, i + 1));

            threadProducers[i] = threadProducer;
            threadConsumers[i] = threadConsumer;
        }

        // 启动生产者和消费者线程
        for (int i = 0; i &amp;lt; num; i++) {
            threadConsumers[i].start();

            threadProducers[i].start();
        }
    }
}

&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;运行结果&#34;&gt;运行结果&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;Connected to the target VM, address: &#39;127.0.0.1:53178&#39;, transport: &#39;socket&#39;
Thread: Thread-1, Buffer Consume fail, num is 1, buffer size is 0
Thread Thread-0: Buffer Product succ, num is 1, buffer size is 1
Thread: Thread-3, Buffer Consume fail, num is 2, buffer size is 1
Thread Thread-2: Buffer Product succ, num is 2, buffer size is 3
Thread: Thread-3, Buffer Consume succ, num is 2, buffer size is 1
Thread: Thread-5, Buffer Consume fail, num is 3, buffer size is 1
Thread: Thread-5, Buffer Consume fail, num is 3, buffer size is 1
Thread: Thread-5, Buffer Consume fail, num is 3, buffer size is 1
Thread Thread-4: Buffer Product succ, num is 3, buffer size is 4
Thread: Thread-7, Buffer Consume succ, num is 4, buffer size is 0
Thread Thread-6: Buffer Product succ, num is 4, buffer size is 4
Thread: Thread-9, Buffer Consume fail, num is 5, buffer size is 4
Thread: Thread-9, Buffer Consume fail, num is 5, buffer size is 4
Thread: Thread-9, Buffer Consume fail, num is 5, buffer size is 4
Thread Thread-8: Buffer Product succ, num is 5, buffer size is 9
Thread: Thread-11, Buffer Consume succ, num is 6, buffer size is 3
Thread Thread-10: Buffer Product succ, num is 6, buffer size is 9
Thread: Thread-13, Buffer Consume succ, num is 7, buffer size is 2
Thread Thread-12: Buffer Product succ, num is 7, buffer size is 9
Thread: Thread-15, Buffer Consume succ, num is 8, buffer size is 1
Thread Thread-14: Buffer Product succ, num is 8, buffer size is 9
Thread: Thread-17, Buffer Consume succ, num is 9, buffer size is 0
Thread Thread-16: Buffer Product succ, num is 9, buffer size is 9
Thread: Thread-19, Buffer Consume fail, num is 10, buffer size is 9
Thread: Thread-19, Buffer Consume fail, num is 10, buffer size is 9
Thread: Thread-19, Buffer Consume fail, num is 10, buffer size is 9
Thread: Thread-19, Buffer Consume fail, num is 10, buffer size is 9
Thread: Thread-19, Buffer Consume fail, num is 10, buffer size is 9
Thread Thread-18: Buffer Product succ, num is 10, buffer size is 9
Thread: Thread-1, Buffer Consume succ, num is 1, buffer size is 8
Thread: Thread-5, Buffer Consume succ, num is 3, buffer size is 5
Thread: Thread-9, Buffer Consume succ, num is 5, buffer size is 0
Thread: Thread-19, Buffer Consume fail, num is 10, buffer size is 0
Thread: Thread-19, Buffer Consume fail, num is 10, buffer size is 0
Thread: Thread-19, Buffer Consume fail, num is 10, buffer size is 0
Thread: Thread-19, Buffer Consume fail, num is 10, buffer size is 0
Thread: Thread-19, Buffer Consume fail, num is 10, buffer size is 0
Disconnected from the target VM, address: &#39;127.0.0.1:53178&#39;, transport: &#39;socket&#39;
Thread: Thread-19, Buffer Consume fail, num is 10, buffer size is 0
Thread Thread-18: Buffer Product succ, num is 10, buffer size is 10
Thread: Thread-19, Buffer Consume succ, num is 10, buffer size is 0

Process finished with exit code 0

&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;工作原理&#34;&gt;工作原理&lt;/h3&gt;

&lt;p&gt;主程序首先实例化一个共享缓冲区对象buffer，然后将该共享缓冲区对象buffer作为构造参数生成若干个生产者线程，和若干个消费者线程。&lt;/p&gt;

&lt;p&gt;生产者线程调用共享缓冲区的bufferProduce(num)方法生产元素，在生产前要先获取锁(lock.lock()方法)，并判断当前共享缓冲区是否能够容纳所有元素，如果不能容纳，则直接返回false，并释放锁。如果可以容纳，则进行生产活动，返回true，并释放锁。生产者线程在一个while循环里判断，如果生产失败(返回false)，则等待一段时间，重新开始执行生产操作。如果生产成功，则结束当前线程。&lt;/p&gt;

&lt;p&gt;消费者线程调用共享缓冲区的bufferConsume(num)方法消费元素，在生产前要先获取锁(lock.lock()方法)，并判断当前共享缓冲区是否有足够的元素供消费，如果元素数量不够，则直接返回false，并释放锁。如果元素足够，则进行消费活动，返回true，并释放锁。消费者线程在一个while循环里判断，如果消费失败(返回false)，则等待一段时间，重新开始执行消费操作。如果消费成功，则结束当前线程。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Java通过阻塞队列实现生产者消费者</title>
      <link>http://nituchao.com/post/2016/java-zu-se-dui-lie-shi-xian-sheng-chan-xiao-fei-zhe/</link>
      <pubDate>Tue, 27 Dec 2016 16:10:12 +0800</pubDate>
      
      <guid>http://nituchao.com/post/2016/java-zu-se-dui-lie-shi-xian-sheng-chan-xiao-fei-zhe/</guid>
      <description>&lt;p&gt;Java通过阻塞队列实现生产者消费者。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Java通过对象同步机制实现生产者消费者</title>
      <link>http://nituchao.com/post/2016/java-dui-xiang-suo-shi-xian-sheng-chan-zhe-xiao-fei-zhe/</link>
      <pubDate>Tue, 27 Dec 2016 12:54:28 +0800</pubDate>
      
      <guid>http://nituchao.com/post/2016/java-dui-xiang-suo-shi-xian-sheng-chan-zhe-xiao-fei-zhe/</guid>
      <description>

&lt;p&gt;每个Java类都是从Object类派生出来的，Object类原生提供了wait(),notify(),notifyAll()等方法来实现线程间的同步控制。&lt;/p&gt;

&lt;p&gt;进一步讲，每个对象都能当做一个锁，每个对象也能当做一个条件队列，对象中的wait(), notify(), notifyAll()方法构成了内部条件队列的API，而队列正是生产者消费者模型的一个关键元素。当对象调用wait()方法时，当前线程会释放获得的对象锁，同时，当前对象会请求操作系统挂起当前线程，此时对象的对象锁就可用了，允许其他等待线程进入。当对象调用notify()或者notifyAll()方法时，当前线程也会释放获得的对象锁，同时，操作系统会结束当前线程的执行，并从阻塞在该对象上的线程列表中选择一个进行唤醒，该线程会获得对线锁并被让操作系统调度。&lt;/p&gt;

&lt;h3 id=&#34;设计思想&#34;&gt;设计思想&lt;/h3&gt;

&lt;p&gt;为了设计基于Java对象同步机制的生产者消费者程序，并且是多个生产者线程VS多个消费者线程，可以从以下三点出发。&lt;/p&gt;

&lt;p&gt;首先，我们需要有一个缓冲区来充当生产者和消费者之间交换数据的媒介，这个缓冲区可以是一个普通的列表对象，我们在该列表对象上进行生产者和消费者的互斥访问控制。本质上讲，这个缓冲器就相当于一个队列，一方面允许生产者往里面添加数据，一方面允许消费者从里面取走数据。这个列表对象非常重要，所有的wait()和notify()操作以及对象锁的控制都是针对该对象的。因此，这是一个共享对象，在各个生产者线程和消费者线程之间充当媒介。&lt;/p&gt;

&lt;p&gt;其次，我们需要有若干个生产者线程。生产者线程要争夺缓冲区对象锁，如果未得到锁则wait()进入阻塞等待被唤醒。如果得到了对象锁，还要判断缓冲区是否已满。如果缓冲区已满，则要wait()进入阻塞等待被唤醒，并释放缓冲区对象锁。如果缓冲区未满，则可以进行生产活动，结束后释放缓冲区对象锁，并唤醒一个阻塞的线程。&lt;/p&gt;

&lt;p&gt;最后，我们需要有若干个消费者线程。消费者线程要争夺缓冲区对象锁，如果未得到锁则wait()进行阻塞等待被唤醒。如果得到了对象锁，还要判断缓冲区里的元素是否满足自己的需要。如果缓冲区里的元素不够自己消费，则要wait()进入阻塞等待被唤醒，并释放缓冲区对象锁。如果缓冲区里的元素满足自己的需要，则进行消费操作，结束后释放缓冲区对象锁，并唤醒一个阻塞的线程。&lt;/p&gt;

&lt;h3 id=&#34;代码实现&#34;&gt;代码实现&lt;/h3&gt;

&lt;p&gt;基于上面的设计，我们需要实现共享缓冲区，生产者线程，消费者线程和主程序四部分。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;共享缓冲区&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;package com.nituchao.jvm.prosumer.objectsync;

import java.util.Date;
import java.util.LinkedList;

/**
 * 共享缓冲区
 * Created by liang on 2016/12/15.
 */
public class Buffer {
    private static final int MAX_SIZE = 100;
    private LinkedList&amp;lt;String&amp;gt; list;

    public Buffer(LinkedList&amp;lt;String&amp;gt; list) {
        this.list = list;
    }

    /**
     * 生产n个产品
     *
     * @param num
     * @throws InterruptedException
     */
    public void BufferProduce(int num) throws InterruptedException {
        synchronized (list) {
            while (list.size() + num &amp;gt; MAX_SIZE) {
                System.out.println(&amp;quot;【要生产的产品数量】:&amp;quot; + num + &amp;quot;/t【库存量】:&amp;quot; + list.size() + &amp;quot;/t暂时不能执行生产任务!&amp;quot;);

                // list进入等待状态
                list.wait();
            }

            // 生产n个产品
            for (int i = 0; i &amp;lt; num; i++) {
                list.add(new Date() + &amp;quot; : &amp;quot; + i);
            }

            System.out.println(&amp;quot;【已经生产产品数】:&amp;quot; + num + &amp;quot;/t【现仓储量为】:&amp;quot; + list.size());

            list.notifyAll();
        }
    }

    /**
     * 消费n个产品
     *
     * @param num
     * @throws InterruptedException
     */
    public void bufferConsume(int num) throws InterruptedException {
        synchronized (list) {
            while (list.size() &amp;lt; num) {
                System.out.println(&amp;quot;【要消费的产品数量】:&amp;quot; + num + &amp;quot;/t【库存量】:&amp;quot; + list.size() + &amp;quot; /t暂时不能执行消费任务!&amp;quot;);

                // list进入等待状态
                list.wait();
            }

            // 消费n个产品
            for (int i = 0; i &amp;lt; num; i++) {
                list.removeFirst();
            }

            System.out.println(&amp;quot;【已经消费产品数】:&amp;quot; + num + &amp;quot;/t【现仓储量为】:&amp;quot; + list.size());

            list.notifyAll();
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;生产者线程&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;package com.nituchao.jvm.prosumer.objectsync;

/**
 * 生产者线程
 * Created by liang on 2016/12/30.
 */
public class BufferProducer implements Runnable {
    private Buffer buffer;
    private int num;

    public BufferProducer(Buffer buffer, int num) {
        this.buffer = buffer;
        this.num = num;
    }

    @Override
    public void run() {
        try {
            buffer.BufferProduce(num);
        } catch (Exception e) {
            e.printStackTrace();
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;消费者线程&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;package com.nituchao.jvm.prosumer.objectsync;

/**
 * 消费者线程
 * Created by liang on 2016/12/30.
 */
public class BufferConsumer implements Runnable {
    private Buffer buffer;
    private int num;

    public BufferConsumer(Buffer buffer, int num) {
        this.buffer = buffer;
        this.num = num;
    }

    @Override
    public void run() {
        try {
            buffer.bufferConsume(num);
        } catch (Exception e) {
            e.printStackTrace();
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;主程序&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;package com.nituchao.jvm.prosumer.objectsync;

import java.util.LinkedList;

/**
 * 主程序
 * Created by liang on 2016/12/30.
 */
public class BufferMain {
    public static void main(String[] args) {
        int num = 10;
        LinkedList&amp;lt;String&amp;gt; list = new LinkedList&amp;lt;&amp;gt;();
        Thread[] threadProducers = new Thread[num];
        Thread[] threadConsumers = new Thread[num];
        Buffer buffer = new Buffer(list);

        for (int i = 0; i &amp;lt; num; i++) {
            Thread threadTmp = new Thread(new BufferProducer(buffer, 10 + i));
            threadProducers[i] = threadTmp;
        }

        for (int i = 0; i &amp;lt; num; i++) {
            Thread threadTmp = new Thread(new BufferConsumer(buffer, 10 + i));
            threadConsumers[i] = threadTmp;
        }

        for (int i = 0; i &amp;lt; num; i++) {
            threadProducers[i].start();
            threadConsumers[i].start();
        }

        System.out.printf(&amp;quot;list size is [%d].\n&amp;quot;, list.size());
    }
}

&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;运行结果&#34;&gt;运行结果&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;【要消费的产品数量】:10/t【库存量】:0 /t暂时不能执行消费任务!
【要消费的产品数量】:12/t【库存量】:0 /t暂时不能执行消费任务!
【要消费的产品数量】:13/t【库存量】:0 /t暂时不能执行消费任务!
list size is [0].
【已经生产产品数】:12/t【现仓储量为】:12
【已经消费产品数】:11/t【现仓储量为】:1
【已经生产产品数】:11/t【现仓储量为】:12
【已经生产产品数】:10/t【现仓储量为】:22
【已经消费产品数】:13/t【现仓储量为】:9
【要消费的产品数量】:12/t【库存量】:9 /t暂时不能执行消费任务!
【要消费的产品数量】:10/t【库存量】:9 /t暂时不能执行消费任务!
【要消费的产品数量】:19/t【库存量】:9 /t暂时不能执行消费任务!
【已经生产产品数】:19/t【现仓储量为】:28
【已经消费产品数】:18/t【现仓储量为】:10
【已经生产产品数】:18/t【现仓储量为】:28
【已经消费产品数】:17/t【现仓储量为】:11
【已经生产产品数】:17/t【现仓储量为】:28
【已经消费产品数】:16/t【现仓储量为】:12
【已经生产产品数】:16/t【现仓储量为】:28
【已经消费产品数】:15/t【现仓储量为】:13
【已经生产产品数】:15/t【现仓储量为】:28
【已经消费产品数】:14/t【现仓储量为】:14
【已经生产产品数】:14/t【现仓储量为】:28
【已经生产产品数】:13/t【现仓储量为】:41
【已经消费产品数】:19/t【现仓储量为】:22
【已经消费产品数】:10/t【现仓储量为】:12
【已经消费产品数】:12/t【现仓储量为】:0

Process finished with exit code 0
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;工作原理&#34;&gt;工作原理&lt;/h3&gt;

&lt;p&gt;共享缓冲区是此程序的核心，它里面内聚了一个普通的列表list。&lt;/p&gt;

&lt;p&gt;在生产产品时，首先通过synchronized关键字获取列表list的对象锁，然后进行业务判断，如果当前集合的剩余空间无法容纳要生产的元素，则调用list.wait()，进入等待状态，并释放list对象锁，使其他线程有机会获取对象锁。如果可以生产，则进行相关操作，最后通过调用list.notifyAll()来唤醒等待状态中的线程，并释放list对象锁。&lt;/p&gt;

&lt;p&gt;在消费产品时，首先通过synchronized关键字获取列表list的对象锁，然后进行业务判断，如果当前集合中没有足够的元素供消费，则调用list.wait()，进入等待状态，并释放list对象锁，使其他线程有机会获取对象锁。如果可以消费，则进行相关操作，最后通过调用list.notifyAll()来唤醒等待状态中的线程，并释放对象锁。&lt;/p&gt;

&lt;p&gt;由于缓冲池实现了共享数据结构的访问和同步，因此生产者线程和消费者线程的实现就相对简单，只是调用共享缓冲池的生产方法和消费方法。&lt;/p&gt;

&lt;p&gt;使用对象锁实现生产者消费者的另一个关键点在于，生产者和消费者要使用同一个共享缓冲池对象，即buffer对象。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Java通过Exchange机制实现生产者消费者</title>
      <link>http://nituchao.com/post/2016/java-exchange-shi-xian-sheng-chan-zhe-xiao-fei-zhe/</link>
      <pubDate>Sat, 26 Nov 2016 22:17:12 +0800</pubDate>
      
      <guid>http://nituchao.com/post/2016/java-exchange-shi-xian-sheng-chan-zhe-xiao-fei-zhe/</guid>
      <description>

&lt;p&gt;Java并发API提供了一个同步辅助类&amp;mdash;Exchanger，它允许并发线程之间交换数据。具体来说，Exchanger类允许在两个线程之间定义同步点(Synchronization Point)。当两个线程都达到同步点时，它们交换数据结构，因此第一个线程的数据结构进入到第二个线程中，同时第二个线程的数据结构进入到第一个线程。&lt;/p&gt;

&lt;p&gt;生产者VS消费者模型本质上就是两个线程交换数据。因此，对于只有一个生产者和一个消费者的场景，就可以使用Exchanger类。&lt;/p&gt;

&lt;h3 id=&#34;设计思想&#34;&gt;设计思想&lt;/h3&gt;

&lt;p&gt;为了通过Exchanger类实现生产者VS消费者模型，我们在设计的时候需要考虑以下三点：&lt;/p&gt;

&lt;p&gt;1, 生产者线程和消费者线程需要各自持有一个自己的缓冲区对象。&lt;/p&gt;

&lt;p&gt;2, 生产者线程和消费者线程需要持有一个共同的Exchanger对象，通过该对象实现两个线程的同步和数据结构交换。&lt;/p&gt;

&lt;p&gt;3, 消费者每次交换前，需要清空自己的数据结构，因为消费者不需要给生产者传递数据。&lt;/p&gt;

&lt;h3 id=&#34;代码实现&#34;&gt;代码实现&lt;/h3&gt;

&lt;p&gt;基于上面的设计，分别实现了生产者线程，消费者线程，主程序。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;生产者线程&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;package com.nituchao.jvm.prosumer.exchanger;

import java.util.List;
import java.util.concurrent.Exchanger;

/**
 * 生产者
 * Created by liang on 2016/11/26.
 */
public class BufferProducer implements Runnable {
    private List&amp;lt;String&amp;gt; buffer;
    private final Exchanger&amp;lt;List&amp;lt;String&amp;gt;&amp;gt; exchanger;

    public BufferProducer(List&amp;lt;String&amp;gt; buffer, Exchanger&amp;lt;List&amp;lt;String&amp;gt;&amp;gt; exchanger) {
        this.buffer = buffer;
        this.exchanger = exchanger;
    }

    @Override
    public void run() {
        // 循环10次数据交换
        int cycle = 1;
        for (int i = 0; i &amp;lt; 10; i++) {
            System.out.printf(&amp;quot;Buffer Producer: Cycle %d\n&amp;quot;, cycle);

            // 在每个循环中，添加10个字符串到buffer列表中
            for (int j = 0; j &amp;lt; 10; j++) {
                String message = &amp;quot;Data &amp;quot; + ((i * 10) + j);
                System.out.printf(&amp;quot;Buffer Producer: %s\n&amp;quot;, message);
                buffer.add(message);
            }

            // 调用exchange()方法与消费者进行数据交换
            try {
                buffer = exchanger.exchange(buffer);
            } catch (InterruptedException e) {
                e.printStackTrace();
            }

            System.out.printf(&amp;quot;Exchange ok, Cycle %d, Buffer Producer size: %d\n&amp;quot;, cycle, buffer.size());
            cycle++;
        }
    }
}

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;消费者线程&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;package com.nituchao.jvm.prosumer.exchanger;

import java.util.List;
import java.util.concurrent.Exchanger;

/**
 * 消费者
 * Created by liang on 2016/11/26.
 */
public class BufferConsumer implements Runnable {
    private List&amp;lt;String&amp;gt; buffer;
    private final Exchanger&amp;lt;List&amp;lt;String&amp;gt;&amp;gt; exchanger;

    public BufferConsumer(List&amp;lt;String&amp;gt; buffer, Exchanger&amp;lt;List&amp;lt;String&amp;gt;&amp;gt; exchanger) {
        this.buffer = buffer;
        this.exchanger = exchanger;
    }

    @Override
    public void run() {
        // 循环10次交换数据
        int cycle = 1;
        for (int i = 0; i &amp;lt; 10; i++) {
            System.out.printf(&amp;quot;Buffer Consumer: Cycle %d\n&amp;quot;, cycle);

            // 在每个循环中，调用exchange()方法与生产者同步，消费数据
            try {
                buffer = exchanger.exchange(buffer);
            } catch (InterruptedException e) {
                e.printStackTrace();
            }

            System.out.printf(&amp;quot;Exchnage ok, Cycle %d, Buffer Consumer size: %d\n&amp;quot;, cycle, buffer.size());
            // 消费buffer中的数据，并情况列表
            for (int j = 0; j &amp;lt; 10; j++) {
                String message = buffer.get(0);
                System.out.println(&amp;quot;Buffer Consumer: &amp;quot; + message);
                buffer.remove(0);
            }

            cycle++;
        }
    }
}

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;主程序&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;package com.nituchao.jvm.prosumer.exchanger;

import java.util.ArrayList;
import java.util.List;
import java.util.concurrent.Exchanger;

/**
 * 主程序
 * Created by liang on 2016/11/26.
 */
public class BufferMain {
    public static void main(String[] args) {
        // 为生产者和消费者各创建一个缓冲区
        List&amp;lt;String&amp;gt; buffer1 = new ArrayList&amp;lt;&amp;gt;();
        List&amp;lt;String&amp;gt; buffer2 = new ArrayList&amp;lt;&amp;gt;();

        // 创建Exchanger对象，用来同步生产者和消费者
        Exchanger&amp;lt;List&amp;lt;String&amp;gt;&amp;gt; exchanger = new Exchanger&amp;lt;&amp;gt;();

        // 创建生产者Producer对象和消费者对象Consumer对象
        BufferProducer bufferProducer = new BufferProducer(buffer1, exchanger);
        BufferConsumer bufferConsumer = new BufferConsumer(buffer2, exchanger);

        // 创建生产者线程和消费者线程
        Thread threadProducer = new Thread(bufferProducer);
        Thread threadConsumer = new Thread(bufferConsumer);

        // 启动
        threadProducer.start();
        threadConsumer.start();
    }
}

&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;运行结果&#34;&gt;运行结果&lt;/h3&gt;

&lt;p&gt;运行上面的主程序，得到的输出信息如下:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;Connected to the target VM, address: &#39;127.0.0.1:55618&#39;, transport: &#39;socket&#39;
Buffer Producer: Cycle 1
Buffer Consumer: Cycle 1
Buffer Producer: Data 0
Buffer Producer: Data 1
Buffer Producer: Data 2
Buffer Producer: Data 3
Buffer Producer: Data 4
Buffer Producer: Data 5
Buffer Producer: Data 6
Buffer Producer: Data 7
Buffer Producer: Data 8
Buffer Producer: Data 9
Exchange ok, Cycle 1, Buffer Producer size: 0
Buffer Producer: Cycle 2
Exchnage ok, Cycle 1, Buffer Consumer size: 10
Buffer Producer: Data 10
Buffer Consumer: Data 0
Buffer Producer: Data 11
Buffer Consumer: Data 1
Buffer Producer: Data 12
Buffer Consumer: Data 2
Buffer Producer: Data 13
Buffer Consumer: Data 3
Buffer Producer: Data 14
Buffer Consumer: Data 4
Buffer Producer: Data 15
Buffer Consumer: Data 5
Buffer Producer: Data 16
Buffer Consumer: Data 6
Buffer Producer: Data 17
Buffer Consumer: Data 7
Buffer Producer: Data 18
Buffer Consumer: Data 8
Buffer Producer: Data 19
Buffer Consumer: Data 9
Buffer Consumer: Cycle 2
Exchnage ok, Cycle 2, Buffer Consumer size: 10
Exchange ok, Cycle 2, Buffer Producer size: 0
Buffer Producer: Cycle 3
Buffer Consumer: Data 10
Buffer Producer: Data 20
Buffer Consumer: Data 11
Buffer Producer: Data 21
Buffer Consumer: Data 12
Buffer Producer: Data 22
Buffer Consumer: Data 13
Buffer Consumer: Data 14
Buffer Consumer: Data 15
Buffer Producer: Data 23
Buffer Producer: Data 24
Buffer Consumer: Data 16
Buffer Producer: Data 25
Buffer Consumer: Data 17
Buffer Producer: Data 26
Buffer Producer: Data 27
Buffer Consumer: Data 18
Buffer Producer: Data 28
Buffer Producer: Data 29
Buffer Consumer: Data 19
Buffer Consumer: Cycle 3
Exchnage ok, Cycle 3, Buffer Consumer size: 10
Exchange ok, Cycle 3, Buffer Producer size: 0
Buffer Producer: Cycle 4
Buffer Consumer: Data 20
Buffer Producer: Data 30
Buffer Consumer: Data 21
Buffer Producer: Data 31
Buffer Consumer: Data 22
Buffer Producer: Data 32
Buffer Consumer: Data 23
Buffer Producer: Data 33
Buffer Consumer: Data 24
Buffer Producer: Data 34
Buffer Producer: Data 35
Buffer Producer: Data 36
Buffer Producer: Data 37
Buffer Consumer: Data 25
Buffer Producer: Data 38
Buffer Consumer: Data 26
Buffer Producer: Data 39
Buffer Consumer: Data 27
Buffer Consumer: Data 28
Buffer Consumer: Data 29
Buffer Consumer: Cycle 4
Exchnage ok, Cycle 4, Buffer Consumer size: 10
Buffer Consumer: Data 30
Buffer Consumer: Data 31
Exchange ok, Cycle 4, Buffer Producer size: 0
Buffer Producer: Cycle 5
Buffer Producer: Data 40
Buffer Producer: Data 41
Buffer Producer: Data 42
Buffer Producer: Data 43
Buffer Producer: Data 44
Buffer Consumer: Data 32
Buffer Producer: Data 45
Buffer Producer: Data 46
Buffer Producer: Data 47
Buffer Producer: Data 48
Buffer Producer: Data 49
Buffer Consumer: Data 33
Buffer Consumer: Data 34
Buffer Consumer: Data 35
Buffer Consumer: Data 36
Buffer Consumer: Data 37
Buffer Consumer: Data 38
Buffer Consumer: Data 39
Buffer Consumer: Cycle 5
Exchnage ok, Cycle 5, Buffer Consumer size: 10
Exchange ok, Cycle 5, Buffer Producer size: 0
Buffer Producer: Cycle 6
Buffer Consumer: Data 40
Buffer Consumer: Data 41
Buffer Consumer: Data 42
Buffer Consumer: Data 43
Buffer Producer: Data 50
Buffer Consumer: Data 44
Buffer Producer: Data 51
Buffer Consumer: Data 45
Buffer Producer: Data 52
Buffer Consumer: Data 46
Buffer Producer: Data 53
Buffer Consumer: Data 47
Buffer Producer: Data 54
Buffer Producer: Data 55
Buffer Consumer: Data 48
Buffer Producer: Data 56
Buffer Producer: Data 57
Buffer Producer: Data 58
Buffer Consumer: Data 49
Buffer Consumer: Cycle 6
Buffer Producer: Data 59
Exchange ok, Cycle 6, Buffer Producer size: 0
Buffer Producer: Cycle 7
Exchnage ok, Cycle 6, Buffer Consumer size: 10
Buffer Producer: Data 60
Buffer Consumer: Data 50
Buffer Consumer: Data 51
Buffer Consumer: Data 52
Buffer Producer: Data 61
Buffer Consumer: Data 53
Buffer Producer: Data 62
Buffer Consumer: Data 54
Buffer Producer: Data 63
Buffer Consumer: Data 55
Buffer Consumer: Data 56
Buffer Consumer: Data 57
Buffer Producer: Data 64
Buffer Consumer: Data 58
Buffer Producer: Data 65
Buffer Consumer: Data 59
Buffer Consumer: Cycle 7
Buffer Producer: Data 66
Buffer Producer: Data 67
Buffer Producer: Data 68
Buffer Producer: Data 69
Exchange ok, Cycle 7, Buffer Producer size: 0
Buffer Producer: Cycle 8
Exchnage ok, Cycle 7, Buffer Consumer size: 10
Buffer Consumer: Data 60
Buffer Producer: Data 70
Buffer Consumer: Data 61
Buffer Producer: Data 71
Buffer Consumer: Data 62
Buffer Consumer: Data 63
Buffer Producer: Data 72
Buffer Consumer: Data 64
Buffer Producer: Data 73
Buffer Consumer: Data 65
Buffer Producer: Data 74
Buffer Consumer: Data 66
Buffer Producer: Data 75
Buffer Consumer: Data 67
Buffer Producer: Data 76
Buffer Consumer: Data 68
Buffer Producer: Data 77
Buffer Consumer: Data 69
Buffer Producer: Data 78
Buffer Consumer: Cycle 8
Buffer Producer: Data 79
Exchange ok, Cycle 8, Buffer Producer size: 0
Buffer Producer: Cycle 9
Buffer Producer: Data 80
Exchnage ok, Cycle 8, Buffer Consumer size: 10
Buffer Consumer: Data 70
Buffer Consumer: Data 71
Buffer Consumer: Data 72
Buffer Consumer: Data 73
Buffer Producer: Data 81
Buffer Consumer: Data 74
Buffer Producer: Data 82
Buffer Consumer: Data 75
Buffer Producer: Data 83
Buffer Consumer: Data 76
Buffer Producer: Data 84
Buffer Consumer: Data 77
Buffer Producer: Data 85
Buffer Consumer: Data 78
Buffer Producer: Data 86
Buffer Consumer: Data 79
Buffer Producer: Data 87
Buffer Consumer: Cycle 9
Buffer Producer: Data 88
Buffer Producer: Data 89
Exchange ok, Cycle 9, Buffer Producer size: 0
Buffer Producer: Cycle 10
Buffer Producer: Data 90
Exchnage ok, Cycle 9, Buffer Consumer size: 10
Buffer Producer: Data 91
Buffer Consumer: Data 80
Buffer Producer: Data 92
Buffer Consumer: Data 81
Buffer Producer: Data 93
Buffer Consumer: Data 82
Buffer Producer: Data 94
Buffer Consumer: Data 83
Buffer Producer: Data 95
Buffer Producer: Data 96
Buffer Producer: Data 97
Buffer Producer: Data 98
Buffer Producer: Data 99
Buffer Consumer: Data 84
Buffer Consumer: Data 85
Buffer Consumer: Data 86
Buffer Consumer: Data 87
Buffer Consumer: Data 88
Buffer Consumer: Data 89
Buffer Consumer: Cycle 10
Exchnage ok, Cycle 10, Buffer Consumer size: 10
Exchange ok, Cycle 10, Buffer Producer size: 0
Buffer Consumer: Data 90
Buffer Consumer: Data 91
Buffer Consumer: Data 92
Buffer Consumer: Data 93
Buffer Consumer: Data 94
Buffer Consumer: Data 95
Buffer Consumer: Data 96
Buffer Consumer: Data 97
Buffer Consumer: Data 98
Buffer Consumer: Data 99
Disconnected from the target VM, address: &#39;127.0.0.1:55618&#39;, transport: &#39;socket&#39;

Process finished with exit code 0

&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;工作原理&#34;&gt;工作原理&lt;/h3&gt;

&lt;p&gt;消费者先创建一个空的缓存区，然后通过调用Exchanger与生产者同步来获得可以消费的数据。生产者从一个空的缓存列表开始执行，它创建了10个字符串，然后存储在这个缓存中，并且使用exchanger对象与消费者同步。两者共享一个exchanger对象。&lt;/p&gt;

&lt;p&gt;在这个同步点上，两个线程(生产者和消费者)都在Exchanger里，它们交换数据结构，当消费者从exchange()方法返回的时候，它的缓存列表有10个字符串。当生产者从exchange()返回的时候，它的缓存列表是空的。这个操作将循环执行10次。&lt;/p&gt;
</description>
    </item>
    
  </channel>
</rss>