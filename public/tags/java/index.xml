<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Java on 泥土巢</title>
    <link>http://nituchao.com/tags/java/index.xml</link>
    <description>Recent content in Java on 泥土巢</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh-CN</language>
    <copyright>Copyright (c) 2017, nituchao | All rights reserved.</copyright>
    <atom:link href="http://nituchao.com/tags/java/index.xml" rel="self" type="application/rss+xml" />
    
    <item>
      <title>jstack命令</title>
      <link>http://nituchao.com/post/2017/tong-guo-jstack-fen-xi/</link>
      <pubDate>Tue, 28 Feb 2017 19:01:58 +0800</pubDate>
      
      <guid>http://nituchao.com/post/2017/tong-guo-jstack-fen-xi/</guid>
      <description>

&lt;p&gt;Java程序在操作系统上是以单进程、多线程的形式运行。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;[work@zc-stage1-miui-sec02 ~]$ jstack
Usage:
    jstack [-l] &amp;lt;pid&amp;gt;
        (to connect to running process)
    jstack -F [-m] [-l] &amp;lt;pid&amp;gt;
        (to connect to a hung process)
    jstack [-m] [-l] &amp;lt;executable&amp;gt; &amp;lt;core&amp;gt;
        (to connect to a core file)
    jstack [-m] [-l] [server_id@]&amp;lt;remote server IP or hostname&amp;gt;
        (to connect to a remote debug server)

Options:
    -F  to force a thread dump. Use when jstack &amp;lt;pid&amp;gt; does not respond (process is hung)
    -m  to print both java and native frames (mixed mode)
    -l  long listing. Prints additional information about locks
    -h or -help to print this help message
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;jstack参数说明&#34;&gt;jstack参数说明&lt;/h2&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;连接到运行中的进程&lt;/p&gt;

&lt;p&gt;&amp;ldquo;jstack pid&amp;rdquo;，pid为进程号，可以通过jps或者top命令查到。&lt;/p&gt;

&lt;p&gt;命令执行成功则堆栈信息打印在控制台，可以通过&amp;rdquo;jstack 7023 &amp;gt; stack.log&amp;rdquo;这种方式将内容输出文件。&lt;/p&gt;

&lt;p&gt;导出的文本中包含线程号，线程号状态，线程调用栈等信息，结合ps命令中查询出的线程号，可以分析出CPU使用率比较高的线程，以及该线程中的调用堆栈，进而可以定位到项目代码。&lt;/p&gt;

&lt;p&gt;```
Thread 1091: (state = BLOCKED)&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;sun.misc.Unsafe.park(boolean, long) @bci=0 (Compiled frame; information may be imprecise)&lt;/li&gt;
&lt;li&gt;java.util.concurrent.locks.LockSupport.park() @bci=5, line=315 (Interpreted frame)&lt;/li&gt;
&lt;li&gt;com.caucho.env.thread2.ResinThread2.park() @bci=29, line=196 (Compiled frame)&lt;/li&gt;
&lt;li&gt;com.caucho.env.thread2.ResinThread2.runTasks() @bci=65, line=147 (Compiled frame)&lt;/li&gt;
&lt;li&gt;com.caucho.env.thread2.ResinThread2.run() @bci=15, line=118 (Interpreted frame)
```&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;Thread 1089: (state = BLOCKED)
    - sun.misc.Unsafe.park(boolean, long) @bci=0 (Compiled frame; information may be imprecise)
    - java.util.concurrent.locks.LockSupport.park() @bci=5, line=315 (Interpreted frame)
    - com.caucho.env.thread2.ResinThread2.park() @bci=29, line=196 (Compiled frame)
    - com.caucho.env.thread2.ResinThread2.runTasks() @bci=65, line=147 (Compiled frame)
    - com.caucho.env.thread2.ResinThread2.run() @bci=15, line=118 (Interpreted frame)&lt;/p&gt;

&lt;p&gt;Thread 1088: (state = IN_NATIVE)
    - java.net.SocketInputStream.socketRead0(java.io.FileDescriptor, byte[], int, int, int) @bci=0 (Compiled frame; information may be imprecise)
    - java.net.SocketInputStream.read(byte[], int, int, int) @bci=79, line=150 (Compiled frame)
    - java.net.SocketInputStream.read(byte[], int, int) @bci=11, line=121 (Compiled frame)
    - java.net.SocketInputStream.read(byte[]) @bci=5, line=107 (Compiled frame)
    - redis.clients.util.RedisInputStream.ensureFill() @bci=20, line=195 (Compiled frame)
    - redis.clients.util.RedisInputStream.readByte() @bci=1, line=40 (Compiled frame)
    - redis.clients.jedis.Protocol.process(redis.clients.util.RedisInputStream) @bci=1, line=141 (Compiled frame)
    - redis.clients.jedis.Protocol.read(redis.clients.util.RedisInputStream) @bci=1, line=205 (Compiled frame)
    - redis.clients.jedis.Connection.readProtocolWithCheckingBroken() @bci=4, line=297 (Compiled frame)
    - redis.clients.jedis.Connection.getBinaryBulkReply() @bci=15, line=216 (Compiled frame)
    - redis.clients.jedis.Connection.getBulkReply() @bci=1, line=205 (Compiled frame)
    - redis.clients.jedis.Jedis.get(java.lang.String) @bci=27, line=101 (Compiled frame)
    - redis.clients.jedis.JedisCluster$3.execute(redis.clients.jedis.Jedis) @bci=5, line=79 (Compiled frame)
    - redis.clients.jedis.JedisCluster$3.execute(redis.clients.jedis.Jedis) @bci=2, line=76 (Compiled frame)
    - redis.clients.jedis.JedisClusterCommand.runWithRetries(byte[], int, boolean, boolean) @bci=78, line=119 (Compiled frame)
    - redis.clients.jedis.JedisClusterCommand.run(java.lang.String) @bci=25, line=30 (Compiled frame)
    - redis.clients.jedis.JedisCluster.get(java.lang.String) @bci=18, line=81 (Compiled frame)
    - com.xiaomi.miui.sec.service.RedisCacheService$14.call(redis.clients.jedis.RedisCluster) @bci=5, line=667 (Compiled frame)
    - com.xiaomi.miui.sec.service.RedisCacheService$14.call(java.lang.Object) @bci=5, line=663 (Compiled frame)
    - com.xiaomi.miui.cache.rediscluster.DefaultRedisClusterCache.get(java.lang.Object, com.xiaomi.miui.cache.rediscluster.RedisClusterCallable) @bci=22, line=68 (Compiled frame)
    - com.xiaomi.miui.sec.service.RedisCacheService.getSettingAdv(java.lang.String, java.lang.String, java.lang.String) @bci=49, line=663 (Compiled frame)
    - com.xiaomi.miui.sec.service.CacheService.getSettingAdv(java.lang.String, java.lang.String, java.lang.String) @bci=7, line=113 (Compiled frame)
    - com.xiaomi.miui.sec.bizLogic.SettingBiz.postHandlerMiCom(net.sf.json.JSONObject, com.xiaomi.miui.sec.thrift.Device, net.paoding.rose.web.Invocation) @bci=55, line=119 (Compiled frame)
    - com.xiaomi.miui.sec.bizLogic.SettingBiz.postHandler(net.sf.json.JSONObject, com.xiaomi.miui.sec.thrift.Device, net.paoding.rose.web.Invocation) @bci=118, line=65 (Compiled frame)
    - com.xiaomi.miui.sec.bizLogic.BasicBiz.mainHandler(net.paoding.rose.web.Invocation) @bci=29, line=59 (Compiled frame)
    - com.xiaomi.miui.sec.controllers.InfoController.setting(net.paoding.rose.web.Invocation, java.lang.String) @bci=73, line=252 (Compiled frame)
    - sun.reflect.GeneratedMethodAccessor31.invoke(java.lang.Object, java.lang.Object[]) @bci=48 (Compiled frame)
    - sun.reflect.DelegatingMethodAccessorImpl.invoke(java.lang.Object, java.lang.Object[]) @bci=6, line=43 (Compiled frame)
    - java.lang.reflect.Method.invoke(java.lang.Object, java.lang.Object[]) @bci=57, line=606 (Compiled frame)&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;
   ​

## jstack分析java线程的CPU使用率和使用时长



## jstack分析分析已有的javacore文件



## jstack连接到远程调试服务器进行分析
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>解决Java进程占用CPU过高的问题</title>
      <link>http://nituchao.com/post/2017/ji-lu-yi-ci-cpu-guo-gao-chu-li/</link>
      <pubDate>Tue, 28 Feb 2017 09:16:18 +0800</pubDate>
      
      <guid>http://nituchao.com/post/2017/ji-lu-yi-ci-cpu-guo-gao-chu-li/</guid>
      <description></description>
    </item>
    
    <item>
      <title>Atomic变量</title>
      <link>http://nituchao.com/post/juc.atomic/atomic-summary/</link>
      <pubDate>Thu, 23 Feb 2017 18:39:27 +0800</pubDate>
      
      <guid>http://nituchao.com/post/juc.atomic/atomic-summary/</guid>
      <description>&lt;p&gt;Java原子变量的诞生源自一个简单的需求 —— 多个线程共享某个变量或者对象时，需要对修改和读取操作进行同步。&lt;/p&gt;

&lt;p&gt;同步包含两层含义：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;互斥访问&lt;/li&gt;
&lt;li&gt;可见性&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;通常，多线程对临界资源的互斥访问通过对象锁(synchronized关键字)保证。对象锁是一种独占锁（悲观锁），会导致其它所有需要锁的线程挂起。而可见性则由volatile的内存语义保证。&lt;/p&gt;

&lt;p&gt;Java 1.5开始提供了原子变量和原子引用，这些类放置在&lt;code&gt;java.util.concurrent&lt;/code&gt;下。大概可以归为4类：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;基本类型：AtomicInteger, AtomicLong, AtomicBoolean;&lt;/li&gt;
&lt;li&gt;数组类型：AtomicIntegerArray, AtomicLongArray, AtomicReferenceArray;&lt;/li&gt;
&lt;li&gt;引用类型：AtomicReference, AtomicStampedReference, AtomicMarkableReference;&lt;/li&gt;
&lt;li&gt;对象的属性修改类型：AtomicIntegerFieldUpdater, AtomicLongFieldUpdater, AtomicReferenceFieldUpdater;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;Java原子变量的存在是为了对相应的数据进行原子操作。&lt;/p&gt;

&lt;p&gt;所谓的原子操作包含下面几层含义：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;操作过程不会被中断。&lt;/li&gt;
&lt;li&gt;操作过程不会被阻塞。&lt;/li&gt;
&lt;li&gt;修改结果被其他线程可见。&lt;/li&gt;
&lt;/ol&gt;
</description>
    </item>
    
    <item>
      <title>Java锁之Unsafe类的理解</title>
      <link>http://nituchao.com/post/juc.lock/java-unsafe/</link>
      <pubDate>Thu, 23 Feb 2017 18:39:27 +0800</pubDate>
      
      <guid>http://nituchao.com/post/juc.lock/java-unsafe/</guid>
      <description>

&lt;h2 id=&#34;一言&#34;&gt;一言&lt;/h2&gt;

&lt;p&gt;&lt;code&gt;sun.misc.Unsafe&lt;/code&gt;类是超越Java的存在，它违反了Java在内存管理上的设计初衷，却又是Java很多重要特性与功能得以实现的基础，它使Java的安全性受到威胁，却有使Java在很多方面的性能得到提升，它是魔鬼与天使的混合体。&lt;/p&gt;

&lt;h2 id=&#34;概述&#34;&gt;概述&lt;/h2&gt;

&lt;p&gt;Java是一个安全的开发工具，它阻止开发人员犯很低级的错误，而大部分的错误都是基于内存管理的。Unsafe类突破了Java原生的内存管理体制，使用Unsafe类可以在系统内存的任意地址进行读写数据，而这些操作对于普通用户来说是非常危险的，Unsafe的操作粒度不是类，而是数据和地址。&lt;/p&gt;

&lt;p&gt;从另一方讲，Java正被广泛应用于游戏服务器和高频率的交易应用。这些之所以能够实现主要归功于Java提供的这个非常便利的类&lt;code&gt;sun.mics.Unsafe&lt;/code&gt;。Unsafe类为了速度，在Java严格的安全标准方法做了一些妥协。&lt;/p&gt;

&lt;p&gt;Java在JUC包中提供了对&lt;code&gt;sun.misc.Unsafe&lt;/code&gt;类的封装实现，这就是&lt;code&gt;java.util.concurrent.LockSupport&lt;/code&gt;。&lt;/p&gt;

&lt;p&gt;本文基于JDK1.7.0_67&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;java version &amp;ldquo;1.7.0&lt;em&gt;67&amp;rdquo;&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;_Java&amp;trade; SE Runtime Environment (build 1.7.0_67-b01)&lt;/p&gt;

&lt;p&gt;Java HotSpot&amp;trade; 64-Bit Server VM (build 24.65-b04, mixed mode)&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&#34;重要函数&#34;&gt;重要函数&lt;/h2&gt;

&lt;p&gt;&lt;code&gt;sun.mics.Unsafe&lt;/code&gt;一共提供了106个函数，这些函数涵盖了以下五个方面的功能：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;对变量和数组内容的原子访问，自定义内存屏障&lt;/li&gt;
&lt;li&gt;对序列化的支持&lt;/li&gt;
&lt;li&gt;自定义内存管理/高效的内存布局&lt;/li&gt;
&lt;li&gt;与原生代码和其他JVM进行互操作&lt;/li&gt;
&lt;li&gt;对高级锁的支持&lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&#34;获取实例&#34;&gt;获取实例&lt;/h3&gt;

&lt;p&gt;&lt;code&gt;sun.misc.Unsafe&lt;/code&gt;只有一个无参的私有构造函数，要想实例化&lt;code&gt;sun.misc.Unsafe&lt;/code&gt;可以调用&lt;code&gt;getUnsafe()&lt;/code&gt;方法。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;@CallerSensitive
public static Unsafe getUnsafe() {
  Class var0 = Reflection.getCallerClass();
  if(var0.getClassLoader() != null) {
    throw new SecurityException(&amp;quot;Unsafe&amp;quot;);
  } else {
    return theUnsafe;
  }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;出于安全考虑，Unsafe类只能被系统类加载器实例化，否则会抛出&lt;code&gt;SecurityException&lt;/code&gt;异常。普通用户如果想实例化&lt;code&gt;sun.misc.Unsafe&lt;/code&gt;类的对象，需要通过类反射机制或者修改Java的安全策略。&lt;/p&gt;

&lt;h3 id=&#34;内存操作&#34;&gt;内存操作&lt;/h3&gt;

&lt;h4 id=&#34;获取成员变量偏移量&#34;&gt;获取成员变量偏移量&lt;/h4&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;// 返回对象中指定静态成员变量的内存偏移量(相对于类存储)
public native long staticFieldOffset(Field f);

// 返回对象中指定成员变量的内存偏移量(相对于对象实例)
public native long objectFieldOffset(Field f);

// 返回对象中指定成员变量
public native Object staticFieldBase(Field f);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;sun.misc.Unsafe&lt;/code&gt;的操作对象是内存数据，获取指定成员变量的内存地址是对其进行操作的第一步。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;objectFieldOffset&lt;/code&gt;是一个本地函数，返回指定静态field的内存地址偏移量，&lt;code&gt;Unsafe&lt;/code&gt;类的其他方法中这个值是被用作一个访问特定field的一个方式。这个值对于给定的field是唯一的，并且后续对该方法的调用都返回相同的值。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;objectFieldOffset&lt;/code&gt;获取到的是内存偏移量，并不是真正的内存指针地址，Unsafe类提供了&lt;code&gt;getAddress&lt;/code&gt;函数将该偏移量转换为真正的内存指针地址，有了该内存指针地址，就可以直接操作内存数据的读写了。&lt;/p&gt;

&lt;h4 id=&#34;操作成员变量数据&#34;&gt;操作成员变量数据&lt;/h4&gt;

&lt;p&gt;有了&lt;code&gt;objectFieldOffset&lt;/code&gt;获取到的内存偏移量，就可以使用Unsafe类对该内存位置的数据进行读写。Unsafe类提供了对所有Java基本数据类型（byte, short, int, long, float, double）和对象类型的读写，这些方法都是本地函数（另外有一些对本地函数进行封装的读写函数，已经被标识为弃用）。&lt;/p&gt;

&lt;p&gt;这些操作可以从另一个层面理解为&lt;code&gt;sun.misc.Unsafe&lt;/code&gt;对序列化和反序列化的支持。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;// o: 对象引用
// offset: 内存偏移量，通过objectFieldOffset获取
public native int getInt(Object o, long offset);
// o: 对象引用
// offset: 内存偏移量，通过objectFieldOffset获取
// x: 新的数据值
public native void putInt(Object o, long offset, int x);
public native Object getObject(Object o, long offset);
public native void putObject(Object o, long offset, Object x);
public native boolean getBoolean(Object o, long offset);
public native void    putBoolean(Object o, long offset, boolean x);
public native byte    getByte(Object o, long offset);
public native void    putByte(Object o, long offset, byte x);
public native short   getShort(Object o, long offset);
public native void    putShort(Object o, long offset, short x);
public native char    getChar(Object o, long offset);
public native void    putChar(Object o, long offset, char x);
public native long    getLong(Object o, long offset);
public native void    putLong(Object o, long offset, long x);
public native float   getFloat(Object o, long offset);
public native void    putFloat(Object o, long offset, float x);
public native double  getDouble(Object o, long offset);
public native void    putDouble(Object o, long offset, double x);

// 获取obj对象中offset地址对应的object型field的值为指定值。
// getObject(Object, long)的volatile版
public native Object getObjectVolatile(Object o, long offset);
// 设置obj对象中offset偏移地址对应的object型field的值为指定值。
// putObject(Object, long, Object)的volatile版
public native void    putObjectVolatile(Object o, long offset, Object x);
public native int     getIntVolatile(Object o, long offset);
public native void    putIntVolatile(Object o, long offset, int x);
public native boolean getBooleanVolatile(Object o, long offset);
public native void    putBooleanVolatile(Object o, long offset, boolean x);
public native byte    getByteVolatile(Object o, long offset);
public native void    putByteVolatile(Object o, long offset, byte x);
public native short   getShortVolatile(Object o, long offset);
public native void    putShortVolatile(Object o, long offset, short x);
public native char    getCharVolatile(Object o, long offset);
public native void    putCharVolatile(Object o, long offset, char x);
public native long    getLongVolatile(Object o, long offset);
public native void    putLongVolatile(Object o, long offset, long x);
public native float   getFloatVolatile(Object o, long offset);
public native void    putFloatVolatile(Object o, long offset, float x);
public native double  getDoubleVolatile(Object o, long offset);
public native void    putDoubleVolatile(Object o, long offset, double x);

// 设置obj对象中offset偏移地址对应的object型field的值为指定值。这是一个有序或者 
// 有延迟的&amp;lt;code&amp;gt;putObjectVolatile&amp;lt;/cdoe&amp;gt;方法，并且不保证值的改变被其他线程立 
// 即看到。只有在field被&amp;lt;code&amp;gt;volatile&amp;lt;/code&amp;gt;修饰并且期望被意外修改的时候 
// 使用才有用。 
// 这个方法在对低延迟代码是很有用的，它能够实现非堵塞的写入，这些写入不会被Java的JIT重新排序指令
// (instruction reordering)，这样它使用快速的存储-存储(store-store) barrier, 而不是较慢
// 的存储-加载(store-load) barrier, 后者总是用在volatile的写操作上，这种性能提升是有代价的，
// 虽然便宜，也就是写后结果并不会被其他线程看到，甚至是自己的线程，通常是几纳秒后被其他线程看到，
// 这个时间比较短，所以代价可以忍受。类似Unsafe.putOrderedObject还有unsafe.putOrderedLong
// 等方法，unsafe.putOrderedLong比使用 volatile long要快3倍左右。.
public native void    putOrderedObject(Object o, long offset, Object x);
public native void    putOrderedInt(Object o, long offset, int x);
public native void    putOrderedLong(Object o, long offset, long x);
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;获取内存指针地址&#34;&gt;获取内存指针地址&lt;/h4&gt;

&lt;p&gt;&lt;code&gt;objectFieldOffset&lt;/code&gt;获取到的是内存偏移量，并不是真正的内存指针地址，Unsafe类提供了&lt;code&gt;getAddress&lt;/code&gt;函数将该偏移量转换为真正的内存指针地址，有了该内存指针地址，就可以直接操作内存数据的读写了。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;// 根据给定的内存偏移量(objectFieldOffset的返回值)，获取真正的内存指针地址。
// 如果给定的内存偏移量为0或者并没有指向一个内存块，返回undefined。
// 如果返回的内存指针地址位宽小于64，用无符号整数进行扩展转换为Java long型。
public native long getAddress(long var1);
// 保存一个内存指针地址到给定的内存偏移量。
// 如过给定的内存偏移量为0或者并没有指向一个内存块，返回undefined。
public native void putAddress(long var1, long var3);

// 返回一个内存指针占用的字节数(bytes)
public native int addressSize();
// 返回一个内存页占用的字节数(bytes)
public native int pageSize();

&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;直接分配内存空间&#34;&gt;直接分配内存空间&lt;/h4&gt;

&lt;p&gt;&lt;code&gt;sun.mics.Unsafe&lt;/code&gt;类允许Java程序使用JVM堆外内存，即操作系统内存。&lt;code&gt;BufferBytes&lt;/code&gt;类也可以分配JVM堆外内存，但是只能使用最大2GB的JVM堆外内存空间，而&lt;code&gt;sun.mics.Unsafe&lt;/code&gt;类没有这个限制。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;// 分配一块大小为var1字节的JVM堆外内存。
// 新分配的内存空间中的内容处于未初始化状态。
// 新分配的内存空间的指针地址不为0，并对所有的值类型做内存对齐。
public native long allocateMemory(long var1);
// 调整JVM堆外内存空间大小。
// 参数var1是待调整的JVM堆外内存空间的指针地址。
// 参数var3是新的JVM堆外内存空间字节大小。
// 如果新空间大小var1=0，则返回指针地址为0.
public native long reallocateMemory(long var1, long var3);
// 释放指定内存指针地址的内存空间。
public native void freeMemory(long var1);
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;直接操作内存类型数据&#34;&gt;直接操作内存类型数据&lt;/h4&gt;

&lt;p&gt;有了&lt;code&gt;addAddress&lt;/code&gt;函数获取到的内存指针地址，就可以直接操作该内存指针地址处的数据了。Unsafe类提供了对所有Java基础数据类型和对象类型的直接内存操作函数。&lt;/p&gt;

&lt;p&gt;下面提供的这些函数，都是按照数据类型对内存数据进行读写。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;// var1: 内存指针地址
public native byte getByte(long var1);
// var1: 内存指针地址
// var3: 新的数据值
public native void putByte(long var1, byte var3);
public native short getShort(long var1);
public native void putShort(long var1, short var3);
public native char getChar(long var1);
public native void putChar(long var1, char var3);
public native int getInt(long var1);
public native void putInt(long var1, int var3);
public native long getLong(long var1);
public native void putLong(long var1, long var3);
public native float getFloat(long var1);
public native void putFloat(long var1, float var3);
public native double getDouble(long var1);
public native void putDouble(long var1, double var3);
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;直接操作内存字节数据&#34;&gt;直接操作内存字节数据&lt;/h4&gt;

&lt;p&gt;有了&lt;code&gt;addAddress&lt;/code&gt;函数获取到的内存指针地址，就可以直接操作该内存指针地址处的数据了。Unsafe类提供了直接按照字节为单位对指定的内存指针地址进行数据操作的函数。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public native void setMemory(Object o, long offset, long bytes, byte value);
public void setMemory(long address, long bytes, byte value) {
  	setMemory(null, address, bytes, value);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;直接复制内存数据&#34;&gt;直接复制内存数据&lt;/h4&gt;

&lt;p&gt;有了&lt;code&gt;addAddress&lt;/code&gt;函数获取到的内存指针地址，还可以直接将一个内存指针地址对应的数据块拷贝到另一个内存指针地址对应的位置。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public native void copyMemory(Object srcBase, long srcOffset,
                              Object destBase, long destOffset,
                              long bytes);
public void copyMemory(long srcAddress, long destAddress, long bytes) {
  	copyMemory(null, srcAddress, null, destAddress, bytes);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;数组操作&#34;&gt;数组操作&lt;/h3&gt;

&lt;p&gt;Unsafe类中有很多以BASE_OFFSET结尾的常量，比如ARRAY_INT_BASE_OFFSET，ARRAY_BYTE_BASE_OFFSET等，这些常量值是通过arrayBaseOffset方法得到的。arrayBaseOffset方法是一个本地方法，可以获取数组第一个元素的偏移地址。&lt;/p&gt;

&lt;p&gt;Unsafe类中还有很多以INDEX_SCALE结尾的常量，比如 ARRAY_INT_INDEX_SCALE ， ARRAY_BYTE_INDEX_SCALE等，这些常量值是通过arrayIndexScale方法得到的。arrayIndexScale方法也是一个本地方法，可以获取数组的转换因子，也就是数组中元素的增量地址。&lt;/p&gt;

&lt;p&gt;将arrayBaseOffset与arrayIndexScale配合使用，可以定位数组中每个元素在内存中的位置。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;// 返回给定数组的第一个元素的内存偏移量
public native int arrayBaseOffset(Class arrayClass);
// 返回给定数组的转换因子，也就是数组中元素的增量地址
public native int arrayIndexScale(Class arrayClass);
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;原子操作&#34;&gt;原子操作&lt;/h3&gt;

&lt;p&gt;&lt;code&gt;sun.misc.Unsafe&lt;/code&gt;类提供了CAS原子操作，能够实现高性能的线程安全的无锁数据结构。&lt;code&gt;sun.misc.Unsafe&lt;/code&gt;类的CAS操作是&lt;code&gt;java.util.concurrent&lt;/code&gt;包的基础，&lt;code&gt;LockSupport&lt;/code&gt;，&lt;code&gt;AbstractQueuedSynchronized&lt;/code&gt;，&lt;code&gt;AtomicInteger&lt;/code&gt;等原子变量和锁框架都基于CAS操作实现的。&lt;/p&gt;

&lt;p&gt;由于CAS操作在执行时当前线程不会被阻塞，所以通常使用自旋锁循环执行，直到操作成功时，表示获取到锁。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;// 当Java对象o的域偏移offset上的值为excepted时，原子地修改为x。
// 如果修改成功，返回true。否则，返回false。
// 操作过程中线程不会阻塞。
public final native boolean compareAndSwapObject(Object o, long offset,
                                                 Object expected,
                                                 Object x);
// 当Java对象o的域偏移offset上的值为int型的excepted时，原子地修改为x。
// 如果修改成功，返回true。否则，返回false。
// 操作过程中线程不会阻塞。
public final native boolean compareAndSwapInt(Object o, long offset,
                                              int expected,
                                              int x);
// 当Java对象o的域偏移offset上的值为int型的excepted时，原子地修改为x。
// 如果修改成功，返回true。否则，返回false。
// 操作过程中线程不会阻塞。
public final native boolean compareAndSwapLong(Object o, long offset,
                                               long expected,
                                               long x);
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;监视器锁&#34;&gt;监视器锁&lt;/h3&gt;

&lt;p&gt;&lt;code&gt;synchronized&lt;/code&gt;是JVM最早提供的锁，称为监视器锁，也称对象锁。获得锁的过程称为monitorEnter，释放锁的过程称为monitorExit，锁的信息保存在对象头里，同步语句会在编译成字节码后转换成监视器语法(monitorEnter和monitorExit)。&lt;code&gt;sun.misc.Unsafe&lt;/code&gt;类提供了监视器的相关操作。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;// 锁住对象
public native void monitorEnter(Object o);
// 尝试锁住对象
public native boolean tryMonitorEnter(Object o);
// 解锁对象
public native void monitorExit(Object o);
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;线程控制&#34;&gt;线程控制&lt;/h3&gt;

&lt;p&gt;在实现&lt;code&gt;java.util.concurrent.AbstractQueued&lt;/code&gt;类，并基于AQS实现整个JUC锁框架的过程中，一方面需要使用&lt;code&gt;sun.misc.Unsafe&lt;/code&gt;类的CAS操作进行锁的获取(标记位state的修改)，另一方在获取锁失败时要把当前线程放入等待队列，并阻塞当前线程。阻塞当前的线程的方法也是&lt;code&gt;sun.misc.Unsafe&lt;/code&gt;类提供的。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;// 阻塞当前线程。
// 直到通过unpark方法解除阻塞，或者线程被中断，或者指定的超时时间到期
// isAbsolute参数是指明时间是绝对的，还是相对的
// time单位是纳秒，如果为0则表示长期阻塞
public native void park(boolean isAbsolute, long time);
// 解除指定线程的阻塞状态。
public native void unpark(Object thread);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;park方法的两个参数里并没有指定要阻塞的线程引用，JVM怎么知道要将哪个线程阻塞？而unpark方法又是如何将一个线程的阻塞状态解除的呢？要真正理解park和unpark的工作原理，需要深入到HotSpot的源码。&lt;/p&gt;

&lt;p&gt;简单的讲，park和unpark本质上是通过HotSpot里的一个volatile共享变量(volatile int _counter)来通信的，当park时，这个变量设置为0，当unpark时，这个变量设置为1。&lt;/p&gt;

&lt;p&gt;由此，我们发现使用park和unpark来对线程进行同步控制非常灵活，unpark甚至可以在park之前调用。park/unpark模型真正实现了线程之间的同步，Java线程之间不再需要一个Object(synchronized代表的对象锁，用对象头存储锁信息)或者其他变量来存储状态(AQS中的state变量)来存储状态，不再需要关心对方的状态。&lt;/p&gt;

&lt;p&gt;对比Java5中提供的wait/notify/notifyAll同步体系。wait/notify机制有个很蛋疼的地方是，比如线程B要用notify通知线程A，那么线程B要确保线程A已经在wait调用上等待了，否则线程A可能永远都在等待。编程的时候就会很蛋疼。&lt;/p&gt;

&lt;p&gt;unpark函数为线程提供“许可(permit)”，线程调用park函数则等待“许可”。这个有点像信号量，但是这个“许可”是不能叠加的，“许可”是一次性的。&lt;/p&gt;

&lt;p&gt;比如线程B连续调用了三次unpark函数，当线程A调用park函数就使用掉这个“许可”，如果线程A再次调用park，则进入等待状态。&lt;/p&gt;

&lt;p&gt;在HotSpot的实现里，每个Java线程都有一个Parker实例，Parker类的定义如下：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;class Parker : public os::PlatformParker {  
private:  
  volatile int _counter ;  
  ...  
public:  
  void park(bool isAbsolute, jlong time);  
  void unpark();  
  ...  
}  
class PlatformParker : public CHeapObj&amp;lt;mtInternal&amp;gt; {  
  protected:  
    pthread_mutex_t _mutex [1] ;  
    pthread_cond_t  _cond  [1] ;  
    ...  
}  
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;异常处理&#34;&gt;异常处理&lt;/h3&gt;

&lt;p&gt;&lt;code&gt;sun.misc.Unsafe&lt;/code&gt;类还提供了抛出异常的能力。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;// 在不通知验证器(verifier)的情况下，抛出异常。
public native void throwException(Throwable ee);
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;对象增强&#34;&gt;对象增强&lt;/h3&gt;

&lt;p&gt;&lt;code&gt;sun.misc.Unsafe&lt;/code&gt;类还提供了一些对类和对象进行操作的函数。通过这些函数，用户可以在绕过虚拟机的情况下进行类的加载、初始化，或者对对象进行实例化。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;// 让虚拟机在不进行安全检查的情况下定义一个类。
// 默认情况下，该类的类加载器和保护域来自调用类。
public native Class defineClass(String name, byte[] b, int off, int len,
                                ClassLoader loader,
                                ProtectionDomain protectionDomain);
public native Class defineClass(String name, byte[] b, int off, int len);

// 在不调用构造函数的情况下，实例化类Class的一个对象
// 如果累Class还没有加载到JVM，则进行加载
public native Object allocateInstance(Class cls)
        throws InstantiationException;

// 定义一个匿名类，该类将不被classloader，或系统目录感知
public native Class defineAnonymousClass(Class hostClass, byte[] data, Object[] cpPatches);

// 确保指定的类已经被初始化(加载到JVM)
public native void ensureClassInitialized(Class c);
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;实例分析&#34;&gt;实例分析&lt;/h2&gt;

&lt;p&gt;本节记录了一些使用&lt;code&gt;sun.misc.Unsafe&lt;/code&gt;的实例，并对这些实例进行分析。&lt;/p&gt;

&lt;h3 id=&#34;实例化私有类&#34;&gt;实例化私有类&lt;/h3&gt;

&lt;p&gt;很多类为了封装的需要将构造函数声明成私有的，防止被实例化。在&lt;code&gt;sun.misc.Unsafe&lt;/code&gt;类面前，这中做法不堪一击。&lt;code&gt;allocateInstance&lt;/code&gt;方法可以在不调用构造函数的情况下，直接实例化类的一个对象。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;import sun.misc.Unsafe;

import java.lang.reflect.Field;

public class UnsafeUser {
    public static void main(String[] args) throws Exception {
        // 由于安全限制，只有系统class loader才能使用getUnsafe()方法
        // 普通用户只能通过反射实例化Unsafe
        Field field = Unsafe.class.getDeclaredField(&amp;quot;theUnsafe&amp;quot;);
        field.setAccessible(true);
        Unsafe unsafe = (Unsafe) field.get(null);

        // 实例化User，不调用构造函数
        User user = (User) unsafe.allocateInstance(User.class);
        user.setName(&amp;quot;liang&amp;quot;);
        System.out.println(user.getName());
    }
}

class User {
    private String name;
    private User() {}
    public String getName() { return name; }
    public void setName(String name) { this.name = name; }
}

// 执行后输出
liang
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;操作对象内存&#34;&gt;操作对象内存&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;import sun.misc.Unsafe;

import java.lang.reflect.Field;

public class UnsafeUser {

    public static void main(String[] args) throws Exception {
        // 由于安全限制，只有系统classloader才能使用getUnsafe()方法
        // 普通用户只能通过反射实例化Unsafe
        Field field = Unsafe.class.getDeclaredField(&amp;quot;theUnsafe&amp;quot;);
        field.setAccessible(true);
        Unsafe unsafe = (Unsafe) field.get(null);

        // 实例化User，不调用构造函数
        User user = (User) unsafe.allocateInstance(User.class);
        user.setName(&amp;quot;liang&amp;quot;);
        user.setAge(28);

        // 输出user对象中各个成员遍历的内存偏移值
        for (Field f : user.getClass().getDeclaredFields()) {
            System.out.println(f.getName() + &amp;quot; 对应的内存偏移地址: &amp;quot; + unsafe.objectFieldOffset(f));
        }

        System.out.println(&amp;quot;---------------------&amp;quot;);

      	// 获取age内存偏移量
        long ageOffset = 
          unsafe.objectFieldOffset(user.getClass().getDeclaredField(&amp;quot;age&amp;quot;));
       	// // 获取name内存偏移量
        long nameOffset = 
          unsafe.objectFieldOffset(user.getClass().getDeclaredField(&amp;quot;name&amp;quot;));

        // 修改age值
        unsafe.putInt(user, ageOffset, 29);
        // 修改name值
        unsafe.putObject(user, nameOffset, &amp;quot;zhang liang&amp;quot;);

        System.out.println(&amp;quot;age: &amp;quot; + user.getAge());
        System.out.println(&amp;quot;name: &amp;quot; + user.getName());
    }
}

class User {
    private int age;
    private String name;
    private User() {}
    public String getName() { return name; }
    public void setName(String name) { this.name = name; }
    public int getAge() { return age; }
    public void setAge(int age) { this.age = age; }
}

// 执行后输出：
age 对应的内存偏移地址: 12
name 对应的内存偏移地址: 16
---------------------
age: 29
name: zhang liang
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;创建超大数组&#34;&gt;创建超大数组&lt;/h3&gt;

&lt;p&gt;Java中数组的最大长度为Integer.MAX_VALUE，正常情况下如果想创建一个大于Integer.MAX_VALUE的数组是做不到的，但是Unsafe可以，通过对内存进行直接分配实现。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public class BigArray {
    public static void main(String[] arg) throws Exception {

        // 由于安全限制，只有系统classloader才能使用getUnsafe()方法
        // 普通用户只能通过反射实例化Unsafe
        Field field = Unsafe.class.getDeclaredField(&amp;quot;theUnsafe&amp;quot;);
        field.setAccessible(true);
        Unsafe unsafe = (Unsafe) field.get(null);

        //只要内存够大，可以把这个调大，大于Integer.MAX_VALUE
        long size = (long) Integer.MAX_VALUE * 2;
        long addr = unsafe.allocateMemory(size);
        System.out.println(&amp;quot;unsafe address :&amp;quot; + addr);

        for (int i = 0; i &amp;lt; size; i++) {
            unsafe.putByte(addr + i, (byte) 6);
            if (unsafe.getByte(addr + i) != 6) {
                System.out.println(&amp;quot;failed at offset&amp;quot;);
            }
        }
    }
}

// 运行结果
unsafe address :4754382848
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;线程挂起与恢复&#34;&gt;线程挂起与恢复&lt;/h3&gt;

&lt;p&gt;将一个线程进行挂起是通过park方法实现的，调用 park后，线程将一直阻塞直到超时或者中断等条件出现。unpark可以终止一个挂起的线程，使其恢复正常。&lt;/p&gt;

&lt;p&gt;整个并发框架中对线程的挂起操作被封装在 LockSupport类中，LockSupport类中有各种版本pack方法，但最终都调用了Unsafe.park()方法。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;import sun.misc.Unsafe;

import java.lang.reflect.Field;
import java.util.concurrent.TimeUnit;
import java.util.concurrent.locks.LockSupport;

public class Lock {
    public static void main(String[] args) throws Exception {

        // 由于安全限制，只有系统classloader才能使用getUnsafe()方法
        // 普通用户只能通过反射实例化Unsafe
        Field field = Unsafe.class.getDeclaredField(&amp;quot;theUnsafe&amp;quot;);
        field.setAccessible(true);
        Unsafe unsafe = (Unsafe) field.get(null);

        WaitThread waitThread = new WaitThread(unsafe);
        waitThread.start();
        WorkThread workThread = new WorkThread(unsafe, waitThread);
        workThread.start();

        workThread.join();

        System.out.println(&amp;quot;the end.&amp;quot;);
    }
}

/**
 * 工作线程
 */
class WorkThread extends Thread {
    private Thread waitThread;
    private Unsafe unsafe;

    public WorkThread(Unsafe unsafe, Thread waitThread) {
        this.waitThread = waitThread;
        this.unsafe = unsafe;
    }

    public void run() {
        int i = 0;
        while (true) {
            if (i == 5) {
                System.out.println(&amp;quot;WorkThread is now to wake WaitThread&amp;quot;);
                unsafe.unpark(waitThread);

                break;
            }

            System.out.println(&amp;quot;WorkThread is now working for &amp;quot; + (++i) + &amp;quot; s&amp;quot;);

            try {
                TimeUnit.SECONDS.sleep(1);
            } catch (Exception e) {
                e.printStackTrace();
            }
        }
    }
}

class WaitThread extends Thread {
    private Unsafe unsafe;

    public WaitThread(Unsafe unsafe) {
        this.unsafe = unsafe;
    }
  
    public void run() {
        System.out.println(&amp;quot;Wait Thread is now going to block!&amp;quot;);
        unsafe.park(false, 0);
        System.out.println(&amp;quot;WaitThread is now awake&amp;quot;);
    }
}

// 执行结果
Wait Thread is now going to block!
WorkThread is now working for 1 s
WorkThread is now working for 2 s
WorkThread is now working for 3 s
WorkThread is now working for 4 s
WorkThread is now working for 5 s
WorkThread is now to wake WaitThread
WaitThread is now awake
the end.
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;参考:&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;&lt;a href=&#34;http://hg.openjdk.java.net/jdk7/jdk7/jdk/file/9b8c96f96a0f/src/share/classes/sun/misc/Unsafe.java&#34;&gt;sun.misc.Unsafe基于JDK7的源码&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;a href=&#34;http://www.cnblogs.com/chenpi/p/5389254.html&#34;&gt;sun.misc.Unsafe的理解&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;a href=&#34;http://ifeve.com/sun-misc-unsafe/&#34;&gt;Java Magic. Part 4: sun.misc.Unsafe&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;a href=&#34;http://howtodoinjava.com/tag/java-hidden-features/&#34;&gt;java-hidden-features&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;a href=&#34;http://blog.csdn.net/fenglibing/article/details/17138079&#34;&gt;sun.misc.unsafe类的使用&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;a href=&#34;http://www.blogjava.net/xylz/archive/2010/07/04/325206.html&#34;&gt;深入浅出 Java Concurrency (5): 原子操作 part 4&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;a href=&#34;http://www.infoq.com/cn/articles/A-Post-Apocalyptic-sun.misc.Unsafe-World&#34;&gt;sun.misc.Unsafe的后启示录&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;a href=&#34;http://blog.csdn.net/aesop_wubo/article/details/7537278&#34;&gt;JAVA并发编程学习笔记之Unsafe类&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;a href=&#34;http://blog.csdn.net/dfdsggdgg/article/details/51538601&#34;&gt;sun.misc.Unsafe源码解析&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;a href=&#34;http://blog.csdn.net/dfdsggdgg/article/details/51543545&#34;&gt;sun.misc.Unsafe的各种神技&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;a href=&#34;http://blog.csdn.net/hengyunabc/article/details/28126139&#34;&gt;Java的LockSupport.park()实现分析&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;
</description>
    </item>
    
    <item>
      <title>AtomicLong源码分析</title>
      <link>http://nituchao.com/post/juc.atomic/atomic-long/</link>
      <pubDate>Thu, 23 Feb 2017 18:30:28 +0800</pubDate>
      
      <guid>http://nituchao.com/post/juc.atomic/atomic-long/</guid>
      <description>

&lt;h2 id=&#34;概述&#34;&gt;概述&lt;/h2&gt;

&lt;p&gt;在原子变量相关类中，AtomicBoolean, AtomicInteger, AtomicLong三个类是对于基本数据类型的操作，其原理和用法类似，区别在于Boolean, Integer, Long分别是8位，32位，64位的类型，本文重点研究AtomicLong。&lt;/p&gt;

&lt;p&gt;Boolean类型数据长度为8位，Integer类型数据是32位，在当前32位操作系统或者64位操作中都能够直接对其进行原子修改和读取。而Long类型数据是64位，在32位JVM上会当做两个分离的32位来进行操作，所以本身不具备原子性。&lt;/p&gt;

&lt;p&gt;还好我们现在的JDK基本都已经更新到64位，对long型数据的直接修改不存在原子性问题，但是当出现运算操作(比如++, —等)时还是会出现性问题，AtomicLong的目的是实现Long类型数据的各种原子操作。&lt;/p&gt;

&lt;p&gt;Java原子变量的实现依赖于&lt;code&gt;sun.misc.Unsafe&lt;/code&gt;的CAS操作和volatile的内存可见性语义。&lt;/p&gt;

&lt;p&gt;本文基于JDK1.7.0_67&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;java version &amp;ldquo;1.7.0&lt;em&gt;67&amp;rdquo;&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;_Java&amp;trade; SE Runtime Environment (build 1.7.0_67-b01)&lt;/p&gt;

&lt;p&gt;Java HotSpot&amp;trade; 64-Bit Server VM (build 24.65-b04, mixed mode)&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&#34;成员变量&#34;&gt;成员变量&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;// 成员变量unsafe是原子变量相关操作的基础
// 原子变量的修改操作最终有sun.misc.Unsafe类的CAS操作实现
private static final Unsafe unsafe = Unsafe.getUnsafe();
// 成员变量value的内存偏移值，在静态代码块中初始化
private static final long valueOffset;
// 通过volatile关键字保证可见性，用于保存值
private volatile long value;

// 记录当前虚拟机是否支持long的原子化操作，如果支持，可以使用CAS进行更新
// 这个问题主要是针对32位JVM对long的更新
static final boolean VM_SUPPORTS_LONG_CAS = VMSupportsCS8();

static {
  try {
    valueOffset = unsafe.objectFieldOffset
      	(AtomicLong.class.getDeclaredField(&amp;quot;value&amp;quot;));
  } catch (Exception ex) { throw new Error(ex); }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;函数列表&#34;&gt;函数列表&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;// 构造函数，初始化值为0
public AtomicLong()
// 构造函数，指定初始化值
public AtomicLong(long initialValue)
// 以原子方式获取当前值
public final long get()
// 以原子方式设置当前值为newValue
// 赋值语句是单操作，所以本身具有原子性
public final void set(long newValue)
// 最后设置为给定值。延时设置变量值，这个等价于set()方法，
// 但是由于字段是volatile类型的，因此此字段的修改会比普通字段
//（非volatile字段）有稍微的时间延时（尽管可以忽略），所以如果
// 不是想立即读取设置的新值，允许在“后台”修改值，那么此方法就很
// 有用。如果还是难以理解，这里就类似于启动一个后台线程如执行修
// 改新值的任务，原线程就不等待修改结果立即返回。
public final void lazySet(long newValue)
// 以原子方式设置当前值为newValue，并返回旧值
public final long getAndSet(long newValue)
// 以原子方式设置当前值为update。
// 如果当前值等于expect，并设置成功，返回true
// 如果当前值不等于expect，则设置失败，返回false
// 该过程不阻塞
public final boolean compareAndSet(long expect, long update)
// 以原子方式设置当前值为update。
// 如果当前值等于expect，并设置成功，返回true
// 如果当前值不等于expect，则设置失败，返回false
// 该过程不阻塞
// 该过程不保证volatile成员的happens-before语义顺序
public final boolean weakCompareAndSet(long expect, long update)
// 以原子的方式将当前值加1
// 该过程以自旋锁的形似循环执行，直到操作成功
// 该过程不会阻塞
// 返回更新前的值
public final long getAndIncrement()
// 以原子的方式将当前值减1
// 该过程以自旋的形式循环执行，直到操作成功
// 该过程不会阻塞
// 返回更新前的值
public final long getAndDecrement()
// 以原子方式将原值加上给定的delta
// 该过程以自旋的形式循环执行，直到操作成功
// 该过程不会阻塞
// 返回更新前的值
public final long getAndAdd(long delta)
// 以原子方式将原值加1
// 该过程以自旋的形式循环执行，直到操作成功
// 该过程不会阻塞
// 返回更新后的值
public final long incrementAndGet()
// 以原子方式将原值减1
// 该过程以自旋的形式循环执行，直到操作成功
// 该过程不会阻塞
// 返回更新后的值
public final long decrementAndGet()
// 以原子方式将原值加上给定的delta
// 该过程以自旋的形式循环执行，直到操作成功
// 该过程不会阻塞
// 返回更新后的值
public final long addAndGet(long delta)
// 将当前值使用Long的静态方法转换成String类型，并返回
public String toString()
// 将当前值使用强制类型转换成int类型，并返回
public int intValue()
// 直接返回当前值
public long longValue()
// 将当前值使用强制类型转换成float类型，并返回
public float floatValue()
// 将当前值使用强制类型转换成double类型，并返回
public double doubleValue()
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;重点函数分析&#34;&gt;重点函数分析&lt;/h2&gt;

&lt;h3 id=&#34;set&#34;&gt;set&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public final void set(long newValue) {
	value = newValue;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;以原子方式设置当前值为newValue，因为set方法只是一个单操作的赋值语句，因此是原子的。加上volatile的内存可见性保证，Set是原子操作无疑。&lt;/p&gt;

&lt;h3 id=&#34;lazyset&#34;&gt;lazySet&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public final void lazySet(long newValue) {
  	unsafe.putOrderedLong(this, valueOffset, newValue);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;简单点说，lazySet优先保证数据的修改操作，而降低对可见性的要求。&lt;/p&gt;

&lt;p&gt;lazySet是使用Unsafe.putOrderedObject方法，这个方法在对低延迟代码是很有用的，它能够实现非堵塞的写入，这些写入不会被Java的JIT重新排序指令(&lt;a href=&#34;http://stackoverflow.com/questions/14321212/java-instruction-reordering-cache-in-threads&#34;&gt;instruction reordering&lt;/a&gt;)，这样它使用快速的存储-存储(store-store) barrier, 而不是较慢的存储-加载(store-load) barrier, 后者总是用在volatile的写操作上，这种性能提升是有代价的，虽然便宜，也就是写后结果并不会被其他线程看到，甚至是自己的线程，通常是几纳秒后被其他线程看到，这个时间比较短，所以代价可以忍受。&lt;/p&gt;

&lt;p&gt;类似Unsafe.putOrderedObject还有unsafe.putOrderedLong等方法，unsafe.putOrderedLong比使用 volatile long要快3倍左右。&lt;/p&gt;

&lt;h3 id=&#34;compareandset&#34;&gt;compareAndSet&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public final boolean compareAndSet(long expect, long update) {
	return unsafe.compareAndSwapLong(this, valueOffset, expect, update);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;以原子方式设置当前值为update。如果当前值等于expect，并设置成功，返回true。如果当前值不等于expect，则设置失败，返回false。该过程不阻塞。由于是使用了&lt;code&gt;sun.misc.Unsafe&lt;/code&gt;的CAS操作实现，它是原子操作无疑。&lt;/p&gt;

&lt;p&gt;_&lt;em&gt;set和compareAndSet都是原子操作，只是他们的目的不同，set只是单纯想设置一个新的值。而compareAndSet则是希望在满足一定条件的情况下(当前值等于except)再设置新的值。&lt;/em&gt;&lt;/p&gt;

&lt;h3 id=&#34;weakcompareandset&#34;&gt;weakCompareAndSet&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public final boolean weakCompareAndSet(long expect, long update) {
	return unsafe.compareAndSwapLong(this, valueOffset, expect, update);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;以原子方式设置当前值为update。它的实现与compareAndSet完全一致。JDK文档中说，weakCompareAndSet在更新变量时并不创建任何&lt;code&gt;happens-before&lt;/code&gt;顺序，因此即使要修改的值是volatile的，也不保证对该变量的读写操作的顺序（一般来讲，volatile的内存语义保证&lt;code&gt;happens-before&lt;/code&gt;顺序）。&lt;/p&gt;

&lt;p&gt;参考：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;&lt;a href=&#34;http://www.cnblogs.com/timlearn/p/4127616.html&#34;&gt;Java并发——原子变量和原子操作&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;a href=&#34;https://stackoverflow.com/questions/1468007/atomicinteger-lazyset-vs-set&#34;&gt;AtomicInteger lazySet vs set&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;a href=&#34;https://stackoverflow.com/questions/19238594/java-atomic-variable-set-vs-compareandset&#34;&gt;Java Atomic Variable set() vs compareAndSet()&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;
</description>
    </item>
    
    <item>
      <title>AtomicLongArray源码分析</title>
      <link>http://nituchao.com/post/juc.atomic/atomic-long-array/</link>
      <pubDate>Thu, 23 Feb 2017 18:30:27 +0800</pubDate>
      
      <guid>http://nituchao.com/post/juc.atomic/atomic-long-array/</guid>
      <description>

&lt;h2 id=&#34;概述&#34;&gt;概述&lt;/h2&gt;

&lt;p&gt;在原子变量相关类中，AtomicIntegerArray, AtomicLongArray, AtomicReferenceArray三个类是对数组类型的原子类操作，其原理和用法类似，本文重点研究AtomicLongArray。&lt;/p&gt;

&lt;p&gt;Java原子变量的实现依赖于&lt;code&gt;sun.misc.Unsafe&lt;/code&gt;的CAS操作和volatile的内存可见性语义。&lt;/p&gt;

&lt;p&gt;本文基于JDK1.7.0_67&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;java version &amp;ldquo;1.7.0&lt;em&gt;67&amp;rdquo;&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;_Java&amp;trade; SE Runtime Environment (build 1.7.0_67-b01)&lt;/p&gt;

&lt;p&gt;Java HotSpot&amp;trade; 64-Bit Server VM (build 24.65-b04, mixed mode)&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&#34;成员变量&#34;&gt;成员变量&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;// 成员变量unsafe是原子变量相关操作的基础
// 原子变量的修改操作最终有sun.misc.Unsafe类的CAS操作实现
private static final Unsafe unsafe = Unsafe.getUnsafe();
// arrayBaseOffset获取数组首个元素地址偏移
private static final int base = unsafe.arrayBaseOffset(long[].class);
// shift就是数组元素的偏移量
private static final int shift;
// 保存数据的数组，在构造函数中初始化
private final long[] array;

static {
  	// scale数组元素的增量偏移 
    int scale = unsafe.arrayIndexScale(long[].class);
  	// 用二进制&amp;amp;操作判断是否是2的倍数，很精彩
    // 对于int型数组，scale是4
  	// 对于lang型数组，scale是8
    // 对于Reference型数组，scale是4
    if ((scale &amp;amp; (scale - 1)) != 0)
          throw new Error(&amp;quot;data type scale not a power of two&amp;quot;);
    // 这里是处理long型的偏移量
    // 对于int型的偏移量，shift是2
    // 对于lang型的偏移量，shift是3
  	// 对于Reference型的偏移量，shift是2
    shift = 31 - Integer.numberOfLeadingZeros(scale);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;函数列表&#34;&gt;函数列表&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;// 构造函数，初始化一个长度为length的空数组
public AtomicLongArray(int length)
// 构造函数，通过拷贝给定数组的值进行初始化
// 通过构造函数中final域的内存语义，保证数据可见性
public AtomicLongArray(long[] array)
// 检查索引值是否越界，并计算数组中元素的地址
private long checkedByteOffset(int i)
// 计算数组中元素的地址，首地址偏移+每个元素的偏移
// 采用了移位操作
private static long byteOffset(int i)
// 返回数组长度
public final int length()
// 以原子方式获取数组元素
public final long get(int i)
// 以原子方式获取数组元素，私有函数
private long getRaw(long offset)
// 以原子方式设置数组指定位置为新的值newValue
public final void set(int i, long newValue)
// 以原子方式设置数组指定位置为新的值newValue
// 该函数优先保证对数据的更新，而不保证数据可见性
// 该函数的性能比set函数好很多
public final void lazySet(int i, long newValue)
// 以原子方式设置数组指定位置为新的值newValue
// 该过程会以自旋的形式循环执行，直到操作成功
// 该过程不会阻塞
// 返回更新前的值
public final long getAndSet(int i, long newValue)
// 以原子方式设置数组指定位置为新的值update
// 如果当前值等于expect，并设置成功，返回true
// 如果当前值不等于expect，则设置失败，返回false
// 该过程不阻塞
public final boolean compareAndSet(int i, long expect, long update)
// 以原子方式设置数组指定位置为新的值update
// 如果当前值等于expect，并设置成功，返回true
// 如果当前值不等于expect，则设置失败，返回false
// 该过程不阻塞
// 私有函数
private boolean compareAndSetRaw(long offset, long expect, long update)
// 以原子方式设置数组指定位置为新的值update
// 如果当前值等于expect，并设置成功，返回true
// 如果当前值不等于expect，则设置失败，返回false
// 该过程不阻塞
// 该过程不保证volatile成员的happens-before语义顺序
public final boolean weakCompareAndSet(int i, long expect, long update)
// 以原子方式设置数组指定位置为当前值加1
// 该过程不阻塞
// 返回更新前的值
public final long getAndIncrement(int i)
// 以原子方式设置数组指定位置为当前值减1
// 该过程不阻塞
// 返回更新前的值
public final long getAndDecrement(int i)
// 以原子方式设置数组指定位置为当前值+delta
// 该过程不阻塞
// 返回更新前的值
public final long getAndAdd(int i, long delta)
// 以原子方式设置数组指定位置为当前值加1
// 该过程不阻塞
// 返回更新前的值
public final long incrementAndGet(int i)
// 以原子方式设置数组指定位置为当前值减1
// 该过程不阻塞
// 返回更新前的值
public final long decrementAndGet(int i)
// 以原子方式设置数组指定位置为当前值+delta
// 该过程不阻塞
// 返回更新后的值
public long addAndGet(int i, long delta)
// 遍历数组中的每一个值，构造字符串
// 返回构造的字符串
public String toString()
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;重要函数分析&#34;&gt;重要函数分析&lt;/h2&gt;

&lt;h3 id=&#34;checkedbyoffset-int-i&#34;&gt;checkedByOffset(int i)&lt;/h3&gt;

&lt;p&gt;首先判断索引值&lt;code&gt;i&lt;/code&gt;是否越界，如果越界，则抛出越界异常。否则，调用byteOffset(int i)函数计算该索引值&lt;code&gt;i&lt;/code&gt;对应在数组中的内存偏移值，该偏移值被&lt;code&gt;sun.misc.Unsafe&lt;/code&gt;类的函数使用。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;private long checkedByteOffset(int i) {
    if (i &amp;lt; 0 || i &amp;gt;= array.length)
        throw new IndexOutOfBoundsException(&amp;quot;index &amp;quot; + i);

    return byteOffset(i);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;byteoffset-int-i&#34;&gt;byteOffset(int i)&lt;/h3&gt;

&lt;p&gt;根据索引值&lt;code&gt;i&lt;/code&gt;，计算数组中元素的地址，首地址偏移+每个元素的偏移&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;private static long byteOffset(int i) {
    return ((long) i &amp;lt;&amp;lt; shift) + base;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;lazyset-int-i-long-newvalue&#34;&gt;lazySet(int i, long newValue)&lt;/h3&gt;

&lt;p&gt;简单点说，lazySet优先保证数据的修改操作，而降低对可见性的要求。&lt;/p&gt;

&lt;p&gt;lazySet是使用Unsafe.putOrderedLong方法，这个方法在对低延迟代码是很有用的，它能够实现非堵塞的写入，这些写入不会被Java的JIT重新排序指令(&lt;a href=&#34;http://stackoverflow.com/questions/14321212/java-instruction-reordering-cache-in-threads&#34;&gt;instruction reordering&lt;/a&gt;)，这样它使用快速的存储-存储(store-store) barrier, 而不是较慢的存储-加载(store-load) barrier, 后者总是用在volatile的写操作上，这种性能提升是有代价的，虽然便宜，也就是写后结果并不会被其他线程看到，甚至是自己的线程，通常是几纳秒后被其他线程看到，这个时间比较短，所以代价可以忍受。&lt;/p&gt;

&lt;p&gt;类似Unsafe.putOrderedLong还有unsafe.putOrderedObject等方法，unsafe.putOrderedLong比使用 volatile long要快3倍左右。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;public final void lazySet(int i, long newValue) {
    unsafe.putOrderedLong(array, checkedByteOffset(i), newValue);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;getandset-int-i-long-newvalue&#34;&gt;getAndSet(int i, long newValue)&lt;/h3&gt;

&lt;p&gt;以原子方式设置数组指定位置为新的值newValue，该过程会以自旋的形式循环执行，直到操作成功。该过程不会阻塞。因为该函数包含两个操作(get和set)，因此需要使用自旋方式通过&lt;code&gt;sun.misc.Unsafe&lt;/code&gt;的CAS操作保证原子性。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;public final long getAndSet(int i, long newValue) {
    long offset = checkedByteOffset(i);
    while (true) {
        long current = getRaw(offset);
        if (compareAndSetRaw(offset, current, newValue))
            return current;
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;tostring&#34;&gt;toString()&lt;/h3&gt;

&lt;p&gt;通过遍历数组中元素来构造字符串，并返回。该函数是线程不安全的，在操作过程中内容可能会发生变化，使得AtomicLongArray具有若一致性。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;public String toString() {
    int iMax = array.length - 1;
    if (iMax == -1)
        return &amp;quot;[]&amp;quot;;

    StringBuilder b = new StringBuilder();
    b.append(&#39;[&#39;);
    for (int i = 0; ; i++) {
        b.append(getRaw(byteOffset(i)));
        if (i == iMax)
            return b.append(&#39;]&#39;).toString();
        b.append(&#39;,&#39;).append(&#39; &#39;);
    }
}
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>AtomicReference源码分析</title>
      <link>http://nituchao.com/post/juc.atomic/atomic-reference/</link>
      <pubDate>Thu, 23 Feb 2017 18:30:27 +0800</pubDate>
      
      <guid>http://nituchao.com/post/juc.atomic/atomic-reference/</guid>
      <description>

&lt;h2 id=&#34;概述&#34;&gt;概述&lt;/h2&gt;

&lt;p&gt;在原子变量相关类中，AtomicReference, AtomicStampedReference, AtomicMarkableReference三个类是对于引用类型的操作，其原理和用法类似。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;AtomicStampedReference&lt;/code&gt;是带了整型版本号(int stamp)的引用型原子变量，每次执行CAS操作时需要对比版本，如果版本满足要求，则操作成功，否则操作失败，用于防止CAS操作的ABA问题。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;AtomicMarkableReference&lt;/code&gt;则是带了布尔型标记位(Boolean mark)的引用型原子量，每次执行CAS操作是需要对比该标记位，如果标记满足要求，则操作成功，否则操作失败。&lt;/p&gt;

&lt;p&gt;Java原子变量的实现依赖于&lt;code&gt;sun.misc.Unsafe&lt;/code&gt;的CAS操作和volatile的内存可见性语义。&lt;/p&gt;

&lt;p&gt;本文基于JDK1.7.0_67&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;java version &amp;ldquo;1.7.0&lt;em&gt;67&amp;rdquo;&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;_Java&amp;trade; SE Runtime Environment (build 1.7.0_67-b01)&lt;/p&gt;

&lt;p&gt;Java HotSpot&amp;trade; 64-Bit Server VM (build 24.65-b04, mixed mode)&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&#34;成员变量&#34;&gt;成员变量&lt;/h2&gt;

&lt;p&gt;&lt;code&gt;AtomicReference&lt;/code&gt;通过泛型&lt;code&gt;T&lt;/code&gt;来声明成员值的类型，表示这是对引用类型的操作。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;// 成员变量unsafe是原子变量相关操作的基础
// 原子变量的修改操作最终有sun.misc.Unsafe类的CAS操作实现
private static final Unsafe unsafe = Unsafe.getUnsafe();
// 成员变量value的内存偏移值，在静态代码块中初始化
private static final long valueOffset;
// 通过volatile关键字保证可见性，用于保存值
private volatile V value;

static {
  try {
    valueOffset = unsafe.objectFieldOffset
      (AtomicReference.class.getDeclaredField(&amp;quot;value&amp;quot;));
  } catch (Exception ex) { throw new Error(ex); }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;函数列表&#34;&gt;函数列表&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;// 构造函数，初始化值为null
public AtomicReference()
// 构造函数，指定初始化值
public AtomicReference(V initialValue)
// 以原子方式获取当前值
public final V get()
// 以原子方式设置当前值为新的值newValue
public final void set(V newValue)
// 以原子方式设置当前值为新的值newValue
// 优先保证修改操作，而不保证volatile的可见性语义
// 效率较高
public final void lazySet(V newValue)
// 以原子方式设置当前值为update
// 如果当前值等于except，则设置成功，返回true
// 如果当前值不等于except，则设置失败，返回fase
// 该过程不阻塞
public final boolean compareAndSet(V expect, V update)
// 以原子方式设置当前值为update
// 如果当前值等于except，则设置成功，返回true
// 如果当前值不等于except，则设置失败，返回fase
// 该过程不阻塞
// 该过程不保证volatile成员的happens-before语义顺序
public final boolean weakCompareAndSet(V expect, V update)
// 以原子方式设置当前值为update
// 返回更新前的值
public final V getAndSet(V newValue)
// 返回当前值的string表达式
public String toString()
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;重点函数分析&#34;&gt;重点函数分析&lt;/h2&gt;

&lt;h3 id=&#34;set-v-newvalue&#34;&gt;set(V newValue)&lt;/h3&gt;

&lt;p&gt;以原子方式设置当前值为newValue，因为set方法只是一个单操作的赋值语句，因此是原子的。加上volatile的内存可见性保证，Set是原子操作无疑。&lt;/p&gt;

&lt;h3 id=&#34;lazyset-v-newvalue&#34;&gt;lazySet(V newValue)&lt;/h3&gt;

&lt;p&gt;简单点说，lazySet优先保证数据的修改操作，而降低对可见性的要求。&lt;/p&gt;

&lt;p&gt;lazySet是使用Unsafe.putOrderedObject方法，这个方法在对低延迟代码是很有用的，它能够实现非堵塞的写入，这些写入不会被Java的JIT重新排序指令(&lt;a href=&#34;http://stackoverflow.com/questions/14321212/java-instruction-reordering-cache-in-threads&#34;&gt;instruction reordering&lt;/a&gt;)，这样它使用快速的存储-存储(store-store) barrier, 而不是较慢的存储-加载(store-load) barrier, 后者总是用在volatile的写操作上，这种性能提升是有代价的，虽然便宜，也就是写后结果并不会被其他线程看到，甚至是自己的线程，通常是几纳秒后被其他线程看到，这个时间比较短，所以代价可以忍受。&lt;/p&gt;

&lt;p&gt;类似Unsafe.putOrderedObject还有unsafe.putOrderedLong等方法，unsafe.putOrderedLong比使用 volatile long要快3倍左右。&lt;/p&gt;

&lt;h2 id=&#34;compareandset-v-expect-v-update&#34;&gt;compareAndSet(V expect,V update)&lt;/h2&gt;

&lt;p&gt;以原子方式设置当前值为update。如果当前值等于expect，并设置成功，返回true。如果当前值不等于expect，则设置失败，返回false。该过程不阻塞。由于是使用了&lt;code&gt;sun.misc.Unsafe&lt;/code&gt;的CAS操作实现，它是原子操作无疑。&lt;/p&gt;

&lt;p&gt;_&lt;em&gt;set和compareAndSet都是原子操作，只是他们的目的不同，set只是单纯想设置一个新的值。而compareAndSet则是希望在满足一定条件的情况下(当前值等于except)再设置新的值。&lt;/em&gt;&lt;/p&gt;

&lt;h2 id=&#34;weakcompareandset-v-expect-v-update&#34;&gt;weakCompareAndSet(V expect,V update)&lt;/h2&gt;

&lt;p&gt;以原子方式设置当前值为update。它的实现与compareAndSet完全一致。JDK文档中说，weakCompareAndSet在更新变量时并不创建任何&lt;code&gt;happens-before&lt;/code&gt;顺序，因此即使要修改的值是volatile的，也不保证对该变量的读写操作的顺序（一般来讲，volatile的内存语义保证&lt;code&gt;happens-before&lt;/code&gt;顺序）。&lt;/p&gt;

&lt;p&gt;参考:&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;a href=&#34;https://developer.xamarin.com/api/type/Java.Util.Concurrent.Atomic.AtomicMarkableReference/&#34;&gt;Java.Util.Concurrent.Atomic.AtomicMarkableReference Class&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;
</description>
    </item>
    
    <item>
      <title>AtomicStampedReference源码分析</title>
      <link>http://nituchao.com/post/juc.atomic/atomic-stamped-reference/</link>
      <pubDate>Thu, 23 Feb 2017 18:30:27 +0800</pubDate>
      
      <guid>http://nituchao.com/post/juc.atomic/atomic-stamped-reference/</guid>
      <description>

&lt;h2 id=&#34;概述&#34;&gt;概述&lt;/h2&gt;

&lt;p&gt;在原子变量相关类中，AtomicReference, AtomicStampedReference, AtomicMarkableReference三个类是对于引用类型的操作，其原理和用法类似。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;AtomicStampedReference&lt;/code&gt;是带了整型版本号(int stamp)的引用型原子变量，每次执行CAS操作时需要对比版本，如果版本满足要求，则操作成功，否则操作失败，用于防止CAS操作的ABA问题。本文重点分析&lt;code&gt;AtomicStampedReference&lt;/code&gt;。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;AtomicMarkableReference&lt;/code&gt;则是带了布尔型标记位(Boolean mark)的引用型原子量，每次执行CAS操作是需要对比该标记位，如果标记满足要求，则操作成功，否则操作失败。&lt;/p&gt;

&lt;p&gt;Java原子变量的实现依赖于&lt;code&gt;sun.misc.Unsafe&lt;/code&gt;的CAS操作和volatile的内存可见性语义。&lt;/p&gt;

&lt;p&gt;本文基于JDK1.7.0_67&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;java version &amp;ldquo;1.7.0&lt;em&gt;67&amp;rdquo;&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;_Java&amp;trade; SE Runtime Environment (build 1.7.0_67-b01)&lt;/p&gt;

&lt;p&gt;Java HotSpot&amp;trade; 64-Bit Server VM (build 24.65-b04, mixed mode)&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&#34;内部类&#34;&gt;内部类&lt;/h3&gt;

&lt;p&gt;&lt;code&gt;AtomicStampedReference&lt;/code&gt;是带整形版本号的原子引用类型，为了同时兼顾引用值和版本号，它定义了一个静态内部类&lt;code&gt;Pair&lt;/code&gt;，&lt;code&gt;AtomicStampedReference&lt;/code&gt;的相关操作都是对&lt;code&gt;Pair&lt;/code&gt;内成员的操作。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;private static class Pair&amp;lt;T&amp;gt; {
    final T reference;
    final int stamp;
    private Pair(T reference, int stamp) {
        this.reference = reference;
        this.stamp = stamp;
    }
    static &amp;lt;T&amp;gt; Pair&amp;lt;T&amp;gt; of(T reference, int stamp) {
      	return new Pair&amp;lt;T&amp;gt;(reference, stamp);
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;成员变量&#34;&gt;成员变量&lt;/h2&gt;

&lt;p&gt;&lt;code&gt;AtomicStampedReference&lt;/code&gt;除了常规的&lt;code&gt;sun.misc.Unsafe&lt;/code&gt;实例和&lt;code&gt;pairOffset&lt;/code&gt;内存偏移量外，声明了一个&lt;code&gt;volatile&lt;/code&gt;的&lt;code&gt;Pair&amp;lt;T&amp;gt;&lt;/code&gt;成员，用于同时维护引用值和版本号。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;// 成员变量unsafe是原子变量相关操作的基础
// 原子变量的修改操作最终有sun.misc.Unsafe类的CAS操作实现
private static final sun.misc.Unsafe UNSAFE = Unsafe.getUnsafe();
// 成员变量value的内存偏移值
private static final long pairOffset = objectFieldOffset(UNSAFE, &amp;quot;pair&amp;quot;, AtomicStampedReference.class);
// 用volatile的内存语义保证可见性
// 保存引用值和版本号
private volatile Pair&amp;lt;V&amp;gt; pair;

// 获取指定域的内存偏移量
static long objectFieldOffset(sun.misc.Unsafe UNSAFE,
                              String field, Class&amp;lt;?&amp;gt; klazz) {
    try {
        return UNSAFE.objectFieldOffset(klazz.getDeclaredField(field));
    } catch (NoSuchFieldException e) {
        // Convert Exception to corresponding Error
        NoSuchFieldError error = new NoSuchFieldError(field);
        error.initCause(e);
        throw error;
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;函数列表&#34;&gt;函数列表&lt;/h2&gt;

&lt;p&gt;由于&lt;code&gt;AtomicStampedReference&lt;/code&gt;要同时维护引用值和版本号，因此很多操作变得复杂。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;// 构造函数，初始化引用和版本号
public AtomicStampedReference(V initialRef, int initialStamp)
// 以原子方式获取当前引用值
public V getReference()
// 以原子方式获取当前版本号
public int getStamp()
// 以原子方式获取当前引用值和版本号
public V get(int[] stampHolder)
// 以原子的方式同时更新引用值和版本号
// 当期望引用值不等于当前引用值时，操作失败，返回false
// 当期望版本号不等于当前版本号时，操作失败，返回false
// 在期望引用值和期望版本号同时等于当前值的前提下
// 当新的引用值和新的版本号同时等于当前值时，不更新，直接返回true
// 当新的引用值和新的版本号不同时等于当前值时，同时设置新的引用值和新的版本号，返回true
// 该过程不保证volatile成员的happens-before语义顺序
public boolean weakCompareAndSet(V  expectedReference,
                                 V  newReference,
                                 int expectedStamp,
                                 int newStamp)
// 以原子的方式同时更新引用值和版本号
// 当期望引用值不等于当前引用值时，操作失败，返回false
// 当期望版本号不等于当前版本号时，操作失败，返回false
// 在期望引用值和期望版本号同时等于当前值的前提下
// 当新的引用值和新的版本号同时等于当前值时，不更新，直接返回true
// 当新的引用值和新的版本号不同时等于当前值时，同时设置新的引用值和新的版本号，返回true
public boolean compareAndSet(V   expectedReference,
                             V   newReference,
                             int expectedStamp,
                             int newStamp)
// 以原子方式设置引用的当前值为新值newReference
// 同时，以原子方式设置版本号的当前值为新值newStamp
// 新引用值和新版本号只要有一个跟当前值不一样，就进行更新
public void set(V newReference, int newStamp)
// 以原子方式设置版本号为新的值
// 前提：引用值保持不变
// 当期望的引用值与当前引用值不相同时，操作失败，返回fasle
// 当期望的引用值与当前引用值相同时，操作成功，返回true
public boolean attemptStamp(V expectedReference, int newStamp)
// 使用`sun.misc.Unsafe`类原子地交换两个对象
private boolean casPair(Pair&amp;lt;V&amp;gt; cmp, Pair&amp;lt;V&amp;gt; val)
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;重点函数分析&#34;&gt;重点函数分析&lt;/h2&gt;

&lt;h3 id=&#34;atomicstampedreference&#34;&gt;AtomicStampedReference&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public AtomicStampedReference(V initialRef, int initialStamp) {
  	pair = Pair.of(initialRef, initialStamp);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;构造函数，根据指定的引用值和版本号，构造一个Pair对象，并将该对象赋值给成员变量&lt;code&gt;pair&lt;/code&gt;。&lt;/p&gt;

&lt;p&gt;由于成员变量&lt;code&gt;pair&lt;/code&gt;被volatile修饰，并且这里只有一个单操作的赋值语句，因此是可以保证原子性的。&lt;/p&gt;

&lt;h3 id=&#34;get&#34;&gt;get&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public V get(int[] stampHolder) {
    Pair&amp;lt;V&amp;gt; pair = this.pair;
    stampHolder[0] = pair.stamp;
    return pair.reference;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;真个函数很有意思，同时获取引用值和版本号。由于Java程序只能有一个返回值，该函数通过一个数组参数&lt;code&gt;int[] stampHolder&lt;/code&gt;来返回版本号，而通过&lt;code&gt;return&lt;/code&gt;语句返回引用值。&lt;/p&gt;

&lt;h3 id=&#34;set&#34;&gt;set&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public void set(V newReference, int newStamp) {
	Pair&amp;lt;V&amp;gt; current = pair;
	if (newReference != current.reference || newStamp != current.stamp)
		this.pair = Pair.of(newReference, newStamp);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;只要新的引用值和新的版本号，有一个与当前值不一样的，就同时修改引用值和版本号。&lt;/p&gt;

&lt;h3 id=&#34;compareandset&#34;&gt;compareAndSet&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public boolean compareAndSet(V   expectedReference,
                             V   newReference,
                             int expectedStamp,
                             int newStamp) {
 	Pair&amp;lt;V&amp;gt; current = pair;
 	return
 		expectedReference == current.reference &amp;amp;&amp;amp;
 		expectedStamp == current.stamp &amp;amp;&amp;amp;
 		((newReference == current.reference &amp;amp;&amp;amp;
 		  newStamp == current.stamp) ||
 		  casPair(current, Pair.of(newReference, newStamp)));
 }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;以原子的方式同时更新引用值和版本号。&lt;/p&gt;

&lt;p&gt;当期望引用值不等于当前引用值时，操作失败，返回false。&lt;/p&gt;

&lt;p&gt;当期望版本号不等于当前版本号时，操作失败，返回false。&lt;/p&gt;

&lt;p&gt;在期望引用值和期望版本号同时等于当前值的前提下，当新的引用值和新的版本号同时等于当前值时，不更新，直接返回true。由于要修改的内容与原内容完全一致，这种处理可以避免一次内存操作，效率较高。&lt;/p&gt;

&lt;p&gt;当新的引用值和新的版本号不同时等于当前值时，同时设置新的引用值和新的版本号，返回true&lt;/p&gt;

&lt;h3 id=&#34;weakcompareandset&#34;&gt;weakCompareAndSet&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public boolean weakCompareAndSet(V   expectedReference,
                                 V   newReference,
                                 int expectedStamp,
                                 int newStamp) {
  	return compareAndSet(expectedReference, newReference,
                       	 expectedStamp, newStamp);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;以原子的方式同时更新引用值和版本号。该是通过调用CompareAndSet实现的。JDK文档中说，weakCompareAndSet在更新变量时并不创建任何&lt;code&gt;happens-before&lt;/code&gt;顺序，因此即使要修改的值是volatile的，也不保证对该变量的读写操作的顺序（一般来讲，volatile的内存语义保证&lt;code&gt;happens-before&lt;/code&gt;顺序）。&lt;/p&gt;

&lt;h3 id=&#34;attemptstamp&#34;&gt;attemptStamp&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public boolean attemptStamp(V expectedReference, int newStamp) {
  	Pair&amp;lt;V&amp;gt; current = pair;
  	return
    	expectedReference == current.reference &amp;amp;&amp;amp;
    	(newStamp == current.stamp ||
     	 casPair(current, Pair.of(expectedReference, newStamp)));
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;修改指定引用值的版本号。&lt;/p&gt;

&lt;p&gt;当期望的引用值与当前引用值不相同时，操作失败，返回fasle。
当期望的引用值与当前引用值相同时，操作成功，返回true。&lt;/p&gt;

&lt;h3 id=&#34;caspair&#34;&gt;casPair&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;private boolean casPair(Pair&amp;lt;V&amp;gt; cmp, Pair&amp;lt;V&amp;gt; val) {
  	return UNSAFE.compareAndSwapObject(this, pairOffset, cmp, val);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;使用&lt;code&gt;sun.misc.Unsafe&lt;/code&gt;类原子地交换两个对象。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>AtomicMarkableReference源码分析</title>
      <link>http://nituchao.com/post/juc.atomic/atomic-markable-reference/</link>
      <pubDate>Thu, 23 Feb 2017 18:30:25 +0800</pubDate>
      
      <guid>http://nituchao.com/post/juc.atomic/atomic-markable-reference/</guid>
      <description>

&lt;h2 id=&#34;概述&#34;&gt;概述&lt;/h2&gt;

&lt;p&gt;在原子变量相关类中，AtomicReference, AtomicStampedReference, AtomicMarkableReference三个类是对于引用类型的操作，其原理和用法类似。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;AtomicStampedReference&lt;/code&gt;是带了整型标记值(int stamp)的引用型原子变量，每次执行CAS操作时需要对比版本，如果版本满足要求，则操作成功，否则操作失败，用于防止CAS操作的ABA问题。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;AtomicMarkableReference&lt;/code&gt;则是带了布尔型标记位(Boolean mark)的引用型原子量，每次执行CAS操作是需要对比该标记位，如果标记满足要求，则操作成功，否则操作失败。本文重点分析&lt;code&gt;AtomicMarkableReference&lt;/code&gt;。&lt;/p&gt;

&lt;p&gt;Java原子变量的实现依赖于&lt;code&gt;sun.misc.Unsafe&lt;/code&gt;的CAS操作和volatile的内存可见性语义。&lt;/p&gt;

&lt;p&gt;本文基于JDK1.7.0_67&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;java version &amp;ldquo;1.7.0_&lt;em&gt;67&amp;rdquo;&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;_Java&amp;trade; SE Runtime Environment (build 1.7.0_67-b01)&lt;/p&gt;

&lt;p&gt;Java HotSpot&amp;trade; 64-Bit Server VM (build 24.65-b04, mixed mode)&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&#34;内部类&#34;&gt;内部类&lt;/h3&gt;

&lt;p&gt;&lt;code&gt;AtomicMarkableReference&lt;/code&gt;是带布尔型标记为的原子引用类型，为了同时兼顾引用值和标记位，它定义了一个静态内部类&lt;code&gt;Pair&lt;/code&gt;，&lt;code&gt;AtomicMarkableReference&lt;/code&gt;的相关操作都是对&lt;code&gt;Pair&lt;/code&gt;内成员的操作。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;private static class Pair&amp;lt;T&amp;gt; {
    final T reference;
    final boolean mark;
    private Pair(T reference, boolean mark) {
        this.reference = reference;
        this.mark = mark;
    }
    static &amp;lt;T&amp;gt; Pair&amp;lt;T&amp;gt; of(T reference, int mark) {
      	return new Pair&amp;lt;T&amp;gt;(reference, mark);
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;成员变量&#34;&gt;成员变量&lt;/h2&gt;

&lt;p&gt;&lt;code&gt;AtomicMarkableReference&lt;/code&gt;除了常规的&lt;code&gt;sun.misc.Unsafe&lt;/code&gt;实例和&lt;code&gt;pairOffset&lt;/code&gt;内存偏移量外，声明了一个&lt;code&gt;volatile&lt;/code&gt;的&lt;code&gt;Pair&amp;lt;T&amp;gt;&lt;/code&gt;成员，用于同时维护引用值和标记值。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;// 成员变量unsafe是原子变量相关操作的基础
// 原子变量的修改操作最终有sun.misc.Unsafe类的CAS操作实现
private static final sun.misc.Unsafe UNSAFE = Unsafe.getUnsafe();
// 成员变量value的内存偏移值
private static final long pairOffset = objectFieldOffset(UNSAFE, &amp;quot;pair&amp;quot;, AtomicMarkableReference.class);
// 用volatile的内存语义保证可见性
// 保存引用值和标记值
private volatile Pair&amp;lt;V&amp;gt; pair;

// 获取指定域的内存偏移量
static long objectFieldOffset(sun.misc.Unsafe UNSAFE,
                              String field, Class&amp;lt;?&amp;gt; klazz) {
    try {
        return UNSAFE.objectFieldOffset(klazz.getDeclaredField(field));
    } catch (NoSuchFieldException e) {
        // Convert Exception to corresponding Error
        NoSuchFieldError error = new NoSuchFieldError(field);
        error.initCause(e);
        throw error;
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;函数列表&#34;&gt;函数列表&lt;/h2&gt;

&lt;p&gt;由于&lt;code&gt;AtomicMarkableReference&lt;/code&gt;要同时维护引用值和标记值，因此很多操作变得复杂。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;// 构造函数，初始化引用和标记值
public AtomicMarkableReference(V initialRef, boolean initialMark)
// 以原子方式获取当前引用值
public V getReference()
// 以原子方式获取当前标记值
public int isMarked()
// 以原子方式获取当前引用值和标记值
public V get(boolean[] markHolder)
// 以原子的方式同时更新引用值和标记值
// 当期望引用值不等于当前引用值时，操作失败，返回false
// 当期望标记值不等于当前标记值时，操作失败，返回false
// 在期望引用值和期望标记值同时等于当前值的前提下
// 当新的引用值和新的标记值同时等于当前值时，不更新，直接返回true
// 当新的引用值和新的标记值不同时等于当前值时，同时设置新的引用值和新的标记值，返回true
// 该过程不保证volatile成员的happens-before语义顺序
public boolean weakCompareAndSet(V  expectedReference,
                                 V  newReference,
                                 int expectedMark,
                                 int newMark)
// 以原子的方式同时更新引用值和标记值
// 当期望引用值不等于当前引用值时，操作失败，返回false
// 当期望标记值不等于当前标记值时，操作失败，返回false
// 在期望引用值和期望标记值同时等于当前值的前提下
// 当新的引用值和新的标记值同时等于当前值时，不更新，直接返回true
// 当新的引用值和新的标记值不同时等于当前值时，同时设置新的引用值和新的标记值，返回true
public boolean compareAndSet(V   expectedReference,
                             V   newReference,
                             int expectedMark,
                             int newMark)
// 以原子方式设置引用的当前值为新值newReference
// 同时，以原子方式设置标记值的当前值为新值newMark
// 新引用值和新标记值只要有一个跟当前值不一样，就进行更新
public void set(V newReference, int newMark)
// 以原子方式设置标记值为新的值
// 前提：引用值保持不变
// 当期望的引用值与当前引用值不相同时，操作失败，返回fasle
// 当期望的引用值与当前引用值相同时，操作成功，返回true
public boolean attemptMark(V expectedReference, int newMark)
// 使用`sun.misc.Unsafe`类原子地交换两个对象
private boolean casPair(Pair&amp;lt;V&amp;gt; cmp, Pair&amp;lt;V&amp;gt; val)
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;重点函数分析&#34;&gt;重点函数分析&lt;/h2&gt;

&lt;h3 id=&#34;atomicmarkablereference&#34;&gt;AtomicMarkableReference&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public AtomicMarkableReference(V initialRef, int initialMark) {
  	pair = Pair.of(initialRef, initialMark);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;构造函数，根据指定的引用值和标记值，构造一个Pair对象，并将该对象赋值给成员变量&lt;code&gt;pair&lt;/code&gt;。&lt;/p&gt;

&lt;p&gt;由于成员变量&lt;code&gt;pair&lt;/code&gt;被volatile修饰，并且这里只有一个单操作的赋值语句，因此是可以保证原子性的。&lt;/p&gt;

&lt;h3 id=&#34;get&#34;&gt;get&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public V get(int[] markHolder) {
    Pair&amp;lt;V&amp;gt; pair = this.pair;
    markHolder[0] = pair.markz;
    return pair.reference;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;真个函数很有意思，同时获取引用值和标记值。由于Java程序只能有一个返回值，该函数通过一个数组参数&lt;code&gt;int[] markHolder&lt;/code&gt;来返回标记值，而通过&lt;code&gt;return&lt;/code&gt;语句返回引用值。&lt;/p&gt;

&lt;h3 id=&#34;set&#34;&gt;set&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public void set(V newReference, int newMark) {
	Pair&amp;lt;V&amp;gt; current = pair;
	if (newReference != current.reference || newMark != current.mark)
		this.pair = Pair.of(newReference, newMark);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;只要新的引用值和新的标记值，有一个与当前值不一样的，就同时修改引用值和标记值。&lt;/p&gt;

&lt;h3 id=&#34;compareandset&#34;&gt;compareAndSet&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public boolean compareAndSet(V   expectedReference,
                             V   newReference,
                             int expectedMark,
                             int newMark) {
 	Pair&amp;lt;V&amp;gt; current = pair;
 	return
 		expectedReference == current.reference &amp;amp;&amp;amp;
 		expectedMark == current.mark &amp;amp;&amp;amp;
 		((newReference == current.reference &amp;amp;&amp;amp;
 		  newMark == current.mark) ||
 		  casPair(current, Pair.of(newReference, newMark)));
 }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;以原子的方式同时更新引用值和标记值。&lt;/p&gt;

&lt;p&gt;当期望引用值不等于当前引用值时，操作失败，返回false。&lt;/p&gt;

&lt;p&gt;当期望标记值不等于当前标记值时，操作失败，返回false。&lt;/p&gt;

&lt;p&gt;在期望引用值和期望标记值同时等于当前值的前提下，当新的引用值和新的标记值同时等于当前值时，不更新，直接返回true。由于要修改的内容与原内容完全一致，这种处理可以避免一次内存操作，效率较高。&lt;/p&gt;

&lt;p&gt;当新的引用值和新的标记值不同时等于当前值时，同时设置新的引用值和新的标记值，返回true&lt;/p&gt;

&lt;h3 id=&#34;weakcompareandset&#34;&gt;weakCompareAndSet&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public boolean weakCompareAndSet(V   expectedReference,
                                 V   newReference,
                                 int expectedMark,
                                 int newMark) {
  	return compareAndSet(expectedReference, newReference,
                       	 expectedMark, newMark);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;以原子的方式同时更新引用值和标记值。该是通过调用CompareAndSet实现的。JDK文档中说，weakCompareAndSet在更新变量时并不创建任何&lt;code&gt;happens-before&lt;/code&gt;顺序，因此即使要修改的值是volatile的，也不保证对该变量的读写操作的顺序（一般来讲，volatile的内存语义保证&lt;code&gt;happens-before&lt;/code&gt;顺序）。&lt;/p&gt;

&lt;h3 id=&#34;attemptmark&#34;&gt;attemptMark&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public boolean attemptMark(V expectedReference, int newMark) {
  	Pair&amp;lt;V&amp;gt; current = pair;
  	return
    	expectedReference == current.reference &amp;amp;&amp;amp;
    	(newMark == current.mark ||
     	 casPair(current, Pair.of(expectedReference, newMark)));
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;修改指定引用值的标记值。&lt;/p&gt;

&lt;p&gt;当期望的引用值与当前引用值不相同时，操作失败，返回fasle。
当期望的引用值与当前引用值相同时，操作成功，返回true。&lt;/p&gt;

&lt;h3 id=&#34;caspair&#34;&gt;casPair&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;private boolean casPair(Pair&amp;lt;V&amp;gt; cmp, Pair&amp;lt;V&amp;gt; val) {
  	return UNSAFE.compareAndSwapObject(this, pairOffset, cmp, val);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;使用&lt;code&gt;sun.misc.Unsafe&lt;/code&gt;类原子地交换两个对象。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Java锁之CAS的原理</title>
      <link>http://nituchao.com/post/juc.lock/java-cas/</link>
      <pubDate>Thu, 23 Feb 2017 18:29:27 +0800</pubDate>
      
      <guid>http://nituchao.com/post/juc.lock/java-cas/</guid>
      <description>&lt;p&gt;参考:&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;a href=&#34;http://zl198751.iteye.com/blog/1848575&#34;&gt;JAVA CAS原理深度分析&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;
</description>
    </item>
    
    <item>
      <title>Java锁之自旋锁的原理</title>
      <link>http://nituchao.com/post/juc.lock/clh-spin-ticket-mcs-lock/</link>
      <pubDate>Thu, 23 Feb 2017 18:29:27 +0800</pubDate>
      
      <guid>http://nituchao.com/post/juc.lock/clh-spin-ticket-mcs-lock/</guid>
      <description>

&lt;h2 id=&#34;概述&#34;&gt;概述&lt;/h2&gt;

&lt;p&gt;锁作为数据同步工具，Java提供了两种实现：synchronized和AQS，这两种锁的实现根本不同，但是在加锁和解锁的过程中，也有很多共同点。它们在进行加锁/解锁时或多或少的用到自旋锁的设计思想。对于这几种自旋锁设计思想的研究，可以帮助我们更好的理解Java的Lock框架。&lt;/p&gt;

&lt;h2 id=&#34;spin锁&#34;&gt;SPIN锁&lt;/h2&gt;

&lt;p&gt;Spin锁即自旋锁。自旋锁是采用让当前线程不停地在循环体内&lt;code&gt;检测并设置临界资源的状态&lt;/code&gt;，直到状态满足条件并设置为指定的新状态。&lt;code&gt;检测并设置临界资源&lt;/code&gt;操作必须是原子的，这样即使多个线程在给定时间自旋，也只有一个线程可获得该锁。&lt;/p&gt;

&lt;p&gt;自旋锁的优点之一是自旋的线程不会被阻塞，一直处于活跃状态，对于锁保护的临界区较小的情况下，自旋获取锁和释放锁的成本都比较低，时间比较短。&lt;/p&gt;

&lt;h3 id=&#34;java中的自旋锁&#34;&gt;Java中的自旋锁&lt;/h3&gt;

&lt;p&gt;在JAVA中，我们可以使用原子变量和Unsafe类的CAS操作来实现自旋锁：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public class SpinLock {
  private AtomicReference&amp;lt;Thread&amp;gt; atomic = new AtomicReference&amp;lt;Thread&amp;gt;();
  
  public void lock() {
    Thread currentThread = Thread.currentThread();
    
    // 如果锁未被占用，则设置当前线程为锁的拥有者。
    while(!atomic.compareAndSet(null, currentThread)) {}
  }
  
  public void unlock() {
    Thread currentThread = Thread.currentThread();
    // 只有锁的拥有者能释放锁
    atomic.compareAndSet(currentThread, null);
  }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;缺点&#34;&gt;缺点&lt;/h4&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;CAS操作需要硬件的配合；&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;保证各个CPU的缓存（L1、L2、L3、跨CPU Socket、主存）的数据一致性，通讯开销很大，在多处理器系统上更严重；&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;没法保证公平性，不保证等待进程/线程按照FIFO顺序获得锁。&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;​&lt;/p&gt;

&lt;h3 id=&#34;linux中的自旋锁&#34;&gt;Linux中的自旋锁&lt;/h3&gt;

&lt;p&gt;自旋锁在Linux内核中广泛使用。在Linux操作系统中，自旋锁是一个互斥设备，它只有两个值&lt;code&gt;锁定&lt;/code&gt;和&lt;code&gt;解锁&lt;/code&gt;。&lt;/p&gt;

&lt;p&gt;由于操作系统和CPU直接打交道，自旋锁又可分为在单核处理器上和多核处理器上。&lt;/p&gt;

&lt;h4 id=&#34;单核处理器&#34;&gt;单核处理器&lt;/h4&gt;

&lt;p&gt;用在单核处理器上，有可分为两种：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;系统不支持内核抢占&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;此时自旋锁什么也不做，确实也不需要做什么，因为单核处理器只有一个线程在执行，又不支持内核抢占，因此资源不可能会被其他的线程访问到。&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;系统支持内核抢占&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;这种情况下，自旋锁加锁仅仅是禁止了内核抢占，解锁则是启用了内核抢占。&lt;/p&gt;

&lt;p&gt;在上述两种情况下，在获取自旋锁后可能会发生中断，若中断处理程序去访问自旋锁所保护的资源，则会发生死锁。因此，linux内核又提供了spin_lock_irq()和spin_lock_irqsave()，这两个函数会在获取自旋锁的同时（同时禁止内核抢占），禁止本地外部可屏蔽中断，从而保证自旋锁的原子操作。&lt;/p&gt;

&lt;h4 id=&#34;多核处理器&#34;&gt;多核处理器&lt;/h4&gt;

&lt;p&gt;多核处理器意味着有多个线程可以同时在不同的处理器上并行执行。&lt;/p&gt;

&lt;p&gt;举个例子：&lt;/p&gt;

&lt;p&gt;四核处理器，若A处理器上的线程1获取了锁,B、C两个处理器恰好这个时候也要访问这个锁保护的资源，因此他俩CPU就一直自旋忙等待。D并不需要这个资源，因此它可以正常处理其他事情。&lt;/p&gt;

&lt;p&gt;自旋锁的几个特点：&lt;/p&gt;

&lt;p&gt;1.被自旋锁保护的临界区代码执行时不能睡眠。单核处理器下，获取到锁的线程睡眠，若恰好此时CPU调度的另一个执行线程也需要获取这个锁，则会造成死锁；多核处理器下，若想获取锁的线程在同一个处理器下，同样会造成死锁，若位于另外的处理器，则会长时间占用CPU等待睡眠的线程释放锁，从而浪费CPU资源。&lt;/p&gt;

&lt;p&gt;2.被自旋锁保护的临界区代码执行时不能被其他中断打断。&lt;/p&gt;

&lt;p&gt;3.被自旋锁保护的临界区代码在执行时，内核不能被抢占。&lt;/p&gt;

&lt;h4 id=&#34;自旋锁函数&#34;&gt;自旋锁函数&lt;/h4&gt;

&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;// 最基本得自旋锁函数，它不失效本地中断。
void spin_lock(spinlock_t *lock);
// 在获得自旋锁之前禁用硬中断（只在本地处理器上），而先前的中断状态保存在flags中
void spin_lock_irqsave(spinlock_t *lock, unsigned long flags);
// 在获得自旋锁之前禁用硬中断（只在本地处理器上），不保存中断状态
void spin_lockirq(spinlock_t *lock);
// 在获得锁前禁用软中断，保持硬中断打开状态
void spin_lock_bh(spinlock_t *lock);
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;ticket锁&#34;&gt;TICKET锁&lt;/h2&gt;

&lt;p&gt;Ticket锁即排队自旋锁，Ticket锁是为了解决上面自旋锁的公平性问题，类似于现实中海底捞的排队叫号：锁拥有一个服务号，表示正在服务的线程，还有一个排队号；每个线程尝试获取锁之前先拿一个排队号，然后不断轮训锁的当前服务号是否是自己的排队号，如果是，则表示自己拥有了锁，不是则继续轮训。&lt;/p&gt;

&lt;p&gt;当前线程释放锁时，将服务号加1，这样下一个线程看到这个变化，就退出自旋，表示获取到锁。&lt;/p&gt;

&lt;h3 id=&#34;java中的自旋锁-1&#34;&gt;Java中的自旋锁&lt;/h3&gt;

&lt;p&gt;在JAVA中，我们可以使用原子变量和Unsafe类的CAS操作来实现Ticket自旋锁：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public class TicketLock {
   private AtomicInteger serviceNum = new AtomicInteger(); // 服务号
   private AtomicInteger ticketNum = new AtomicInteger(); // 排队号

   public int lock() {
         // 首先原子性地获得一个排队号
         int myTicketNum = ticketNum.getAndIncrement();

         // 只要当前服务号不是自己的就不断轮询
       	while (serviceNum.get() != myTicketNum) {}

       	return myTicketNum;
    }

    public void unlock(int myTicket) {
        // 只有当前线程拥有者才能释放锁
        int next = myTicket + 1;
        serviceNum.compareAndSet(myTicket, next);
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;缺点-1&#34;&gt;缺点&lt;/h4&gt;

&lt;p&gt;Ticket Lock 虽然解决了公平性的问题，但是多处理器系统上，每个进程/线程占用的处理器都在读写同一个变量&lt;code&gt;serviceNum&lt;/code&gt; ，每次读写操作都必须在多个处理器缓存之间进行缓存同步，这会导致繁重的系统总线和内存的流量，大大降低系统整体的性能。&lt;/p&gt;

&lt;h3 id=&#34;linux中的排队自旋锁&#34;&gt;Linux中的排队自旋锁&lt;/h3&gt;

&lt;p&gt;排队自旋锁(FIFO Ticket Spinlock)是Linux内核2.6.25版本引入的一种新型自旋锁，它解决了传统自旋锁由于无序竞争导致的&amp;rdquo;公平性&amp;rdquo;问题。但是由于排队自旋锁在一个共享变量上“自旋”，因此在锁竞争激烈的多核或 NUMA 系统上导致性能低下。&lt;/p&gt;

&lt;h2 id=&#34;mcs锁&#34;&gt;MCS锁&lt;/h2&gt;

&lt;p&gt;MCS自旋锁是一种基于链表的高性能、可扩展的自旋锁。申请线程之在本地变量上自旋，直接前驱负责通知其结束自旋，从而极大地减少了不必要的处理器缓存同步的次数，降低了总线和内存的开销。&lt;/p&gt;

&lt;p&gt;MCS锁的设计目标如下：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;保证自旋锁申请者以先进先出的顺序获取锁（FIFO Ordering）。&lt;/li&gt;
&lt;li&gt;只在本地可访问的标志变量上自旋。&lt;/li&gt;
&lt;li&gt;在处理器个数较少的系统中或锁竞争并不激烈的情况下，保持较高性能。&lt;/li&gt;
&lt;li&gt;自旋锁的空间复杂度（即锁数据结构和锁操作所需的空间开销）为常数。&lt;/li&gt;
&lt;li&gt;在没有处理器缓存一致性协议保证的系统中也能很好地工作。&lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&#34;java中的mcs锁&#34;&gt;Java中的MCS锁&lt;/h3&gt;

&lt;p&gt;在JAVA中，我们可以使用原子变量和Unsafe类的CAS操作来实现MCS自旋锁：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public class MCSLock {
    public static class MCSNode {
        volatile MCSNode next;
        volatile boolean isBlock = true; // 本地自旋变量，默认是在等待锁
    }

    volatile MCSNode queue;// 指向最后一个申请锁的MCSNode
    private static final AtomicReferenceFieldUpdater UPDATER = 
      AtomicReferenceFieldUpdater.newUpdater(MCSLock.class, MCSNode.class, &amp;quot;queue&amp;quot;);

    public void lock(MCSNode currentThread) {
        MCSNode predecessor = UPDATER.getAndSet(this, currentThread);// step 1
        if (predecessor != null) {
            predecessor.next = currentThread;// step 2

            while (currentThread.isBlock) {// step 3
            }
        }else { // 只有一个线程在使用锁，没有前驱来通知它，所以得自己标记自己为非阻塞
            currentThread.isBlock = false;
        }
    }

    public void unlock(MCSNode currentThread) {
        if (currentThread.isBlock) {// 锁拥有者进行释放锁才有意义
            return;
        }

        if (currentThread.next == null) {// 检查是否有人排在自己后面
            if (UPDATER.compareAndSet(this, currentThread, null)) {// step 4
                // compareAndSet返回true表示确实没有人排在自己后面
                return;
            } else {
                // 突然有人排在自己后面了，可能还不知道是谁，下面是等待后续者
                // 这里之所以要忙等是因为：step 1执行完后，step 2可能还没执行完
                while (currentThread.next == null) { // step 5
                }
            }
        }

        currentThread.next.isBlock = false;
        currentThread.next = null;// for GC
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;linux中的mcs锁&#34;&gt;Linux中的MCS锁&lt;/h3&gt;

&lt;p&gt;目前 Linux 内核尚未使用 MCS Spinlock。根据上节的算法描述，我们可以很容易地实现 MCS Spinlock。本文的实现针对x86 体系结构(包括 IA32 和 x86_64)。原子交换、比较-交换操作可以使用带 LOCK 前缀的 xchg(q)，cmpxchg(q)[3] 指令实现。&lt;/p&gt;

&lt;h2 id=&#34;clh锁&#34;&gt;CLH锁&lt;/h2&gt;

&lt;p&gt;CLH（Craig, Landin, and Hagersten）锁也是基于链表的可扩展、高性能、公平的自旋锁，申请线程旨在本地变量上自旋，它不断轮训前驱的状态，如果发现前驱释放了锁就结束自旋。&lt;/p&gt;

&lt;h3 id=&#34;java中的clh锁&#34;&gt;Java中的CLH锁&lt;/h3&gt;

&lt;p&gt;在Java中CLH的应用非常广泛，比如JUC包下的锁框架AbstractQueuedSynchronized就是基于CLH实现的，并进而实现了整个Lock框架体系。&lt;/p&gt;

&lt;p&gt;在JAVA中，我们可以使用原子变量和Unsafe类的CAS操作来实现CLH自旋锁：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public class CLHLock {
    public static class CLHNode {
        private volatile boolean isLocked = true; // 默认是在等待锁
    }

    @SuppressWarnings(&amp;quot;unused&amp;quot; )
    private volatile CLHNode tail ;
    private static final AtomicReferenceFieldUpdater&amp;lt;CLHLock, CLHNode&amp;gt; UPDATER = AtomicReferenceFieldUpdater
                  . newUpdater(CLHLock.class, CLHNode .class , &amp;quot;tail&amp;quot; );

    public void lock(CLHNode currentThread) {
        CLHNode preNode = UPDATER.getAndSet( this, currentThread);
        if(preNode != null) {//已有线程占用了锁，进入自旋
            while(preNode.isLocked ) {
            }
        }
    }

    public void unlock(CLHNode currentThread) {
        // 如果队列里只有当前线程，则释放对当前线程的引用（for GC）。
        if (!UPDATER .compareAndSet(this, currentThread, null)) {
            // 还有后续线程
            currentThread. isLocked = false ;// 改变状态，让后续线程结束自旋
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;clh锁与mcs锁的比较&#34;&gt;CLH锁与MCS锁的比较&lt;/h2&gt;

&lt;p&gt;下图是经典的CLH锁和MCS锁队列图示：&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://coderbee.net/wp-content/uploads/2013/11/CLH-MCS-SpinLock.png&#34; alt=&#34;CLH和MCS&#34; /&gt;&lt;/p&gt;

&lt;p&gt;差异：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;从代码实现来看，CLH比MCS要简单得多。&lt;/li&gt;
&lt;li&gt;从自旋的条件来看，CLH是在前驱节点的属性上自旋，而MCS是在本地属性变量上自旋。&lt;/li&gt;
&lt;li&gt;从链表队列来看，CLH的队列是隐式的，CLHNode并不实际持有下一个节点；MCS的队列是物理存在的。&lt;/li&gt;
&lt;li&gt;CLH锁释放时只需要改变自己的属性，MCS锁释放则需要改变后继节点的属性。&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;&lt;strong&gt;注意：这里实现的锁都是独占的，且不能重入的。&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;参考：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;a href=&#34;https://www.ibm.com/developerworks/cn/linux/l-cn-mcsspinlock/&#34;&gt;高性能自旋锁 MCS Spinlock 的设计与实现&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://www.cnblogs.com/hdflzh/p/3716156.html&#34;&gt;高效编程之互斥锁和自旋锁的一些知识&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://my.oschina.net/MinGKai/blog/188522&#34;&gt;基于队列的锁:mcs lock简介&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://blog.csdn.net/vividonly/article/details/6594195&#34;&gt;深入理解linux内核自旋锁&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;
</description>
    </item>
    
    <item>
      <title>Java锁之Lock框架概述</title>
      <link>http://nituchao.com/post/juc.lock/lock-summary/</link>
      <pubDate>Thu, 23 Feb 2017 18:28:27 +0800</pubDate>
      
      <guid>http://nituchao.com/post/juc.lock/lock-summary/</guid>
      <description>

&lt;p&gt;在Java中关于锁有两个体系，一个是synchronized代表的对象监视器同步锁，一个是以AQS为基础的锁框架，该框架位于java.uti.concurrent包下。&lt;/p&gt;

&lt;p&gt;本文基于JDK1.7.0_67&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;java version &amp;ldquo;1.7.0&lt;em&gt;67&amp;rdquo;&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;_Java&amp;trade; SE Runtime Environment (build 1.7.0_67-b01)&lt;/p&gt;

&lt;p&gt;Java HotSpot&amp;trade; 64-Bit Server VM (build 24.65-b04, mixed mode)&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&#34;aqs框架原理-aqs框架图-file-users-liang-library-group-20containers-ubf8t346g9-office-msoclip1-01-65cceb69-4317-8645-9279-f8aa33dad044-png&#34;&gt;AQS框架原理&lt;img src=&#34;file:////Users/liang/Library/Group%20Containers/UBF8T346G9.Office/msoclip1/01/65CCEB69-4317-8645-9279-F8AA33DAD044.png&#34; alt=&#34;AQS框架图&#34; /&gt;&lt;/h2&gt;

&lt;h2 id=&#34;juc包中的锁&#34;&gt;JUC包中的锁&lt;/h2&gt;

&lt;p&gt;相比同步锁，JUC包中的锁的功能更加强大，它为锁提供了一个框架，该框架允许更灵活地使用锁，只是它的用法更难罢了。&lt;/p&gt;

&lt;p&gt;JUC包中的锁，包括：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Lock接口&lt;/li&gt;
&lt;li&gt;ReadWriteLock接口&lt;/li&gt;
&lt;li&gt;Condition接口&lt;/li&gt;
&lt;li&gt;ReentrantLock独占锁&lt;/li&gt;
&lt;li&gt;ReentrantReadWriteLock读写锁&lt;/li&gt;
&lt;li&gt;CountDownLatch&lt;/li&gt;
&lt;li&gt;CyclicBarrier&lt;/li&gt;
&lt;li&gt;Semaphore&lt;/li&gt;
&lt;li&gt;AbstractOwnableSynchronizer抽象类&lt;/li&gt;
&lt;li&gt;AbstractQueuedSynchronizer抽象类&lt;/li&gt;
&lt;li&gt;AbstractQueuedLongSynchronizer抽象类&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>AtomicLongFieldUpdater源码分析</title>
      <link>http://nituchao.com/post/juc.atomic/atomic-long-field-updater/</link>
      <pubDate>Thu, 23 Feb 2017 18:27:27 +0800</pubDate>
      
      <guid>http://nituchao.com/post/juc.atomic/atomic-long-field-updater/</guid>
      <description>

&lt;h2 id=&#34;概述&#34;&gt;概述&lt;/h2&gt;

&lt;p&gt;在原子变量相关类中，AtomicIntegerFieldUpdater, AtomicLongFieldUpdater, AtomicReferenceFieldUpdater三个类是用于原子地修改对象的成员属性，它们的原理和用法类似，区别在于对Integer，Long，Reference类型的成员属性进行修改。本文重点研究AtomicLongFieldUpdater。&lt;/p&gt;

&lt;p&gt;AtomicLongFieldUpdater的设计非常有意思。AtomicLongFieldUpdater本身是一个抽象类，只有一个受保护的构造函数，它本身不能被实例化。&lt;/p&gt;

&lt;p&gt;AtomicLongFieldUpdater有两个私有的静态内部类&lt;code&gt;CASUpdater&lt;/code&gt;和&lt;code&gt;LockedUpdater&lt;/code&gt;，它们都是&lt;code&gt;AtomicLongFieldUpdater&lt;/code&gt;的子类。&lt;/p&gt;

&lt;p&gt;用户使用&lt;code&gt;AtomicLongFieldUpdater&lt;/code&gt;公共静态方法&lt;code&gt;newUpdater&lt;/code&gt;实例化&lt;code&gt;AtomicLongFieldUpdater&lt;/code&gt;的对象，本质是上是根据条件实例化了子类&lt;code&gt;CASUpdater&lt;/code&gt;或者&lt;code&gt;LockedUpdater&lt;/code&gt;，然后通过子类来完成具体的工作。&lt;code&gt;CASUpdater&lt;/code&gt;和&lt;code&gt;LockedUpdater&lt;/code&gt;值的读取和更新最后都是使用&lt;code&gt;sun.misc.Unsafe&lt;/code&gt;类的相关操作。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;CASUpdater&lt;/code&gt;使用下面的方法：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public native Object getLongVolatile(Object o, long offset);
public native void   putLongVolatile(Object o, long offset, long x);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;LockedUpdater使用下面的方法：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public native long    getLong(Object o, long offset);
public native void    putLong(Object o, long offset, long x);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;为了防止操作过程中的指令重排，LockedUpdater使用synchronized进行同步。&lt;/p&gt;

&lt;p&gt;本文基于JDK1.7.0_67&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;java version &amp;ldquo;1.7.0_67&amp;rdquo;&lt;/p&gt;

&lt;p&gt;_Java™ SE Runtime Environment (build 1.7.0_67-b01)&lt;/p&gt;

&lt;p&gt;Java HotSpot™ 64-Bit Server VM (build 24.65-b04, mixed mode)&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&#34;内部类&#34;&gt;内部类&lt;/h2&gt;

&lt;p&gt;&lt;code&gt;AtomicLongFieldUpdater&lt;/code&gt;本身是抽象类，通过两个私有的静态内部子类来完成具体的工作。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;CASUpdater&lt;/code&gt;：顾名思义，使用CAS操作对象的成员变量。&lt;/li&gt;
&lt;li&gt;LockedUpdater：顾名思义，在更新和读取对象的成员变量时，使用对象锁来保证同步。&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;成员变量&#34;&gt;成员变量&lt;/h2&gt;

&lt;p&gt;&lt;code&gt;AtomicLongFieldUpdater&lt;/code&gt;是个抽象类，具体的业务逻辑都是交给它的子类实现的，它本身没有包含任何成员变量。&lt;/p&gt;

&lt;h2 id=&#34;函数列表&#34;&gt;函数列表&lt;/h2&gt;

&lt;p&gt;&lt;code&gt;AtomicLongFieldUpdater&lt;/code&gt;采用模板方法，它本身定义了一些操作过程，而其中使用的具体的方法则由各个子类实现。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;// 受保护的无操作构造函数，供子类使用
protected AtomicLongFieldUpdater()
// 为对象创建并返回一个具有给定字段的更新器。
public static &amp;lt;U&amp;gt; AtomicLongFieldUpdater&amp;lt;U&amp;gt; newUpdater(Class&amp;lt;U&amp;gt; tclass, String fieldName)
// 以原子方式设置当前值为update。
// 如果当前值等于expect，并设置成功，返回true
// 如果当前值不等于expect，则设置失败，返回false
// CASUpdater的实现该不阻塞
// LockedUpdater的实现通过synchronized进行同步，会阻塞
public abstract boolean compareAndSet(T obj, long expect, long update)
// 以原子方式设置当前值为update。
// 如果当前值等于expect，并设置成功，返回true
// 如果当前值不等于expect，则设置失败，返回false
// CASUpdater的实现该不阻塞
// LockedUpdater的实现通过synchronized进行同步，会阻塞
// 该过程不保证volatile成员的happens-before语义顺序
public abstract boolean weakCompareAndSet(T obj, long expect, long update)
// 以原子方式设置当前值为newValue
// CASUpdater的实现使用Unsafe类的putLongVolatile进行操作，具有原子性
// LockedUpdater的实现使用synchronizde和Unsafe类的putLong进行操作，具有原子性
public abstract void set(T obj, long newValue)
// 以原子方式设置当前值为newValue
// CASUpdater的实现使用Unsafe类的putOrderedLong进行操作，所以本身具有原子性
// LockedUpdater的实现使用synchronizde和Unsafe类的putLong进行操作，具有原子性
// 优先保证对值的修改，而不保证可见性
public abstract void lazySet(T obj, long newValue)
// 以原子方式获取当前值
// CASUpdater的实现使用Unsafe类的getLongVolatile进行操作，所以本身具有原子性
// LockedUpdater的实现使用synchronizde和Unsafe类的getLong进行操作，具有原子性
public abstract long get(T obj)
// 以原子方式设置当前值为newValue，并返回更新前的值
// CASUpdater的实现使用Unsafe类的compareAndSwapLong进行操作，所以本身具有原子性
// LockedUpdater的实现使用synchronizde和Unsafe类的putLong进行操作，具有原子性
// 操作过程中使用自旋方式，直到操作成功
public long getAndSet(T obj, long newValue)
// 以原子方式将当前值加1，并返回更新前的值
// CASUpdater的实现使用Unsafe类的compareAndSwapLong进行操作，所以本身具有原子性
// LockedUpdater的实现使用synchronizde和Unsafe类的putLong进行操作，具有原子性
// 操作过程中使用自旋方式，直到操作成功
public long getAndIncrement(T obj)
// 以原子方式将当前值减1，并返回更新前的值
// CASUpdater的实现使用Unsafe类的compareAndSwapLong进行操作，所以本身具有原子性
// LockedUpdater的实现使用synchronizde和Unsafe类的putLong进行操作，具有原子性
// 操作过程中使用自旋方式，直到操作成功
public long getAndDecrement(T obj)
// 以原子方式将当前值加上给定值delta，并返回更新前的值
// CASUpdater的实现使用Unsafe类的compareAndSwapLong进行操作，所以本身具有原子性
// LockedUpdater的实现使用synchronizde和Unsafe类的putLong进行操作，具有原子性
// 操作过程中使用自旋方式，直到操作成功
public long getAndAdd(T obj, long delta)
// 以原子方式将当前值加1，并返回更新后的值
// CASUpdater的实现使用Unsafe类的compareAndSwapLong进行操作，所以本身具有原子性
// LockedUpdater的实现使用synchronizde和Unsafe类的putLong进行操作，具有原子性
// 操作过程中使用自旋方式，直到操作成功
public long incrementAndGet(T obj)
// 以原子方式将当前值减1，并返回更新前的值
// CASUpdater的实现使用Unsafe类的compareAndSwapLong进行操作，所以本身具有原子性
// LockedUpdater的实现使用synchronizde和Unsafe类的putLong进行操作，具有原子性
// 操作过程中使用自旋方式，直到操作成功
public long decrementAndGet(T obj)
// 以原子方式将当前值加上给定值delta，并返回更新后的值
// CASUpdater的实现使用Unsafe类的compareAndSwapLong进行操作，所以本身具有原子性
// LockedUpdater的实现使用synchronizde和Unsafe类的putLong进行操作，具有原子性
// 操作过程中使用自旋方式，直到操作成功
public long addAndGet(T obj, long delta)
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;重点函数分析&#34;&gt;重点函数分析&lt;/h2&gt;

&lt;h3 id=&#34;newupdater&#34;&gt;newUpdater&lt;/h3&gt;

&lt;p&gt;为对象创建并返回一个具有给定字段的更新器实例。由于要操作long型数据，因此要根据虚拟机是否支持原子化更新long来创建对于的子类。当虚拟机支持原子化更新long时，创建CASUpdater实例。否则，创LockedUpdater实例，32位虚拟机不支持对long的原子化更新，因此，只能使用对象锁来保证原子操作。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public static &amp;lt;U&amp;gt; AtomicLongFieldUpdater&amp;lt;U&amp;gt; newUpdater(Class&amp;lt;U&amp;gt; tclass, String fieldName) {
    Class&amp;lt;?&amp;gt; caller = Reflection.getCallerClass();
    if (AtomicLong.VM_SUPPORTS_LONG_CAS)
      	return new CASUpdater&amp;lt;U&amp;gt;(tclass, fieldName, caller);
    else
      	return new LockedUpdater&amp;lt;U&amp;gt;(tclass, fieldName, caller);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;atomiclongfieldupdater&#34;&gt;AtomicLongFieldUpdater&lt;/h3&gt;

&lt;p&gt;受保护的无操作构造函数，供子类实现。无论是&lt;code&gt;CASUpdater&lt;/code&gt;还是&lt;code&gt;LockedUpdater&lt;/code&gt;，都包含了下面四个成员变量，它们构造函数的实现也是一样的，我们只分析其中CASUpdater的实现。&lt;/p&gt;

&lt;p&gt;在构造函数中，首先获取要更新的类的指定成员变量fieldName的访问策略(Modifier: public, private, default, protected)，然后检查调用类(caller)是否有权限访问该成员变量fieldName，如果没有权限则抛出异常。接下来，判断指定的成员变量fieldName的类型是否是long，如果不是，也抛出异常。接下来，判断当前指定的成员变量是否是volatile类型的，如果不是，也抛出异常。接下来，实例化调用者类cclass，和操作目标类tclass。最后，计算指定成员变量fieldName的内存偏移值。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;// 成员变量unsafe是原子变量相关操作的基础
// 原子变量的修改操作最终有sun.misc.Unsafe类的CAS操作实现
private static final Unsafe unsafe = Unsafe.getUnsafe();
// 成员变量fieldName的内存偏移值，在构造函数中初始化
private final long offset;
// 操作目标类，对该类中的fieldName字段进行更新
private final Class&amp;lt;T&amp;gt; tclass;
// 调用者类，通过反射获取
private final Class cclass;

CASUpdater(Class&amp;lt;T&amp;gt; tclass, String fieldName, Class&amp;lt;?&amp;gt; caller) {
    Field field = null;
    int modifiers = 0;
    try {
      	// 获取要更新的类的指定成员变量fieldName的访问策略
        field = tclass.getDeclaredField(fieldName);
        modifiers = field.getModifiers();
      	// 验证访问策略
        sun.reflect.misc.ReflectUtil.ensureMemberAccess(
          	caller, tclass, null, modifiers);
        sun.reflect.misc.ReflectUtil.checkPackageAccess(tclass);
    } catch (Exception ex) {
      	throw new RuntimeException(ex);
    }

  	// 当前成员变量的类型必须是long
    Class fieldt = field.getType();
    if (fieldt != long.class)
      	throw new IllegalArgumentException(&amp;quot;Must be long type&amp;quot;);

  	// 当前成员变量必须是volatile修饰
    if (!Modifier.isVolatile(modifiers))
      	throw new IllegalArgumentException(&amp;quot;Must be volatile type&amp;quot;);

  	// 设置调用者类
    this.cclass = (Modifier.isProtected(modifiers) &amp;amp;&amp;amp;
                   caller != tclass) ? caller : null;
  	// 设置操作目标类
    this.tclass = tclass;
  	// 设置成员变量的内存偏移值
    offset = unsafe.objectFieldOffset(field);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;weakcompareandset&#34;&gt;weakCompareAndSet&lt;/h3&gt;

&lt;p&gt;以原子方式设置当前值为update。如果当前值等于expect，并设置成功，返回true。如果当前值不等于expect，则设置失败，返回false。&lt;/p&gt;

&lt;p&gt;weakCompareAndSet是通过调用compareAndSet实现的，但是，在JDK文档中声明，weakCompareAndSet不保证volatile的happens-before内存顺序性语义，这是它们的区别。&lt;/p&gt;

&lt;p&gt;在&lt;code&gt;AtomicLongFieldUpdater&lt;/code&gt;类中，这是一个抽象方法。&lt;code&gt;CASUpdater&lt;/code&gt;和&lt;code&gt;LockedUpdater&lt;/code&gt;有各自的实现。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public abstract boolean weakCompareAndSet(T obj, long expect, long update);
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;compareandset&#34;&gt;compareAndSet&lt;/h3&gt;

&lt;p&gt;以原子方式设置当前值为update。如果当前值等于expect，并设置成功，返回true。如果当前值不等于expect，则设置失败，返回false。&lt;/p&gt;

&lt;p&gt;在&lt;code&gt;AtomicLongFieldUpdater&lt;/code&gt;类中，这是一个抽象方法。&lt;code&gt;CASUpdater&lt;/code&gt;和&lt;code&gt;LockedUpdater&lt;/code&gt;有各自的实现。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public abstract boolean compareAndSet(T obj, long expect, long update);
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;casupdater的实现&#34;&gt;CASUpdater的实现&lt;/h4&gt;

&lt;p&gt;当JVM支持long的原子更新时，CASUpdater选择用Unsafe类的&lt;code&gt;compareAndSwapLong&lt;/code&gt;方法来直接原子地比较期望值并更新当前值。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public boolean compareAndSet(T obj, long expect, long update) {
    if (obj == null || obj.getClass() != tclass || cclass != null) fullCheck(obj);
    	return unsafe.compareAndSwapLong(obj, offset, expect, update);
}

// 类型检查&amp;amp;访问检查
private void fullCheck(T obj) {
	if (!tclass.isInstance(obj))
    	throw new ClassCastException();
  	if (cclass != null)
    	ensureProtectedAccess(obj);
}

// 访问检查
private void ensureProtectedAccess(T obj) {
    if (cclass.isInstance(obj)) {
      	return;
    }
    throw new RuntimeException(
      	new IllegalAccessException(&amp;quot;Class &amp;quot; +
            cclass.getName() +
            &amp;quot; can not access a protected member of class &amp;quot; +
            tclass.getName() +
            &amp;quot; using an instance of &amp;quot; +
            obj.getClass().getName()
            )
    );
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;lockedupdater的实现&#34;&gt;LockedUpdater的实现&lt;/h4&gt;

&lt;p&gt;当JVM不支持long的原子更新时，LockedUpdater选择用synchronized对象锁来同步更新操作，其中涉及到当前值是否等于预期值expect，如果相等，则更新，并返回true，否则，不更新，返回false。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public boolean compareAndSet(T obj, long expect, long update) {
	if (obj == null || obj.getClass() != tclass || cclass != null) fullCheck(obj);
    synchronized (this) {
        long v = unsafe.getLong(obj, offset);
        if (v != expect)
            return false;
        unsafe.putLong(obj, offset, update);
        return true;
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;get&#34;&gt;get&lt;/h3&gt;

&lt;p&gt;以原子方式获取当前值。&lt;/p&gt;

&lt;p&gt;在&lt;code&gt;AtomicLongFieldUpdater&lt;/code&gt;类中，这是一个抽象方法。&lt;code&gt;CASUpdater&lt;/code&gt;和&lt;code&gt;LockedUpdater&lt;/code&gt;有各自的实现。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public long get(T obj);
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;casupdater的实现-1&#34;&gt;CASUpdater的实现&lt;/h4&gt;

&lt;p&gt;当JVM支持long的原子更新时，CASUpdater选择用Unsafe类的getLongVolatile方法来直接原子地获取当前值。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public long get(T obj) {
    if (obj == null || obj.getClass() != tclass || cclass != null) fullCheck(obj);
    return unsafe.getLongVolatile(obj, offset);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;lockedupdater的实现-1&#34;&gt;LockedUpdater的实现&lt;/h4&gt;

&lt;p&gt;当JVM不支持long的原子更新时，LockedUpdater选择用synchronized对象锁来同步更新操作。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public long get(T obj) {
    if (obj == null || obj.getClass() != tclass || cclass != null) fullCheck(obj);
    synchronized (this) {
        return unsafe.getLong(obj, offset);
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;set&#34;&gt;set&lt;/h3&gt;

&lt;p&gt;以原子方式设置当前值为newValue。&lt;/p&gt;

&lt;p&gt;在&lt;code&gt;AtomicLongFieldUpdater&lt;/code&gt;类中，这是一个抽象方法。&lt;code&gt;CASUpdater&lt;/code&gt;和&lt;code&gt;LockedUpdater&lt;/code&gt;有各自的实现。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public abstract void set(T obj, long newValue);
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;casupdater的实现-2&#34;&gt;CASUpdater的实现&lt;/h4&gt;

&lt;p&gt;当JVM支持long的原子更新时，CASUpdater选择用Unsafe类的putLongVolatile方法来直接原子地更新当前值。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public void set(T obj, long newValue) {
	if (obj == null || obj.getClass() != tclass || cclass != null) fullCheck(obj);
    unsafe.putLongVolatile(obj, offset, newValue);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;lockedupdater的实现-2&#34;&gt;LockedUpdater的实现&lt;/h4&gt;

&lt;p&gt;当JVM不支持long的原子更新时，LockedUpdater选择用synchronized对象锁来同步更新操作。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public void set(T obj, long newValue) {
	if (obj == null || obj.getClass() != tclass || cclass != null) fullCheck(obj);
    synchronized (this) {
	    unsafe.putLong(obj, offset, newValue);
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;lazyset&#34;&gt;lazySet&lt;/h3&gt;

&lt;p&gt;以原子方式设置当前值为newValue。与set方法不同之处在于，lazySet优先保证更新数据，而不保证可见性。因此，更新效率高于set。但是，这种保证只是JDK的设计声明，在子类的实现中，要具体情况具体分析。比如LockedUpdater的lazySet就是调用set方法实现的，本质上一样。&lt;/p&gt;

&lt;p&gt;在&lt;code&gt;AtomicLongFieldUpdater&lt;/code&gt;类中，这是一个抽象方法。&lt;code&gt;CASUpdater&lt;/code&gt;和&lt;code&gt;LockedUpdater&lt;/code&gt;有各自的实现。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public abstract void lazySet(T obj, long newValue);
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;casupdater的实现-3&#34;&gt;CASUpdater的实现&lt;/h4&gt;

&lt;p&gt;当JVM支持long的原子更新时，CASUpdater选择用Unsafe类的putOrderedLong方法来直接原子地更新当前值。并且，该方法优先保证更新数据，而不保证可见性。效率比putLong高3倍。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public void lazySet(T obj, long newValue) {
	if (obj == null || obj.getClass() != tclass || cclass != null) fullCheck(obj);
	unsafe.putOrderedLong(obj, offset, newValue);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;lockedupdater的实现-3&#34;&gt;LockedUpdater的实现&lt;/h4&gt;

&lt;p&gt;当JVM不支持long的原子更新时，LockedUpdater选择调用set方法进行更新，set方法则使用synchronized对象锁来同步更新操作。在LockedUpdater中set方法和lazySet方法没有区别。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public void lazySet(T obj, long newValue) {
	set(obj, newValue);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;getandset&#34;&gt;getAndSet&lt;/h3&gt;

&lt;p&gt;以原子方式设置当前值为newValue，并返回更新前的值。&lt;/p&gt;

&lt;p&gt;这是一个模板方法，通过在自旋循环中反复调用compareAndSet方法进行操作，而compareAndSet则在不同的子类中有不同的实现。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public long getAndSet(T obj, long newValue) {
  for (;;) {
    long current = get(obj);
    if (compareAndSet(obj, current, newValue))
    	return current;
  }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;类似的方法还有：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public long getAndIncrement(T obj)
public long getAndDecrement(T obj)
public long getAndAdd(T obj, long delta)
public long incrementAndGet(T obj)
public long decrementAndGet(T obj)
public long addAndGet(T obj, long delta)
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>ConcurrentHashMap源码分析</title>
      <link>http://nituchao.com/post/juc.concurrent/concurrent-hasmap/</link>
      <pubDate>Thu, 23 Feb 2017 18:27:27 +0800</pubDate>
      
      <guid>http://nituchao.com/post/juc.concurrent/concurrent-hasmap/</guid>
      <description>

&lt;h2 id=&#34;一言&#34;&gt;一言&lt;/h2&gt;

&lt;p&gt;ConcurrentHashMap是线程安全的、高效的哈希表。默认支持16个并发级别，并发级别在初始化后不能扩展。&lt;/p&gt;

&lt;h2 id=&#34;概述&#34;&gt;概述&lt;/h2&gt;

&lt;p&gt;&lt;strong&gt;HashMap&lt;/strong&gt;是非线程安全的哈希表，常用于单线程程序中。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Hashtable&lt;/strong&gt;是线程安全的哈希表，它是通过synchronized来保证线程安全的；多线程通过同一个“对象的同步锁”来实现并发控制。Hashtable在线程竞争激烈时，效率比较低(此时建议使用ConcurrentHashMap)！因为当一个线程访问Hashtable的同步方法时，其它线程就访问Hashtable的同步方法时，可能会进入阻塞状态。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;ConcurrentHashMap&lt;/strong&gt;是线程安全的哈希表，它是通过“锁分段”来保证线程安全的。ConcurrentHashMap将哈希表分成许多片段(Segment)，每一个片段除了保存哈希表之外，本质上也是一个“可重入的互斥锁”(ReentrantLock)。多线程对同一个片段的访问，是互斥的；但是，对于不同片段的访问，却是可以同步进行的。&lt;/p&gt;

&lt;p&gt;本文基于JDK1.7.0_67&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;java version &amp;ldquo;1.7.0&lt;em&gt;67&amp;rdquo;&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;_Java&amp;trade; SE Runtime Environment (build 1.7.0_67-b01)&lt;/p&gt;

&lt;p&gt;Java HotSpot&amp;trade; 64-Bit Server VM (build 24.65-b04, mixed mode)&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&#34;concurrenthashmap数据结构&#34;&gt;ConcurrentHashMap数据结构&lt;/h2&gt;

&lt;p&gt;要想搞清ConcurrentHashMap，必须先弄清楚它的数据结构：&lt;/p&gt;

&lt;p&gt;&lt;code&gt;图&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;说明:&lt;/strong&gt;&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;ConcurrentHashMap继承于AbstractMap抽象类。&lt;/li&gt;
&lt;li&gt;Setment是ConcurrentHashMap的内部类，它就是ConcurrentHashMap中的&amp;rdquo;锁分段&amp;rdquo;对应的数据结构。ConcurrentHashMap与Segment是组合关系，1个ConcurrentHashMap对象包含若干个Segment对象。在代码中，这表现为ConcurrentHashMap类中存在&amp;rdquo;Segment数组&amp;rdquo;成员。&lt;/li&gt;
&lt;li&gt;Segment类继承于ReentrantLock类，所以Segment本质上是一个可重入的互斥锁。&lt;/li&gt;
&lt;li&gt;HashEntry也是ConcurrentHashMap的内部类，是单向链表节点，存储着key-value键值对。Segment与HashEntry是组合关系，Segment类中存在“HashEntry数组”成员，“HashEntry数组”中的每个HashEntry就是一个单向链表。&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;对于多线程访问对一个“哈希表对象”竞争资源，Hashtable是通过一把锁来控制并发；而ConcurrentHashMap则是将哈希表分成许多片段，对于每一个片段分别通过一个互斥锁来控制并发。ConcurrentHashMap对并发的控制更加细腻，它也更加适应于高并发场景！&lt;/p&gt;

&lt;h2 id=&#34;concurrenthashmap常量定义&#34;&gt;ConcurrentHashMap常量定义&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;// 默认初始容量(HashEntry的个数)
static final int DEFAULT_INITIAL_CAPACITY = 16;
// 默认负载因子
static final float DEFAULT_LOAD_FACTOR = 0.75f;
// 默认并发级别
static final int DEFAULT_CONCURRENCY_LEVEL = 16;
// 最大容量(HashEntry的个数)
static final int MAXIMUM_CAPACITY = 1 &amp;lt;&amp;lt; 30;
// 每个段(Segment)中HashEntry数组(table)的最小容量
// 设置最小为2，是为了防止构造完成后立即resize
static final int MIN_SEGMENT_TABLE_CAPACITY = 2;
// 段的最大个数
static final int MAX_SEGMENTS = 1 &amp;lt;&amp;lt; 16; // slightly conservative
// 在计算size时，先尝试不获取段锁计算，最多尝试RETRIES_BEFORE_LOCK次。
// 如果重试超过RETRIES_BEFORE_LOCK次，则获取段锁后进行计算。
static final int RETRIES_BEFORE_LOCK = 2;
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;concurrenthashmap成员变量&#34;&gt;ConcurrentHashMap成员变量&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;// 制造一个随机值，使得在计算key的hash值时不容易出现冲突。
// 该值通过sun.misc.Hashing.randomHashSeed(instance)生成。
private transient final int hashSeed = randomHashSeed(this);
// 段segment的掩码，用于计算key所在segments索引值。
final int segmentMask;
// 段segment的偏移，用于计算key所在segments索引值。
final int segmentShift;
// 段segment数组，其内部是由HashEntry数组实现。
final Segment&amp;lt;K,V&amp;gt;[] segments;
// 键集合，键不能重复
transient Set&amp;lt;K&amp;gt; keySet;
// 值集合，值可以重复
transient Collection&amp;lt;V&amp;gt; values;
// 元素HashEntry集合
transient Set&amp;lt;Map.Entry&amp;lt;K,V&amp;gt;&amp;gt; entrySet;
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;concurrenthashmap内部类&#34;&gt;ConcurrentHashMap内部类&lt;/h2&gt;

&lt;h3 id=&#34;holder&#34;&gt;Holder&lt;/h3&gt;

&lt;p&gt;静态内部类，存放一些在虚拟机启动后才能初始化的值。&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;容量阈值，初始化hashSeed的时候会用到该值。&lt;/li&gt;
&lt;/ol&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;static final boolean ALTERNATIVE_HASHING;
&lt;/code&gt;&lt;/pre&gt;

&lt;ol&gt;
&lt;li&gt;static静态块&lt;/li&gt;
&lt;/ol&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;static {
  // 获取系统变量jdk.map.althashing.threshold
  // 通过系统变量jdk.map.althashing.threshold来初始化threshold
  String altThreshold = java.security.AccessController.doPrivileged(
    new sun.security.action.GetPropertyAction(
      &amp;quot;jdk.map.althashing.threshold&amp;quot;));

  int threshold;
  try {
    threshold = (null != altThreshold)
      ? Integer.parseInt(altThreshold)
      : Integer.MAX_VALUE;

    // disable alternative hashing if -1
    if (threshold == -1) {
      threshold = Integer.MAX_VALUE;
    }

    if (threshold &amp;lt; 0) {
      throw new IllegalArgumentException(&amp;quot;value must be positive integer.&amp;quot;);
    }
  } catch(IllegalArgumentException failed) {
    throw new Error(&amp;quot;Illegal value for &#39;jdk.map.althashing.threshold&#39;&amp;quot;, failed);
  }
  // 根据系统变量jdk.map.althashing.threshold来初始化ALTERNATIVE_HASHING
  ALTERNATIVE_HASHING = threshold &amp;lt;= MAXIMUM_CAPACITY;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;Holder&lt;/code&gt;类是用来辅助生成hashSeed的。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;jdk.map.althashing.threshold&lt;/code&gt; —&amp;gt; &lt;code&gt;Holder.ALTERNATIVE_HASHING&lt;/code&gt; —&amp;gt; &lt;code&gt;hashSeed&lt;/code&gt;。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;private static int randomHashSeed(ConcurrentHashMap instance) {
  if (sun.misc.VM.isBooted() &amp;amp;&amp;amp; Holder.ALTERNATIVE_HASHING) {
    return sun.misc.Hashing.randomHashSeed(instance);
  }

  return 0;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;hashentry&#34;&gt;HashEntry&lt;/h3&gt;

&lt;p&gt;ConcurrentHashMap中的末端数据结构，用于存储键值信息。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;static final class HashEntry&amp;lt;K,V&amp;gt; {
  // hash和key都是final，保证了读操作时不用加锁。
  final int hash;
  final K key;
  // value设置成volatile，为了确保读操作能够看到最新的值。
  volatile V value;
  // 不再用final关键字，采用unsafe操作保证并发安全。
  volatile HashEntry&amp;lt;K,V&amp;gt; next;

  HashEntry(int hash, K key, V value, HashEntry&amp;lt;K,V&amp;gt; next) {
    this.hash = hash;
    this.key = key;
    this.value = value;
    this.next = next;
  }

  final void setNext(HashEntry&amp;lt;K,V&amp;gt; n) {
    UNSAFE.putOrderedObject(this, nextOffset, n);
  }

  // Unsafe mechanics
  static final sun.misc.Unsafe UNSAFE;
  static final long nextOffset;
  static {
    try {
      UNSAFE = sun.misc.Unsafe.getUnsafe();
      Class k = HashEntry.class;
      nextOffset = UNSAFE.objectFieldOffset
        (k.getDeclaredField(&amp;quot;next&amp;quot;));
    } catch (Exception e) {
      throw new Error(e);
    }
  }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;说明:&lt;/strong&gt;&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;HashEntry是个final类。在插入新的HashEntry节点时，只能采用头插法，因为HashEntry的next节点也是final的不可修改。final修饰的HashEntry可以提高并发性，读操作时不用加锁。&lt;/li&gt;
&lt;li&gt;HashEntry在设置next节点时，使用UNSAFE类保证线程安全。&lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&#34;segment&#34;&gt;Segment&lt;/h3&gt;

&lt;p&gt;Segment是ConcurrentHashMap的内部类，继承ReentrantLock，实现了Serializable接口。操作基本上都在Segment上，Segment中的table是一个HashEntry数组，数据就存放到这个数组中。看到这里对比下HashMap的存储结构，就大概能明白。具体方法在接下来的ConcurrentHashMap的具体方法中讲解。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;static final class Segment&amp;lt;K,V&amp;gt; extends ReentrantLock implements Serializable {
  private static final long serialVersionUID = 2249069246763182397L;

  static final int MAX_SCAN_RETRIES =
    Runtime.getRuntime().availableProcessors() &amp;gt; 1 ? 64 : 1;

  transient volatile HashEntry&amp;lt;K,V&amp;gt;[] table;
  
  transient int count;
  
  transient int modCount;

  transient int threshold;
  
  final float loadFactor;

  Segment(float lf, int threshold, HashEntry&amp;lt;K,V&amp;gt;[] tab);

  final V put(K key, int hash, V value, boolean onlyIfAbsent)

  private void rehash(HashEntry&amp;lt;K,V&amp;gt; node);

  private HashEntry&amp;lt;K,V&amp;gt; scanAndLockForPut(K key, int hash, V value);

  private void scanAndLock(Object key, int hash);

  final V remove(Object key, int hash, Object value);

  final boolean replace(K key, int hash, V oldValue, V newValue);
  final V replace(K key, int hash, V value);

  final void clear();
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;hashiterator&#34;&gt;HashIterator&lt;/h3&gt;

&lt;p&gt;ConcurrentHashMap使用了不同于传统集合的快速失败迭代器的另一种迭代方式，我们称为&lt;strong&gt;弱一致迭代器&lt;/strong&gt;。在这种迭代方式中，当iterator被创建后集合再发生改变就不再是抛出 ConcurrentModificationException，取而代之的是在改变时new新的数据从而不影响原有的数 据，iterator完成后再将头指针替换为新的数据，这样iterator线程可以使用原来老的数据，而写线程也可以并发的完成改变，更重要的，这保证了多个线程并发执行的连续性和扩展性，是性能提升的关键。&lt;/p&gt;

&lt;p&gt;HashIterator通过调用advance()遍历底层数组。在遍历过程中，如果已经遍历的数组上的内容变化了，迭代器不会抛出ConcurrentModificationException异常。如果未遍历的数组上的内容发生了变化，则有可能反映到迭代过程中。这就是ConcurrentHashMap迭代器若一致性的表现。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;HashIterator&lt;/code&gt;是个抽象类，它的子类有&lt;code&gt;EntryIterator&lt;/code&gt;，&lt;code&gt;KeyIterator&lt;/code&gt;和&lt;code&gt;ValueIterator&lt;/code&gt;。从名字上可以看出来，HashIterator为ConcurrentHashMap的遍历提供了键、值、HashEntry等不同维度的迭代器。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;EntryIterator&lt;/code&gt;、&lt;code&gt;KeyIterator&lt;/code&gt;、&lt;code&gt;ValueIterator&lt;/code&gt;事实上是为&lt;code&gt;EntrySet&lt;/code&gt;、&lt;code&gt;KeySet&lt;/code&gt;、&lt;code&gt;Values&lt;/code&gt;提供迭代服务。而所有的迭代操作在本质上都是调用HashIterator里的相关实现（如：nextEntry()，hasNext()，remove()等）。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;abstract class HashIterator {
  int nextSegmentIndex;
  int nextTableIndex;
  HashEntry&amp;lt;K,V&amp;gt;[] currentTable;
  HashEntry&amp;lt;K, V&amp;gt; nextEntry;
  HashEntry&amp;lt;K, V&amp;gt; lastReturned;

  HashIterator() {
    // 从segment的segment.length - 1开始向前遍历。
    nextSegmentIndex = segments.length - 1;
    nextTableIndex = -1;
    advance();
  }

  /**
  * Segment数组从后往前，找到第一个table数组不为null的Segment
  * 将nextSegmentIndex指向该Segment
  * 将nextTableIndex指向该table
  * 将currentTable指向该table
  * 将nextEntry指向该table中的第一个HashEntry元素
  * lastReturned在这里还没有初始化，只有在遍历(调用nextEntry())是才赋值
  */
  final void advance() {
    for (;;) {
      if (nextTableIndex &amp;gt;= 0) {
        if ((nextEntry = entryAt(currentTable, nextTableIndex--)) != null)
          break;
      }
      else if (nextSegmentIndex &amp;gt;= 0) {
        Segment&amp;lt;K,V&amp;gt; seg = segmentAt(segments, nextSegmentIndex--);
        if (seg != null &amp;amp;&amp;amp; (currentTable = seg.table) != null)
          nextTableIndex = currentTable.length - 1;
      }
      else
        break;
    }
  }

  /**
  * 获取当前nextEntry指向的HashEntry。
  * 修改lastReturned为nextEntry当前指向的HashEntry。
  * 调用advance()，向前寻找第一个table数组不为null的Segment
  */
  final HashEntry&amp;lt;K,V&amp;gt; nextEntry() {
    HashEntry&amp;lt;K,V&amp;gt; e = nextEntry;
    if (e == null)
      throw new NoSuchElementException();
    lastReturned = e; // cannot assign until after null check
    if ((nextEntry = e.next) == null)
      advance();
    return e;
  }

  // 根据nextEntry是否为空，判断是否还有下一个元素供遍历
  public final boolean hasNext() { return nextEntry != null; }
  
  // 根据nextEntry是否为空，判断是否还有下一个元素供遍历
  public final boolean hasMoreElements() { return nextEntry != null; }

  /**
  * 调用ConcurrentHashMap的remove方法，按key移除元素。
  * 将lastReturned置为空。
  * 此时nextEntry
  */
  public final void remove() {
    if (lastReturned == null)
      throw new IllegalStateException();
    ConcurrentHashMap.this.remove(lastReturned.key);
    lastReturned = null;
  }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;entryiterator&#34;&gt;EntryIterator&lt;/h3&gt;

&lt;p&gt;继承自&lt;code&gt;HashIterator&lt;/code&gt;，并实现了Iterator接口，用于HashEntry的迭代遍历。EntryIterator重写了next方法，返回了一个WriteThroughEntry对象，该对象继承自AbstractMap.SimpleEntry，本质上是个Map.Entry。&lt;/p&gt;

&lt;p&gt;EntryIterator将在ConcurrentHashMap.EntrySet中起作用，为EntrySet类型提供迭代能力。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;final class EntryIterator 
  		extends HashIterator 
  		implements Iterator&amp;lt;Entry&amp;lt;K,V&amp;gt;&amp;gt; {
  	public Map.Entry&amp;lt;K,V&amp;gt; next() {
      HashEntry&amp;lt;K,V&amp;gt; e = super.nextEntry();
      return new WriteThroughEntry(e.key, e.value);
	}
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;keyiterator&#34;&gt;KeyIterator&lt;/h3&gt;

&lt;p&gt;继承自&lt;code&gt;HashIterator&lt;/code&gt;，并实现了Iterator接口，用于HashEntry的key的迭代遍历。KeyIterator重写了next方法，返回了当前HashEntry的key值。&lt;/p&gt;

&lt;p&gt;KeyIterator将在ConcurrentHashMap.KeySet中起作用，为KeySet类型提供迭代能力。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;final class KeyIterator 
  		extends HashIterator
        implements Iterator&amp;lt;K&amp;gt;, Enumeration&amp;lt;K&amp;gt; {
  public final K next()        { return super.nextEntry().key; }
  public final K nextElement() { return super.nextEntry().key; }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;valueiterator&#34;&gt;ValueIterator&lt;/h3&gt;

&lt;p&gt;继承自HashIterator，并实现了Iterator接口，用于HashEntry的值的迭代遍历。ValueIterator重写了next方法，返回了当前HashEntry的值。&lt;/p&gt;

&lt;p&gt;ValueIterator将在ConcurrentHashMap.Values中起作用，为Values类型提供迭代能力。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;final class ValueIterator
  extends HashIterator
  implements Iterator&amp;lt;V&amp;gt;, Enumeration&amp;lt;V&amp;gt; {
  public final V next()        { return super.nextEntry().value; }
  public final V nextElement() { return super.nextEntry().value; }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;writethroughentry&#34;&gt;WriteThroughEntry&lt;/h3&gt;

&lt;p&gt;&lt;code&gt;WriteThroughEntry&lt;/code&gt;里只有一个public方法setValue，将值写入map中。注意由于并发情况，可能不会是实时修改数据，故不能用于跟踪数据。该方法可以用于遍历时修改数据。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;final class WriteThroughEntry extends AbstractMap.SimpleEntry&amp;lt;K,V&amp;gt; {
  
  WriteThroughEntry(K k, V v) {
  	super(k,v);
  }

  public V setValue(V value) {
    if (value == null) throw new NullPointerException();
    V v = super.setValue(value);
    ConcurrentHashMap.this.put(getKey(), value);
    return v;
  }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;keyset&#34;&gt;KeySet&lt;/h3&gt;

&lt;p&gt;ConcurrentHashMap的KeySet类型用于定义按Key进行遍历的相关操作。其中，iterator()会实例化一个KeyIterator()，进而提供相关的迭代操作。其他的方法，则是通过ConcurrentHashMap的原生方法实现。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;final class KeySet extends AbstractSet&amp;lt;K&amp;gt; {
  public Iterator&amp;lt;K&amp;gt; iterator() {
  	return new KeyIterator();
  }
  public int size() {
  	return ConcurrentHashMap.this.size();
  }
  public boolean isEmpty() {
  	return ConcurrentHashMap.this.isEmpty();
  }
  public boolean contains(Object o) {
  	return ConcurrentHashMap.this.containsKey(o);
  }
  public boolean remove(Object o) {
  	return ConcurrentHashMap.this.remove(o) != null;
  }
  public void clear() {
  	ConcurrentHashMap.this.clear();
  }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;entryset&#34;&gt;EntrySet&lt;/h3&gt;

&lt;p&gt;ConcurrentHashMap的EntrySet类型用于定义按Entry进行遍历的相关操作。其中，iterator()会实例化一个EntryIterator()，进而提供相关的迭代操作。其他的方法，则是通过ConcurrentHashMap的原生方法实现。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;final class EntrySet extends AbstractSet&amp;lt;Map.Entry&amp;lt;K,V&amp;gt;&amp;gt; {
  public Iterator&amp;lt;Map.Entry&amp;lt;K,V&amp;gt;&amp;gt; iterator() {
  	return new EntryIterator();
  }
  public boolean contains(Object o) {
    if (!(o instanceof Map.Entry))
    	return false;
    Map.Entry&amp;lt;?,?&amp;gt; e = (Map.Entry&amp;lt;?,?&amp;gt;)o;
    V v = ConcurrentHashMap.this.get(e.getKey());
    return v != null &amp;amp;&amp;amp; v.equals(e.getValue());
  }
  public boolean remove(Object o) {
  	if (!(o instanceof Map.Entry))
  		return false;
  	Map.Entry&amp;lt;?,?&amp;gt; e = (Map.Entry&amp;lt;?,?&amp;gt;)o;
  	return ConcurrentHashMap.this.remove(e.getKey(), e.getValue());
  }
  public int size() {
  	return ConcurrentHashMap.this.size();
  }
  public boolean isEmpty() {
  	return ConcurrentHashMap.this.isEmpty();
  }
  public void clear() {
  	ConcurrentHashMap.this.clear();
  }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;values&#34;&gt;Values&lt;/h3&gt;

&lt;p&gt;ConcurrentHashMap的Values类型用于定义按Value进行遍历的相关操作。其中，iterator()会实例化一个ValueIterator()，进而提供相关的迭代操作。其他的方法，则是通过ConcurrentHashMap的原生方法实现。&lt;/p&gt;

&lt;p&gt;由于ConcurrentHashMap的值可以重复，因此Values类型继承自AbstractCollection，而不是集合Set。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;final class Values extends AbstractCollection&amp;lt;V&amp;gt; {
  public Iterator&amp;lt;V&amp;gt; iterator() {
  	return new ValueIterator();
  }
  public int size() {
  	return ConcurrentHashMap.this.size();
  }
  public boolean isEmpty() {
  	return ConcurrentHashMap.this.isEmpty();
  }
  public boolean contains(Object o) {
  	return ConcurrentHashMap.this.containsValue(o);
  }
  public void clear() {
  	ConcurrentHashMap.this.clear();
  }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;concurrenthashmap函数列表&#34;&gt;ConcurrentHashMap函数列表&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;// 创建一个带有默认初始容量 (16)、加载因子 (0.75) 和 concurrencyLevel (16) 的新的空映射。
ConcurrentHashMap()
// 创建一个带有指定初始容量、默认加载因子 (0.75) 和 concurrencyLevel (16) 的新的空映射。
ConcurrentHashMap(int initialCapacity)
// 创建一个带有指定初始容量、加载因子和默认 concurrencyLevel (16) 的新的空映射。
ConcurrentHashMap(int initialCapacity, float loadFactor)
// 创建一个带有指定初始容量、加载因子和并发级别的新的空映射。
ConcurrentHashMap(int initialCapacity, float loadFactor, int concurrencyLevel)
// 构造一个与给定映射具有相同映射关系的新映射。
ConcurrentHashMap(Map&amp;lt;? extends K,? extends V&amp;gt; m)

// 从该映射中移除所有映射关系
void clear()
// 一种遗留方法，测试此表中是否有一些与指定值存在映射关系的键。
boolean contains(Object value)
// 测试指定对象是否为此表中的键。
boolean containsKey(Object key)
// 如果此映射将一个或多个键映射到指定值，则返回 true。
boolean containsValue(Object value)
// 返回此表中值的枚举。
Enumeration&amp;lt;V&amp;gt; elements()
// 返回此映射所包含的映射关系的 Set 视图。
Set&amp;lt;Map.Entry&amp;lt;K,V&amp;gt;&amp;gt; entrySet()
// 返回指定键所映射到的值，如果此映射不包含该键的映射关系，则返回 null。
V get(Object key)
// 如果此映射不包含键-值映射关系，则返回 true。
boolean isEmpty()
// 返回此表中键的枚举。
Enumeration&amp;lt;K&amp;gt; keys()
// 返回此映射中包含的键的 Set 视图。
Set&amp;lt;K&amp;gt; keySet()
// 将指定键映射到此表中的指定值。
V put(K key, V value)
// 将指定映射中所有映射关系复制到此映射中。
void putAll(Map&amp;lt;? extends K,? extends V&amp;gt; m)
// 如果指定键已经不再与某个值相关联，则将它与给定值关联。
V putIfAbsent(K key, V value)
// 从此映射中移除键（及其相应的值）。
V remove(Object key)
// 只有目前将键的条目映射到给定值时，才移除该键的条目。
boolean remove(Object key, Object value)
// 只有目前将键的条目映射到某一值时，才替换该键的条目。
V replace(K key, V value)
// 只有目前将键的条目映射到给定值时，才替换该键的条目。
boolean replace(K key, V oldValue, V newValue)
// 返回此映射中的键-值映射关系数。
int size()
// 返回此映射中包含的值的 Collection 视图。
Collection&amp;lt;V&amp;gt; values()
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;concurrenthashmap重点函数&#34;&gt;ConcurrentHashMap重点函数&lt;/h2&gt;

&lt;h3 id=&#34;构造函数&#34;&gt;构造函数&lt;/h3&gt;

&lt;p&gt;ConcurrentHashMap有五个构造函数，重点分析下面这个构造函数。&lt;/p&gt;

&lt;p&gt;ConcurrentHashMap初始化是通过initialCapacity，loadFactor，concurrentLevel等参数来初始化Segment数组，段偏移量segmentShift，段掩码segmentMask和每个segment里的HashEntry数组。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public ConcurrentHashMap(int initialCapacity, float loadFactor, int concurrencyLevel) {
  // 参数检查
  if (!(loadFactor &amp;gt; 0) || initialCapacity &amp;lt; 0 || concurrencyLevel &amp;lt;= 0)
    throw new IllegalArgumentException();
  // 并发级别不能超过段的最大数量
  if (concurrencyLevel &amp;gt; MAX_SEGMENTS)
    concurrencyLevel = MAX_SEGMENTS;
  // Find power-of-two sizes best matching arguments
  int sshift = 0;
  int ssize = 1;
  while (ssize &amp;lt; concurrencyLevel) {
    ++sshift;
    ssize &amp;lt;&amp;lt;= 1;
  }
  this.segmentShift = 32 - sshift;
  this.segmentMask = ssize - 1;
  if (initialCapacity &amp;gt; MAXIMUM_CAPACITY)
    initialCapacity = MAXIMUM_CAPACITY;
  int c = initialCapacity / ssize;
  if (c * ssize &amp;lt; initialCapacity)
    ++c;
  int cap = MIN_SEGMENT_TABLE_CAPACITY;
  while (cap &amp;lt; c)
    cap &amp;lt;&amp;lt;= 1;
  // create segments and segments[0]
  Segment&amp;lt;K,V&amp;gt; s0 =
    new Segment&amp;lt;K,V&amp;gt;(loadFactor, (int)(cap * loadFactor),
                     (HashEntry&amp;lt;K,V&amp;gt;[])new HashEntry[cap]);
  Segment&amp;lt;K,V&amp;gt;[] ss = (Segment&amp;lt;K,V&amp;gt;[])new Segment[ssize];
  UNSAFE.putOrderedObject(ss, SBASE, s0); // ordered write of segments[0]
  this.segments = ss;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;segments数组的长度ssize通过concurrencyLevel计算得出。&lt;/strong&gt;为了能通过按位与的哈希算法来定位segments数组的索引，必须保证segments数组的长度是2的N次方（power-of-two size），所以必须计算出一个是大于或等于concurrencyLevel的最小的2的N次方值来作为segments数组的长度。假如concurrencyLevel等于14，15或16，ssize都会等于16，即容器里锁的个数也是16。注意concurrencyLevel的最大大小是65535，意味着segments数组的长度最大为65536，对应的二进制是16位，对应全局常量MAX_SEGMENTS = 1 &amp;lt;&amp;lt; 16。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;初始化segmentShift和segmentMask。&lt;/strong&gt; 这两个全局变量在定位segment时的哈希算法里需要使用，sshift等于ssize从1向左移位的次数，在默认情况下concurrencyLevel等于16，1需要向左移位移动4次，所以sshift等于4。segmentShift用于定位参与hash运算的位数，segmentShift等于32减sshift，所以等于28，这里之所以用32是因为ConcurrentHashMap里的hash()方法输出的最大数是32位的，后面的测试中我们可以看到这点。segmentMask是哈希运算的掩码，等于ssize减1，即15，掩码的二进制各个位的值都是1。因为ssize的最大长度是65536，所以segmentShift最大值是16，segmentMask最大值是65535，对应的二进制是16位，每个位都是1。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;初始化每个Segment。&lt;/strong&gt;输入参数initialCapacity是ConcurrentHashMap的初始化容量，loadfactor是每个segment的负载因子，在构造方法里需要通过这两个参数来初始化数组中的每个segment。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;初始化每个segment里HashEntry数组的长度cap&lt;/strong&gt;。cap等于initialCapacity除以ssize的倍数c，如果c大于1，就会取大于等于c的2的N次方值，所以cap不是1，就是2的N次方。segment的容量threshold＝(int)cap*loadFactor，默认情况下initialCapacity等于16，loadfactor等于0.75，通过运算cap等于1，threshold等于零。&lt;/p&gt;

&lt;h3 id=&#34;put-k-key-v-value&#34;&gt;put(K key, V value)&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public V put(K key, V value) {
  Segment&amp;lt;K,V&amp;gt; s;
  if (value == null)
  	throw new NullPointerException();
  int hash = hash(key);
  int j = (hash &amp;gt;&amp;gt;&amp;gt; segmentShift) &amp;amp; segmentMask;
  if ((s = (Segment&amp;lt;K,V&amp;gt;)UNSAFE.getObject          // nonvolatile; recheck
  	(segments, (j &amp;lt;&amp;lt; SSHIFT) + SBASE)) == null) //  in ensureSegment
  s = ensureSegment(j);
  return s.put(key, hash, value, false);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Segment内部类中的put方法：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;final V put(K key, int hash, V value, boolean onlyIfAbsent) {
	// tryLock(): 如果锁可用，则获取锁，并立即返回true，否则返回false。
	// scanAndLockForPut扫描指定key的节点，并获取锁，如果不存在就新建一个HashEntry。
	// 在scanAndLockForPut方法里，会循环执行MAX_SCAN_RETRIES次tryLock。
	// 如果还是没有获取到锁，则调用lock()方法使用CAS获取锁。
	// 总之，在node返回时，当前线程一定已经取到了当前segment的锁。
	HashEntry&amp;lt;K,V&amp;gt; node = tryLock() ? null : 
		scanAndLockForPut(key, hash, value);
	V oldValue;
	try {
        HashEntry&amp;lt;K,V&amp;gt;[] tab = table;
        int index = (tab.length - 1) &amp;amp; hash;
        HashEntry&amp;lt;K,V&amp;gt; first = entryAt(tab, index);
        for (HashEntry&amp;lt;K,V&amp;gt; e = first;;) {
        	if (e != null) {
        		K k;
        		if ((k = e.key) == key ||
        			(e.hash == hash &amp;amp;&amp;amp; key.equals(k))) {
        			oldValue = e.value;
        			if (!onlyIfAbsent) {
        				e.value = value;
        				++modCount;
                  }
                  break;
              }
              e = e.next;
            }
            else {
                if (node != null)
                    node.setNext(first);
                else
                    node = new HashEntry&amp;lt;K,V&amp;gt;(hash, key, value, first);
                int c = count + 1;
                if (c &amp;gt; threshold &amp;amp;&amp;amp; tab.length &amp;lt; MAXIMUM_CAPACITY)
                    rehash(node);
                else
                    setEntryAt(tab, index, node);
                ++modCount;
                count = c;
                oldValue = null;
                break;
            }
		}
    } finally {
    unlock();
    }
    return oldValue;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;put操作开始，首先定位到Segment，为了线程安全，锁定当前Segment；然后在Segment里进行插入操作，首先判断是否需要扩容，然后在定位添加元素的位置放在HashEntry数组里。&lt;/p&gt;

&lt;p&gt;扩容：在插入元素前会先判断Segment里的HashEntry数组是否超过容量（threshold），如果超过阀值，数组进行扩容。值得一提的是，Segment的扩容判断比HashMap更恰当，因为HashMap是在插入元素后判断元素是否已经到达容量的，如果到达了就进行扩容，但是很有可能扩容之后没有新元素插入，这时HashMap就进行了一次无效的扩容。&lt;/p&gt;

&lt;p&gt;扩容的时候首先会创建一个两倍于原容量的数组，然后将原数组里的元素进行再hash后插入到新的数组里。为了高效ConcurrentHashMap不会对整个容器进行扩容，而只对某个segment进行扩容。&lt;/p&gt;

&lt;h3 id=&#34;get-k-key&#34;&gt;get(K key)&lt;/h3&gt;

&lt;p&gt;在ConcurrentHashMap中get(K key)方法没有加锁，因此可能会读到其他线程put的新数据。这也是ConcurrentHashMap弱一致性的体现。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public V get(Object key) {
    Segment&amp;lt;K,V&amp;gt; s; // manually integrate access methods to reduce overhead
    HashEntry&amp;lt;K,V&amp;gt;[] tab;
    int h = hash(key);
    long u = (((h &amp;gt;&amp;gt;&amp;gt; segmentShift) &amp;amp; segmentMask) &amp;lt;&amp;lt; SSHIFT) + SBASE;
    if ((s = (Segment&amp;lt;K,V&amp;gt;)UNSAFE.getObjectVolatile(segments, u)) != null &amp;amp;&amp;amp;
        (tab = s.table) != null) {
        for (HashEntry&amp;lt;K,V&amp;gt; e = (HashEntry&amp;lt;K,V&amp;gt;) UNSAFE.getObjectVolatile
                 (tab, ((long)(((tab.length - 1) &amp;amp; h)) &amp;lt;&amp;lt; TSHIFT) + TBASE);
             e != null; e = e.next) {
            K k;
            if ((k = e.key) == key || (e.hash == h &amp;amp;&amp;amp; key.equals(k)))
                return e.value;
        }
    }
    return null;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;size&#34;&gt;size()&lt;/h3&gt;

&lt;p&gt;要统计整个ConcurrentHashMap里元素的大小，就必须统计所有Segment里元素的大小后求和。Segment里的全局变量count是一个volatile变量，那么在多线程场景下，我们是不是直接把所有Segment的count相加就可以得到整个ConcurrentHashMap大小了呢？不是的，虽然相加时可以获取每个Segment的count的最新值，但是拿到之后可能累加前使用的count发生了变化，那么统计结果就不准了。所以最安全的做法，是在统计size的时候把所有Segment的put，remove和clean方法全部锁住，但是这种做法显然非常低效。&lt;/p&gt;

&lt;p&gt;因为在累加count操作过程中，之前累加过的count发生变化的几率非常小，所以ConcurrentHashMap的做法是先尝试2次通过不锁住Segment的方式来统计各个Segment大小，如果统计的过程中，容器的count发生了变化，则再采用加锁的方式来统计所有Segment的大小。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public int size() {
  // Try a few times to get accurate count. On failure due to
  // continuous async changes in table, resort to locking.
  final Segment&amp;lt;K,V&amp;gt;[] segments = this.segments;
  int size;
  boolean overflow; // true if size overflows 32 bits
  long sum;         // sum of modCounts
  long last = 0L;   // previous sum
  int retries = -1; // first iteration isn&#39;t retry
  try {
    for (;;) {
        if (retries++ == RETRIES_BEFORE_LOCK) {
            for (int j = 0; j &amp;lt; segments.length; ++j)
                ensureSegment(j).lock(); // force creation
        }
        sum = 0L;
        size = 0;
        overflow = false;
        for (int j = 0; j &amp;lt; segments.length; ++j) {
            Segment&amp;lt;K,V&amp;gt; seg = segmentAt(segments, j);
            if (seg != null) {
            sum += seg.modCount;
            int c = seg.count;
            if (c &amp;lt; 0 || (size += c) &amp;lt; 0)
            overflow = true;
            }
        }
        if (sum == last)
          break;
      	last = sum;
    }
  } finally {
      if (retries &amp;gt; RETRIES_BEFORE_LOCK) {
          for (int j = 0; j &amp;lt; segments.length; ++j)
              segmentAt(segments, j).unlock();
      }
  }
  return overflow ? Integer.MAX_VALUE : size;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;putifabsent-k-key-v-value&#34;&gt;putIfAbsent(K key, V value)&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;// 如果key在容器中不存在则将其放入其中，否则donothing.
// 返回 null,表示确实不存在，并且value被成功放入
// 返回非 null, 表示 key 存在，返回值是key在容器中的当前值 。
public V putIfAbsent(K key, V value) {
  Segment&amp;lt;K,V&amp;gt; s;
  if (value == null)
    throw new NullPointerException();
  int hash = hash(key);
  int j = (hash &amp;gt;&amp;gt;&amp;gt; segmentShift) &amp;amp; segmentMask;
  if ((s = (Segment&amp;lt;K,V&amp;gt;)UNSAFE.getObject
       (segments, (j &amp;lt;&amp;lt; SSHIFT) + SBASE)) == null)
    s = ensureSegment(j);
  return s.put(key, hash, value, true);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;参考：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;a href=&#34;http://ifeve.com/concurrenthashmap-weakly-consistent/&#34;&gt;为什么ConcurrentHashMap是弱一致的&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://www.cnblogs.com/skywang12345/p/3498537.html&#34;&gt;JUC集合之ConcurrentHashMap&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://a-ray-of-sunshine.github.io/2016/08/01/%E5%B9%B6%E5%8F%91%E5%AE%B9%E5%99%A8-ConcurrentMap/&#34;&gt;并发容器-ConcurrentMap&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://cxis.me/2016/05/26/ConcurrentHashMap%E7%AE%80%E4%BB%8B/&#34;&gt;ConcurrentHashMap简介&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;
</description>
    </item>
    
    <item>
      <title>AtomicReferenceFieldUpdater源码分析</title>
      <link>http://nituchao.com/post/juc.atomic/atomic-reference-field-update/</link>
      <pubDate>Thu, 23 Feb 2017 18:27:26 +0800</pubDate>
      
      <guid>http://nituchao.com/post/juc.atomic/atomic-reference-field-update/</guid>
      <description></description>
    </item>
    
  </channel>
</rss>