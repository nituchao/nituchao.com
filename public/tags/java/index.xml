<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Java on 泥土巢</title>
    <link>http://nituchao.com/tags/java/index.xml</link>
    <description>Recent content in Java on 泥土巢</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh-CN</language>
    <copyright>Copyright (c) 2017, nituchao | All rights reserved.</copyright>
    <atom:link href="http://nituchao.com/tags/java/index.xml" rel="self" type="application/rss+xml" />
    
    <item>
      <title>jstack命令</title>
      <link>http://nituchao.com/post/2017/tong-guo-jstack-fen-xi/</link>
      <pubDate>Tue, 28 Feb 2017 19:01:58 +0800</pubDate>
      
      <guid>http://nituchao.com/post/2017/tong-guo-jstack-fen-xi/</guid>
      <description>

&lt;p&gt;Java程序在操作系统上是以单进程、多线程的形式运行。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;[work@zc-stage1-miui-sec02 ~]$ jstack
Usage:
    jstack [-l] &amp;lt;pid&amp;gt;
        (to connect to running process)
    jstack -F [-m] [-l] &amp;lt;pid&amp;gt;
        (to connect to a hung process)
    jstack [-m] [-l] &amp;lt;executable&amp;gt; &amp;lt;core&amp;gt;
        (to connect to a core file)
    jstack [-m] [-l] [server_id@]&amp;lt;remote server IP or hostname&amp;gt;
        (to connect to a remote debug server)

Options:
    -F  to force a thread dump. Use when jstack &amp;lt;pid&amp;gt; does not respond (process is hung)
    -m  to print both java and native frames (mixed mode)
    -l  long listing. Prints additional information about locks
    -h or -help to print this help message
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;jstack参数说明&#34;&gt;jstack参数说明&lt;/h2&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;连接到运行中的进程&lt;/p&gt;

&lt;p&gt;&amp;ldquo;jstack pid&amp;rdquo;，pid为进程号，可以通过jps或者top命令查到。&lt;/p&gt;

&lt;p&gt;命令执行成功则堆栈信息打印在控制台，可以通过&amp;rdquo;jstack 7023 &amp;gt; stack.log&amp;rdquo;这种方式将内容输出文件。&lt;/p&gt;

&lt;p&gt;导出的文本中包含线程号，线程号状态，线程调用栈等信息，结合ps命令中查询出的线程号，可以分析出CPU使用率比较高的线程，以及该线程中的调用堆栈，进而可以定位到项目代码。&lt;/p&gt;

&lt;p&gt;```
Thread 1091: (state = BLOCKED)&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;sun.misc.Unsafe.park(boolean, long) @bci=0 (Compiled frame; information may be imprecise)&lt;/li&gt;
&lt;li&gt;java.util.concurrent.locks.LockSupport.park() @bci=5, line=315 (Interpreted frame)&lt;/li&gt;
&lt;li&gt;com.caucho.env.thread2.ResinThread2.park() @bci=29, line=196 (Compiled frame)&lt;/li&gt;
&lt;li&gt;com.caucho.env.thread2.ResinThread2.runTasks() @bci=65, line=147 (Compiled frame)&lt;/li&gt;
&lt;li&gt;com.caucho.env.thread2.ResinThread2.run() @bci=15, line=118 (Interpreted frame)
```&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;Thread 1089: (state = BLOCKED)
    - sun.misc.Unsafe.park(boolean, long) @bci=0 (Compiled frame; information may be imprecise)
    - java.util.concurrent.locks.LockSupport.park() @bci=5, line=315 (Interpreted frame)
    - com.caucho.env.thread2.ResinThread2.park() @bci=29, line=196 (Compiled frame)
    - com.caucho.env.thread2.ResinThread2.runTasks() @bci=65, line=147 (Compiled frame)
    - com.caucho.env.thread2.ResinThread2.run() @bci=15, line=118 (Interpreted frame)&lt;/p&gt;

&lt;p&gt;Thread 1088: (state = IN_NATIVE)
    - java.net.SocketInputStream.socketRead0(java.io.FileDescriptor, byte[], int, int, int) @bci=0 (Compiled frame; information may be imprecise)
    - java.net.SocketInputStream.read(byte[], int, int, int) @bci=79, line=150 (Compiled frame)
    - java.net.SocketInputStream.read(byte[], int, int) @bci=11, line=121 (Compiled frame)
    - java.net.SocketInputStream.read(byte[]) @bci=5, line=107 (Compiled frame)
    - redis.clients.util.RedisInputStream.ensureFill() @bci=20, line=195 (Compiled frame)
    - redis.clients.util.RedisInputStream.readByte() @bci=1, line=40 (Compiled frame)
    - redis.clients.jedis.Protocol.process(redis.clients.util.RedisInputStream) @bci=1, line=141 (Compiled frame)
    - redis.clients.jedis.Protocol.read(redis.clients.util.RedisInputStream) @bci=1, line=205 (Compiled frame)
    - redis.clients.jedis.Connection.readProtocolWithCheckingBroken() @bci=4, line=297 (Compiled frame)
    - redis.clients.jedis.Connection.getBinaryBulkReply() @bci=15, line=216 (Compiled frame)
    - redis.clients.jedis.Connection.getBulkReply() @bci=1, line=205 (Compiled frame)
    - redis.clients.jedis.Jedis.get(java.lang.String) @bci=27, line=101 (Compiled frame)
    - redis.clients.jedis.JedisCluster$3.execute(redis.clients.jedis.Jedis) @bci=5, line=79 (Compiled frame)
    - redis.clients.jedis.JedisCluster$3.execute(redis.clients.jedis.Jedis) @bci=2, line=76 (Compiled frame)
    - redis.clients.jedis.JedisClusterCommand.runWithRetries(byte[], int, boolean, boolean) @bci=78, line=119 (Compiled frame)
    - redis.clients.jedis.JedisClusterCommand.run(java.lang.String) @bci=25, line=30 (Compiled frame)
    - redis.clients.jedis.JedisCluster.get(java.lang.String) @bci=18, line=81 (Compiled frame)
    - com.xiaomi.miui.sec.service.RedisCacheService$14.call(redis.clients.jedis.RedisCluster) @bci=5, line=667 (Compiled frame)
    - com.xiaomi.miui.sec.service.RedisCacheService$14.call(java.lang.Object) @bci=5, line=663 (Compiled frame)
    - com.xiaomi.miui.cache.rediscluster.DefaultRedisClusterCache.get(java.lang.Object, com.xiaomi.miui.cache.rediscluster.RedisClusterCallable) @bci=22, line=68 (Compiled frame)
    - com.xiaomi.miui.sec.service.RedisCacheService.getSettingAdv(java.lang.String, java.lang.String, java.lang.String) @bci=49, line=663 (Compiled frame)
    - com.xiaomi.miui.sec.service.CacheService.getSettingAdv(java.lang.String, java.lang.String, java.lang.String) @bci=7, line=113 (Compiled frame)
    - com.xiaomi.miui.sec.bizLogic.SettingBiz.postHandlerMiCom(net.sf.json.JSONObject, com.xiaomi.miui.sec.thrift.Device, net.paoding.rose.web.Invocation) @bci=55, line=119 (Compiled frame)
    - com.xiaomi.miui.sec.bizLogic.SettingBiz.postHandler(net.sf.json.JSONObject, com.xiaomi.miui.sec.thrift.Device, net.paoding.rose.web.Invocation) @bci=118, line=65 (Compiled frame)
    - com.xiaomi.miui.sec.bizLogic.BasicBiz.mainHandler(net.paoding.rose.web.Invocation) @bci=29, line=59 (Compiled frame)
    - com.xiaomi.miui.sec.controllers.InfoController.setting(net.paoding.rose.web.Invocation, java.lang.String) @bci=73, line=252 (Compiled frame)
    - sun.reflect.GeneratedMethodAccessor31.invoke(java.lang.Object, java.lang.Object[]) @bci=48 (Compiled frame)
    - sun.reflect.DelegatingMethodAccessorImpl.invoke(java.lang.Object, java.lang.Object[]) @bci=6, line=43 (Compiled frame)
    - java.lang.reflect.Method.invoke(java.lang.Object, java.lang.Object[]) @bci=57, line=606 (Compiled frame)&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;
   ​

## jstack分析java线程的CPU使用率和使用时长



## jstack分析分析已有的javacore文件



## jstack连接到远程调试服务器进行分析
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>解决Java进程占用CPU过高的问题</title>
      <link>http://nituchao.com/post/2017/ji-lu-yi-ci-cpu-guo-gao-chu-li/</link>
      <pubDate>Tue, 28 Feb 2017 09:16:18 +0800</pubDate>
      
      <guid>http://nituchao.com/post/2017/ji-lu-yi-ci-cpu-guo-gao-chu-li/</guid>
      <description></description>
    </item>
    
    <item>
      <title>Java锁之CAS的原理</title>
      <link>http://nituchao.com/post/juc.lock/java-cas/</link>
      <pubDate>Thu, 23 Feb 2017 18:29:27 +0800</pubDate>
      
      <guid>http://nituchao.com/post/juc.lock/java-cas/</guid>
      <description>&lt;p&gt;参考:&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;a href=&#34;http://zl198751.iteye.com/blog/1848575&#34;&gt;JAVA CAS原理深度分析&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;
</description>
    </item>
    
    <item>
      <title>Java锁之Unsafe类的理解</title>
      <link>http://nituchao.com/post/juc.lock/java-unsafe/</link>
      <pubDate>Thu, 23 Feb 2017 18:29:27 +0800</pubDate>
      
      <guid>http://nituchao.com/post/juc.lock/java-unsafe/</guid>
      <description>&lt;p&gt;参考:&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;&lt;a href=&#34;http://www.cnblogs.com/chenpi/p/5389254.html&#34;&gt;sun.misc.Unsafe的理解&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;a href=&#34;http://ifeve.com/sun-misc-unsafe/&#34;&gt;Java Magic. Part 4: sun.misc.Unsafe&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;a href=&#34;http://howtodoinjava.com/tag/java-hidden-features/&#34;&gt;java-hidden-features&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;a href=&#34;http://blog.csdn.net/fenglibing/article/details/17138079&#34;&gt;sun.misc.unsafe类的使用&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;a href=&#34;http://www.blogjava.net/xylz/archive/2010/07/04/325206.html&#34;&gt;深入浅出 Java Concurrency (5): 原子操作 part 4&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;
</description>
    </item>
    
    <item>
      <title>Java锁之自旋锁的原理</title>
      <link>http://nituchao.com/post/juc.lock/clh-spin-ticket-mcs-lock/</link>
      <pubDate>Thu, 23 Feb 2017 18:29:27 +0800</pubDate>
      
      <guid>http://nituchao.com/post/juc.lock/clh-spin-ticket-mcs-lock/</guid>
      <description>

&lt;h2 id=&#34;概述&#34;&gt;概述&lt;/h2&gt;

&lt;p&gt;锁作为数据同步工具，Java提供了两种实现：synchronized和AQS，这两种锁的实现根本不同，但是在加锁和解锁的过程中，也有很多共同点。它们在进行加锁/解锁时或多或少的用到自旋锁的设计思想。对于这几种自旋锁设计思想的研究，可以帮助我们更好的理解Java的Lock框架。&lt;/p&gt;

&lt;h2 id=&#34;spin锁&#34;&gt;SPIN锁&lt;/h2&gt;

&lt;p&gt;Spin锁即自旋锁。自旋锁是采用让当前线程不停地在循环体内&lt;code&gt;检测并设置临界资源的状态&lt;/code&gt;，直到状态满足条件并设置为指定的新状态。&lt;code&gt;检测并设置临界资源&lt;/code&gt;操作必须是原子的，这样即使多个线程在给定时间自旋，也只有一个线程可获得该锁。&lt;/p&gt;

&lt;p&gt;自旋锁的优点之一是自旋的线程不会被阻塞，一直处于活跃状态，对于锁保护的临界区较小的情况下，自旋获取锁和释放锁的成本都比较低，时间比较短。&lt;/p&gt;

&lt;h3 id=&#34;java中的自旋锁&#34;&gt;Java中的自旋锁&lt;/h3&gt;

&lt;p&gt;在JAVA中，我们可以使用原子变量和Unsafe类的CAS操作来实现自旋锁：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public class SpinLock {
  private AtomicReference&amp;lt;Thread&amp;gt; atomic = new AtomicReference&amp;lt;Thread&amp;gt;();
  
  public void lock() {
    Thread currentThread = Thread.currentThread();
    
    // 如果锁未被占用，则设置当前线程为锁的拥有者。
    while(!atomic.compareAndSet(null, currentThread)) {}
  }
  
  public void unlock() {
    Thread currentThread = Thread.currentThread();
    // 只有锁的拥有者能释放锁
    atomic.compareAndSet(currentThread, null);
  }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;缺点&#34;&gt;缺点&lt;/h4&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;CAS操作需要硬件的配合；&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;保证各个CPU的缓存（L1、L2、L3、跨CPU Socket、主存）的数据一致性，通讯开销很大，在多处理器系统上更严重；&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;没法保证公平性，不保证等待进程/线程按照FIFO顺序获得锁。&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;​&lt;/p&gt;

&lt;h3 id=&#34;linux中的自旋锁&#34;&gt;Linux中的自旋锁&lt;/h3&gt;

&lt;p&gt;自旋锁在Linux内核中广泛使用。在Linux操作系统中，自旋锁是一个互斥设备，它只有两个值&lt;code&gt;锁定&lt;/code&gt;和&lt;code&gt;解锁&lt;/code&gt;。&lt;/p&gt;

&lt;p&gt;由于操作系统和CPU直接打交道，自旋锁又可分为在单核处理器上和多核处理器上。&lt;/p&gt;

&lt;h4 id=&#34;单核处理器&#34;&gt;单核处理器&lt;/h4&gt;

&lt;p&gt;用在单核处理器上，有可分为两种：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;系统不支持内核抢占&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;此时自旋锁什么也不做，确实也不需要做什么，因为单核处理器只有一个线程在执行，又不支持内核抢占，因此资源不可能会被其他的线程访问到。&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;系统支持内核抢占&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;这种情况下，自旋锁加锁仅仅是禁止了内核抢占，解锁则是启用了内核抢占。&lt;/p&gt;

&lt;p&gt;在上述两种情况下，在获取自旋锁后可能会发生中断，若中断处理程序去访问自旋锁所保护的资源，则会发生死锁。因此，linux内核又提供了spin_lock_irq()和spin_lock_irqsave()，这两个函数会在获取自旋锁的同时（同时禁止内核抢占），禁止本地外部可屏蔽中断，从而保证自旋锁的原子操作。&lt;/p&gt;

&lt;h4 id=&#34;多核处理器&#34;&gt;多核处理器&lt;/h4&gt;

&lt;p&gt;多核处理器意味着有多个线程可以同时在不同的处理器上并行执行。&lt;/p&gt;

&lt;p&gt;举个例子：&lt;/p&gt;

&lt;p&gt;四核处理器，若A处理器上的线程1获取了锁,B、C两个处理器恰好这个时候也要访问这个锁保护的资源，因此他俩CPU就一直自旋忙等待。D并不需要这个资源，因此它可以正常处理其他事情。&lt;/p&gt;

&lt;p&gt;自旋锁的几个特点：&lt;/p&gt;

&lt;p&gt;1.被自旋锁保护的临界区代码执行时不能睡眠。单核处理器下，获取到锁的线程睡眠，若恰好此时CPU调度的另一个执行线程也需要获取这个锁，则会造成死锁；多核处理器下，若想获取锁的线程在同一个处理器下，同样会造成死锁，若位于另外的处理器，则会长时间占用CPU等待睡眠的线程释放锁，从而浪费CPU资源。&lt;/p&gt;

&lt;p&gt;2.被自旋锁保护的临界区代码执行时不能被其他中断打断。&lt;/p&gt;

&lt;p&gt;3.被自旋锁保护的临界区代码在执行时，内核不能被抢占。&lt;/p&gt;

&lt;h4 id=&#34;自旋锁函数&#34;&gt;自旋锁函数&lt;/h4&gt;

&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;// 最基本得自旋锁函数，它不失效本地中断。
void spin_lock(spinlock_t *lock);
// 在获得自旋锁之前禁用硬中断（只在本地处理器上），而先前的中断状态保存在flags中
void spin_lock_irqsave(spinlock_t *lock, unsigned long flags);
// 在获得自旋锁之前禁用硬中断（只在本地处理器上），不保存中断状态
void spin_lockirq(spinlock_t *lock);
// 在获得锁前禁用软中断，保持硬中断打开状态
void spin_lock_bh(spinlock_t *lock);
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;ticket锁&#34;&gt;TICKET锁&lt;/h2&gt;

&lt;p&gt;Ticket锁即排队自旋锁，Ticket锁是为了解决上面自旋锁的公平性问题，类似于现实中海底捞的排队叫号：锁拥有一个服务号，表示正在服务的线程，还有一个排队号；每个线程尝试获取锁之前先拿一个排队号，然后不断轮训锁的当前服务号是否是自己的排队号，如果是，则表示自己拥有了锁，不是则继续轮训。&lt;/p&gt;

&lt;p&gt;当前线程释放锁时，将服务号加1，这样下一个线程看到这个变化，就退出自旋，表示获取到锁。&lt;/p&gt;

&lt;h3 id=&#34;java中的自旋锁-1&#34;&gt;Java中的自旋锁&lt;/h3&gt;

&lt;p&gt;在JAVA中，我们可以使用原子变量和Unsafe类的CAS操作来实现Ticket自旋锁：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public class TicketLock {
   private AtomicInteger serviceNum = new AtomicInteger(); // 服务号
   private AtomicInteger ticketNum = new AtomicInteger(); // 排队号

   public int lock() {
         // 首先原子性地获得一个排队号
         int myTicketNum = ticketNum.getAndIncrement();

         // 只要当前服务号不是自己的就不断轮询
       	while (serviceNum.get() != myTicketNum) {}

       	return myTicketNum;
    }

    public void unlock(int myTicket) {
        // 只有当前线程拥有者才能释放锁
        int next = myTicket + 1;
        serviceNum.compareAndSet(myTicket, next);
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;缺点-1&#34;&gt;缺点&lt;/h4&gt;

&lt;p&gt;Ticket Lock 虽然解决了公平性的问题，但是多处理器系统上，每个进程/线程占用的处理器都在读写同一个变量&lt;code&gt;serviceNum&lt;/code&gt; ，每次读写操作都必须在多个处理器缓存之间进行缓存同步，这会导致繁重的系统总线和内存的流量，大大降低系统整体的性能。&lt;/p&gt;

&lt;h3 id=&#34;linux中的排队自旋锁&#34;&gt;Linux中的排队自旋锁&lt;/h3&gt;

&lt;p&gt;排队自旋锁(FIFO Ticket Spinlock)是Linux内核2.6.25版本引入的一种新型自旋锁，它解决了传统自旋锁由于无序竞争导致的&amp;rdquo;公平性&amp;rdquo;问题。但是由于排队自旋锁在一个共享变量上“自旋”，因此在锁竞争激烈的多核或 NUMA 系统上导致性能低下。&lt;/p&gt;

&lt;h2 id=&#34;mcs锁&#34;&gt;MCS锁&lt;/h2&gt;

&lt;p&gt;MCS自旋锁是一种基于链表的高性能、可扩展的自旋锁。申请线程之在本地变量上自旋，直接前驱负责通知其结束自旋，从而极大地减少了不必要的处理器缓存同步的次数，降低了总线和内存的开销。&lt;/p&gt;

&lt;p&gt;MCS锁的设计目标如下：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;保证自旋锁申请者以先进先出的顺序获取锁（FIFO Ordering）。&lt;/li&gt;
&lt;li&gt;只在本地可访问的标志变量上自旋。&lt;/li&gt;
&lt;li&gt;在处理器个数较少的系统中或锁竞争并不激烈的情况下，保持较高性能。&lt;/li&gt;
&lt;li&gt;自旋锁的空间复杂度（即锁数据结构和锁操作所需的空间开销）为常数。&lt;/li&gt;
&lt;li&gt;在没有处理器缓存一致性协议保证的系统中也能很好地工作。&lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&#34;java中的mcs锁&#34;&gt;Java中的MCS锁&lt;/h3&gt;

&lt;p&gt;在JAVA中，我们可以使用原子变量和Unsafe类的CAS操作来实现MCS自旋锁：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public class MCSLock {
    public static class MCSNode {
        volatile MCSNode next;
        volatile boolean isBlock = true; // 本地自旋变量，默认是在等待锁
    }

    volatile MCSNode queue;// 指向最后一个申请锁的MCSNode
    private static final AtomicReferenceFieldUpdater UPDATER = 
      AtomicReferenceFieldUpdater.newUpdater(MCSLock.class, MCSNode.class, &amp;quot;queue&amp;quot;);

    public void lock(MCSNode currentThread) {
        MCSNode predecessor = UPDATER.getAndSet(this, currentThread);// step 1
        if (predecessor != null) {
            predecessor.next = currentThread;// step 2

            while (currentThread.isBlock) {// step 3
            }
        }else { // 只有一个线程在使用锁，没有前驱来通知它，所以得自己标记自己为非阻塞
            currentThread.isBlock = false;
        }
    }

    public void unlock(MCSNode currentThread) {
        if (currentThread.isBlock) {// 锁拥有者进行释放锁才有意义
            return;
        }

        if (currentThread.next == null) {// 检查是否有人排在自己后面
            if (UPDATER.compareAndSet(this, currentThread, null)) {// step 4
                // compareAndSet返回true表示确实没有人排在自己后面
                return;
            } else {
                // 突然有人排在自己后面了，可能还不知道是谁，下面是等待后续者
                // 这里之所以要忙等是因为：step 1执行完后，step 2可能还没执行完
                while (currentThread.next == null) { // step 5
                }
            }
        }

        currentThread.next.isBlock = false;
        currentThread.next = null;// for GC
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;linux中的mcs锁&#34;&gt;Linux中的MCS锁&lt;/h3&gt;

&lt;p&gt;目前 Linux 内核尚未使用 MCS Spinlock。根据上节的算法描述，我们可以很容易地实现 MCS Spinlock。本文的实现针对x86 体系结构(包括 IA32 和 x86_64)。原子交换、比较-交换操作可以使用带 LOCK 前缀的 xchg(q)，cmpxchg(q)[3] 指令实现。&lt;/p&gt;

&lt;h2 id=&#34;clh锁&#34;&gt;CLH锁&lt;/h2&gt;

&lt;p&gt;CLH（Craig, Landin, and Hagersten）锁也是基于链表的可扩展、高性能、公平的自旋锁，申请线程旨在本地变量上自旋，它不断轮训前驱的状态，如果发现前驱释放了锁就结束自旋。&lt;/p&gt;

&lt;h3 id=&#34;java中的clh锁&#34;&gt;Java中的CLH锁&lt;/h3&gt;

&lt;p&gt;在Java中CLH的应用非常广泛，比如JUC包下的锁框架AbstractQueuedSynchronized就是基于CLH实现的，并进而实现了整个Lock框架体系。&lt;/p&gt;

&lt;p&gt;在JAVA中，我们可以使用原子变量和Unsafe类的CAS操作来实现CLH自旋锁：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public class CLHLock {
    public static class CLHNode {
        private volatile boolean isLocked = true; // 默认是在等待锁
    }

    @SuppressWarnings(&amp;quot;unused&amp;quot; )
    private volatile CLHNode tail ;
    private static final AtomicReferenceFieldUpdater&amp;lt;CLHLock, CLHNode&amp;gt; UPDATER = AtomicReferenceFieldUpdater
                  . newUpdater(CLHLock.class, CLHNode .class , &amp;quot;tail&amp;quot; );

    public void lock(CLHNode currentThread) {
        CLHNode preNode = UPDATER.getAndSet( this, currentThread);
        if(preNode != null) {//已有线程占用了锁，进入自旋
            while(preNode.isLocked ) {
            }
        }
    }

    public void unlock(CLHNode currentThread) {
        // 如果队列里只有当前线程，则释放对当前线程的引用（for GC）。
        if (!UPDATER .compareAndSet(this, currentThread, null)) {
            // 还有后续线程
            currentThread. isLocked = false ;// 改变状态，让后续线程结束自旋
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;clh锁与mcs锁的比较&#34;&gt;CLH锁与MCS锁的比较&lt;/h2&gt;

&lt;p&gt;下图是经典的CLH锁和MCS锁队列图示：&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://coderbee.net/wp-content/uploads/2013/11/CLH-MCS-SpinLock.png&#34; alt=&#34;CLH和MCS&#34; /&gt;&lt;/p&gt;

&lt;p&gt;差异：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;从代码实现来看，CLH比MCS要简单得多。&lt;/li&gt;
&lt;li&gt;从自旋的条件来看，CLH是在前驱节点的属性上自旋，而MCS是在本地属性变量上自旋。&lt;/li&gt;
&lt;li&gt;从链表队列来看，CLH的队列是隐式的，CLHNode并不实际持有下一个节点；MCS的队列是物理存在的。&lt;/li&gt;
&lt;li&gt;CLH锁释放时只需要改变自己的属性，MCS锁释放则需要改变后继节点的属性。&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;&lt;strong&gt;注意：这里实现的锁都是独占的，且不能重入的。&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;参考：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;a href=&#34;https://www.ibm.com/developerworks/cn/linux/l-cn-mcsspinlock/&#34;&gt;高性能自旋锁 MCS Spinlock 的设计与实现&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://www.cnblogs.com/hdflzh/p/3716156.html&#34;&gt;高效编程之互斥锁和自旋锁的一些知识&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://my.oschina.net/MinGKai/blog/188522&#34;&gt;基于队列的锁:mcs lock简介&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://blog.csdn.net/vividonly/article/details/6594195&#34;&gt;深入理解linux内核自旋锁&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;
</description>
    </item>
    
    <item>
      <title>Java锁之Lock框架概述</title>
      <link>http://nituchao.com/post/juc.lock/lock-summary/</link>
      <pubDate>Thu, 23 Feb 2017 18:28:27 +0800</pubDate>
      
      <guid>http://nituchao.com/post/juc.lock/lock-summary/</guid>
      <description>

&lt;p&gt;在Java中关于锁有两个体系，一个是synchronized代表的对象监视器同步锁，一个是以AQS为基础的锁框架，该框架位于java.uti.concurrent包下。&lt;/p&gt;

&lt;p&gt;本文基于JDK1.7.0_67。&lt;/p&gt;

&lt;h2 id=&#34;aqs框架原理-aqs框架图-file-users-liang-library-group-20containers-ubf8t346g9-office-msoclip1-01-65cceb69-4317-8645-9279-f8aa33dad044-png&#34;&gt;AQS框架原理&lt;img src=&#34;file:////Users/liang/Library/Group%20Containers/UBF8T346G9.Office/msoclip1/01/65CCEB69-4317-8645-9279-F8AA33DAD044.png&#34; alt=&#34;AQS框架图&#34; /&gt;&lt;/h2&gt;

&lt;h2 id=&#34;juc包中的锁&#34;&gt;JUC包中的锁&lt;/h2&gt;

&lt;p&gt;相比同步锁，JUC包中的锁的功能更加强大，它为锁提供了一个框架，该框架允许更灵活地使用锁，只是它的用法更难罢了。&lt;/p&gt;

&lt;p&gt;JUC包中的锁，包括：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Lock接口&lt;/li&gt;
&lt;li&gt;ReadWriteLock接口&lt;/li&gt;
&lt;li&gt;Condition接口&lt;/li&gt;
&lt;li&gt;ReentrantLock独占锁&lt;/li&gt;
&lt;li&gt;ReentrantReadWriteLock读写锁&lt;/li&gt;
&lt;li&gt;CountDownLatch&lt;/li&gt;
&lt;li&gt;CyclicBarrier&lt;/li&gt;
&lt;li&gt;Semaphore&lt;/li&gt;
&lt;li&gt;AbstractOwnableSynchronizer抽象类&lt;/li&gt;
&lt;li&gt;AbstractQueuedSynchronizer抽象类&lt;/li&gt;
&lt;li&gt;AbstractQueuedLongSynchronizer抽象类&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>ConcurrentHashMap源码分析</title>
      <link>http://nituchao.com/post/juc.concurrent/concurrent-hasmap/</link>
      <pubDate>Thu, 23 Feb 2017 18:27:27 +0800</pubDate>
      
      <guid>http://nituchao.com/post/juc.concurrent/concurrent-hasmap/</guid>
      <description>

&lt;h2 id=&#34;一言&#34;&gt;一言&lt;/h2&gt;

&lt;p&gt;ConcurrentHashMap是线程安全的、高效的哈希表。默认支持16个并发级别，并发级别在初始化后不能扩展。&lt;/p&gt;

&lt;h2 id=&#34;概述&#34;&gt;概述&lt;/h2&gt;

&lt;p&gt;&lt;strong&gt;HashMap&lt;/strong&gt;是非线程安全的哈希表，常用于单线程程序中。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Hashtable&lt;/strong&gt;是线程安全的哈希表，它是通过synchronized来保证线程安全的；多线程通过同一个“对象的同步锁”来实现并发控制。Hashtable在线程竞争激烈时，效率比较低(此时建议使用ConcurrentHashMap)！因为当一个线程访问Hashtable的同步方法时，其它线程就访问Hashtable的同步方法时，可能会进入阻塞状态。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;ConcurrentHashMap&lt;/strong&gt;是线程安全的哈希表，它是通过“锁分段”来保证线程安全的。ConcurrentHashMap将哈希表分成许多片段(Segment)，每一个片段除了保存哈希表之外，本质上也是一个“可重入的互斥锁”(ReentrantLock)。多线程对同一个片段的访问，是互斥的；但是，对于不同片段的访问，却是可以同步进行的。&lt;/p&gt;

&lt;p&gt;本文基于JDK1.7.0_67。&lt;/p&gt;

&lt;h2 id=&#34;concurrenthashmap数据结构&#34;&gt;ConcurrentHashMap数据结构&lt;/h2&gt;

&lt;p&gt;要想搞清ConcurrentHashMap，必须先弄清楚它的数据结构：&lt;/p&gt;

&lt;p&gt;&lt;code&gt;图&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;说明:&lt;/strong&gt;&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;ConcurrentHashMap继承于AbstractMap抽象类。&lt;/li&gt;
&lt;li&gt;Setment是ConcurrentHashMap的内部类，它就是ConcurrentHashMap中的&amp;rdquo;锁分段&amp;rdquo;对应的数据结构。ConcurrentHashMap与Segment是组合关系，1个ConcurrentHashMap对象包含若干个Segment对象。在代码中，这表现为ConcurrentHashMap类中存在&amp;rdquo;Segment数组&amp;rdquo;成员。&lt;/li&gt;
&lt;li&gt;Segment类继承于ReentrantLock类，所以Segment本质上是一个可重入的互斥锁。&lt;/li&gt;
&lt;li&gt;HashEntry也是ConcurrentHashMap的内部类，是单向链表节点，存储着key-value键值对。Segment与HashEntry是组合关系，Segment类中存在“HashEntry数组”成员，“HashEntry数组”中的每个HashEntry就是一个单向链表。&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;对于多线程访问对一个“哈希表对象”竞争资源，Hashtable是通过一把锁来控制并发；而ConcurrentHashMap则是将哈希表分成许多片段，对于每一个片段分别通过一个互斥锁来控制并发。ConcurrentHashMap对并发的控制更加细腻，它也更加适应于高并发场景！&lt;/p&gt;

&lt;h2 id=&#34;concurrenthashmap常量定义&#34;&gt;ConcurrentHashMap常量定义&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;// 默认初始容量(HashEntry的个数)
static final int DEFAULT_INITIAL_CAPACITY = 16;
// 默认负载因子
static final float DEFAULT_LOAD_FACTOR = 0.75f;
// 默认并发级别
static final int DEFAULT_CONCURRENCY_LEVEL = 16;
// 最大容量(HashEntry的个数)
static final int MAXIMUM_CAPACITY = 1 &amp;lt;&amp;lt; 30;
// 每个段(Segment)中HashEntry数组(table)的最小容量
// 设置最小为2，是为了防止构造完成后立即resize
static final int MIN_SEGMENT_TABLE_CAPACITY = 2;
// 段的最大个数
static final int MAX_SEGMENTS = 1 &amp;lt;&amp;lt; 16; // slightly conservative
// 在计算size时，先尝试不获取段锁计算，最多尝试RETRIES_BEFORE_LOCK次。
// 如果重试超过RETRIES_BEFORE_LOCK次，则获取段锁后进行计算。
static final int RETRIES_BEFORE_LOCK = 2;
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;concurrenthashmap成员变量&#34;&gt;ConcurrentHashMap成员变量&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;// 制造一个随机值，使得在计算key的hash值时不容易出现冲突。
// 该值通过sun.misc.Hashing.randomHashSeed(instance)生成。
private transient final int hashSeed = randomHashSeed(this);
// 段segment的掩码，用于计算key所在segments索引值。
final int segmentMask;
// 段segment的偏移，用于计算key所在segments索引值。
final int segmentShift;
// 段segment数组，其内部是由HashEntry数组实现。
final Segment&amp;lt;K,V&amp;gt;[] segments;
// 键集合，键不能重复
transient Set&amp;lt;K&amp;gt; keySet;
// 值集合，值可以重复
transient Collection&amp;lt;V&amp;gt; values;
// 元素HashEntry集合
transient Set&amp;lt;Map.Entry&amp;lt;K,V&amp;gt;&amp;gt; entrySet;
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;concurrenthashmap内部类&#34;&gt;ConcurrentHashMap内部类&lt;/h2&gt;

&lt;h3 id=&#34;holder&#34;&gt;Holder&lt;/h3&gt;

&lt;p&gt;静态内部类，存放一些在虚拟机启动后才能初始化的值。&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;容量阈值，初始化hashSeed的时候会用到该值。&lt;/li&gt;
&lt;/ol&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;static final boolean ALTERNATIVE_HASHING;
&lt;/code&gt;&lt;/pre&gt;

&lt;ol&gt;
&lt;li&gt;static静态块&lt;/li&gt;
&lt;/ol&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;static {
  // 获取系统变量jdk.map.althashing.threshold
  // 通过系统变量jdk.map.althashing.threshold来初始化threshold
  String altThreshold = java.security.AccessController.doPrivileged(
    new sun.security.action.GetPropertyAction(
      &amp;quot;jdk.map.althashing.threshold&amp;quot;));

  int threshold;
  try {
    threshold = (null != altThreshold)
      ? Integer.parseInt(altThreshold)
      : Integer.MAX_VALUE;

    // disable alternative hashing if -1
    if (threshold == -1) {
      threshold = Integer.MAX_VALUE;
    }

    if (threshold &amp;lt; 0) {
      throw new IllegalArgumentException(&amp;quot;value must be positive integer.&amp;quot;);
    }
  } catch(IllegalArgumentException failed) {
    throw new Error(&amp;quot;Illegal value for &#39;jdk.map.althashing.threshold&#39;&amp;quot;, failed);
  }
  // 根据系统变量jdk.map.althashing.threshold来初始化ALTERNATIVE_HASHING
  ALTERNATIVE_HASHING = threshold &amp;lt;= MAXIMUM_CAPACITY;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;Holder&lt;/code&gt;类是用来辅助生成hashSeed的。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;jdk.map.althashing.threshold&lt;/code&gt; —&amp;gt; &lt;code&gt;Holder.ALTERNATIVE_HASHING&lt;/code&gt; —&amp;gt; &lt;code&gt;hashSeed&lt;/code&gt;。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;private static int randomHashSeed(ConcurrentHashMap instance) {
  if (sun.misc.VM.isBooted() &amp;amp;&amp;amp; Holder.ALTERNATIVE_HASHING) {
    return sun.misc.Hashing.randomHashSeed(instance);
  }

  return 0;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;hashentry&#34;&gt;HashEntry&lt;/h3&gt;

&lt;p&gt;ConcurrentHashMap中的末端数据结构，用于存储键值信息。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;static final class HashEntry&amp;lt;K,V&amp;gt; {
  // hash和key都是final，保证了读操作时不用加锁。
  final int hash;
  final K key;
  // value设置成volatile，为了确保读操作能够看到最新的值。
  volatile V value;
  // 不再用final关键字，采用unsafe操作保证并发安全。
  volatile HashEntry&amp;lt;K,V&amp;gt; next;

  HashEntry(int hash, K key, V value, HashEntry&amp;lt;K,V&amp;gt; next) {
    this.hash = hash;
    this.key = key;
    this.value = value;
    this.next = next;
  }

  final void setNext(HashEntry&amp;lt;K,V&amp;gt; n) {
    UNSAFE.putOrderedObject(this, nextOffset, n);
  }

  // Unsafe mechanics
  static final sun.misc.Unsafe UNSAFE;
  static final long nextOffset;
  static {
    try {
      UNSAFE = sun.misc.Unsafe.getUnsafe();
      Class k = HashEntry.class;
      nextOffset = UNSAFE.objectFieldOffset
        (k.getDeclaredField(&amp;quot;next&amp;quot;));
    } catch (Exception e) {
      throw new Error(e);
    }
  }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;说明:&lt;/strong&gt;&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;HashEntry是个final类。在插入新的HashEntry节点时，只能采用头插法，因为HashEntry的next节点也是final的不可修改。final修饰的HashEntry可以提高并发性，读操作时不用加锁。&lt;/li&gt;
&lt;li&gt;HashEntry在设置next节点时，使用UNSAFE类保证线程安全。&lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&#34;segment&#34;&gt;Segment&lt;/h3&gt;

&lt;p&gt;Segment是ConcurrentHashMap的内部类，继承ReentrantLock，实现了Serializable接口。操作基本上都在Segment上，Segment中的table是一个HashEntry数组，数据就存放到这个数组中。看到这里对比下HashMap的存储结构，就大概能明白。具体方法在接下来的ConcurrentHashMap的具体方法中讲解。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;static final class Segment&amp;lt;K,V&amp;gt; extends ReentrantLock implements Serializable {
  private static final long serialVersionUID = 2249069246763182397L;

  static final int MAX_SCAN_RETRIES =
    Runtime.getRuntime().availableProcessors() &amp;gt; 1 ? 64 : 1;

  transient volatile HashEntry&amp;lt;K,V&amp;gt;[] table;
  
  transient int count;
  
  transient int modCount;

  transient int threshold;
  
  final float loadFactor;

  Segment(float lf, int threshold, HashEntry&amp;lt;K,V&amp;gt;[] tab);

  final V put(K key, int hash, V value, boolean onlyIfAbsent)

  private void rehash(HashEntry&amp;lt;K,V&amp;gt; node);

  private HashEntry&amp;lt;K,V&amp;gt; scanAndLockForPut(K key, int hash, V value);

  private void scanAndLock(Object key, int hash);

  final V remove(Object key, int hash, Object value);

  final boolean replace(K key, int hash, V oldValue, V newValue);
  final V replace(K key, int hash, V value);

  final void clear();
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;hashiterator&#34;&gt;HashIterator&lt;/h3&gt;

&lt;p&gt;ConcurrentHashMap使用了不同于传统集合的快速失败迭代器的另一种迭代方式，我们称为&lt;strong&gt;弱一致迭代器&lt;/strong&gt;。在这种迭代方式中，当iterator被创建后集合再发生改变就不再是抛出 ConcurrentModificationException，取而代之的是在改变时new新的数据从而不影响原有的数 据，iterator完成后再将头指针替换为新的数据，这样iterator线程可以使用原来老的数据，而写线程也可以并发的完成改变，更重要的，这保证了多个线程并发执行的连续性和扩展性，是性能提升的关键。&lt;/p&gt;

&lt;p&gt;HashIterator通过调用advance()遍历底层数组。在遍历过程中，如果已经遍历的数组上的内容变化了，迭代器不会抛出ConcurrentModificationException异常。如果未遍历的数组上的内容发生了变化，则有可能反映到迭代过程中。这就是ConcurrentHashMap迭代器若一致性的表现。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;HashIterator&lt;/code&gt;是个抽象类，它的子类有&lt;code&gt;EntryIterator&lt;/code&gt;，&lt;code&gt;KeyIterator&lt;/code&gt;和&lt;code&gt;ValueIterator&lt;/code&gt;。从名字上可以看出来，HashIterator为ConcurrentHashMap的遍历提供了键、值、HashEntry等不同维度的迭代器。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;EntryIterator&lt;/code&gt;、&lt;code&gt;KeyIterator&lt;/code&gt;、&lt;code&gt;ValueIterator&lt;/code&gt;事实上是为&lt;code&gt;EntrySet&lt;/code&gt;、&lt;code&gt;KeySet&lt;/code&gt;、&lt;code&gt;Values&lt;/code&gt;提供迭代服务。而所有的迭代操作在本质上都是调用HashIterator里的相关实现（如：nextEntry()，hasNext()，remove()等）。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;abstract class HashIterator {
  int nextSegmentIndex;
  int nextTableIndex;
  HashEntry&amp;lt;K,V&amp;gt;[] currentTable;
  HashEntry&amp;lt;K, V&amp;gt; nextEntry;
  HashEntry&amp;lt;K, V&amp;gt; lastReturned;

  HashIterator() {
    // 从segment的segment.length - 1开始向前遍历。
    nextSegmentIndex = segments.length - 1;
    nextTableIndex = -1;
    advance();
  }

  /**
  * Segment数组从后往前，找到第一个table数组不为null的Segment
  * 将nextSegmentIndex指向该Segment
  * 将nextTableIndex指向该table
  * 将currentTable指向该table
  * 将nextEntry指向该table中的第一个HashEntry元素
  * lastReturned在这里还没有初始化，只有在遍历(调用nextEntry())是才赋值
  */
  final void advance() {
    for (;;) {
      if (nextTableIndex &amp;gt;= 0) {
        if ((nextEntry = entryAt(currentTable, nextTableIndex--)) != null)
          break;
      }
      else if (nextSegmentIndex &amp;gt;= 0) {
        Segment&amp;lt;K,V&amp;gt; seg = segmentAt(segments, nextSegmentIndex--);
        if (seg != null &amp;amp;&amp;amp; (currentTable = seg.table) != null)
          nextTableIndex = currentTable.length - 1;
      }
      else
        break;
    }
  }

  /**
  * 获取当前nextEntry指向的HashEntry。
  * 修改lastReturned为nextEntry当前指向的HashEntry。
  * 调用advance()，向前寻找第一个table数组不为null的Segment
  */
  final HashEntry&amp;lt;K,V&amp;gt; nextEntry() {
    HashEntry&amp;lt;K,V&amp;gt; e = nextEntry;
    if (e == null)
      throw new NoSuchElementException();
    lastReturned = e; // cannot assign until after null check
    if ((nextEntry = e.next) == null)
      advance();
    return e;
  }

  // 根据nextEntry是否为空，判断是否还有下一个元素供遍历
  public final boolean hasNext() { return nextEntry != null; }
  
  // 根据nextEntry是否为空，判断是否还有下一个元素供遍历
  public final boolean hasMoreElements() { return nextEntry != null; }

  /**
  * 调用ConcurrentHashMap的remove方法，按key移除元素。
  * 将lastReturned置为空。
  * 此时nextEntry
  */
  public final void remove() {
    if (lastReturned == null)
      throw new IllegalStateException();
    ConcurrentHashMap.this.remove(lastReturned.key);
    lastReturned = null;
  }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;entryiterator&#34;&gt;EntryIterator&lt;/h3&gt;

&lt;p&gt;继承自&lt;code&gt;HashIterator&lt;/code&gt;，并实现了Iterator接口，用于HashEntry的迭代遍历。EntryIterator重写了next方法，返回了一个WriteThroughEntry对象，该对象继承自AbstractMap.SimpleEntry，本质上是个Map.Entry。&lt;/p&gt;

&lt;p&gt;EntryIterator将在ConcurrentHashMap.EntrySet中起作用，为EntrySet类型提供迭代能力。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;final class EntryIterator 
  		extends HashIterator 
  		implements Iterator&amp;lt;Entry&amp;lt;K,V&amp;gt;&amp;gt; {
  	public Map.Entry&amp;lt;K,V&amp;gt; next() {
      HashEntry&amp;lt;K,V&amp;gt; e = super.nextEntry();
      return new WriteThroughEntry(e.key, e.value);
	}
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;keyiterator&#34;&gt;KeyIterator&lt;/h3&gt;

&lt;p&gt;继承自&lt;code&gt;HashIterator&lt;/code&gt;，并实现了Iterator接口，用于HashEntry的key的迭代遍历。KeyIterator重写了next方法，返回了当前HashEntry的key值。&lt;/p&gt;

&lt;p&gt;KeyIterator将在ConcurrentHashMap.KeySet中起作用，为KeySet类型提供迭代能力。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;final class KeyIterator 
  		extends HashIterator
        implements Iterator&amp;lt;K&amp;gt;, Enumeration&amp;lt;K&amp;gt; {
  public final K next()        { return super.nextEntry().key; }
  public final K nextElement() { return super.nextEntry().key; }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;valueiterator&#34;&gt;ValueIterator&lt;/h3&gt;

&lt;p&gt;继承自HashIterator，并实现了Iterator接口，用于HashEntry的值的迭代遍历。ValueIterator重写了next方法，返回了当前HashEntry的值。&lt;/p&gt;

&lt;p&gt;ValueIterator将在ConcurrentHashMap.Values中起作用，为Values类型提供迭代能力。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;final class ValueIterator
  extends HashIterator
  implements Iterator&amp;lt;V&amp;gt;, Enumeration&amp;lt;V&amp;gt; {
  public final V next()        { return super.nextEntry().value; }
  public final V nextElement() { return super.nextEntry().value; }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;writethroughentry&#34;&gt;WriteThroughEntry&lt;/h3&gt;

&lt;p&gt;&lt;code&gt;WriteThroughEntry&lt;/code&gt;里只有一个public方法setValue，将值写入map中。注意由于并发情况，可能不会是实时修改数据，故不能用于跟踪数据。该方法可以用于遍历时修改数据。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;final class WriteThroughEntry extends AbstractMap.SimpleEntry&amp;lt;K,V&amp;gt; {
  
  WriteThroughEntry(K k, V v) {
  	super(k,v);
  }

  public V setValue(V value) {
    if (value == null) throw new NullPointerException();
    V v = super.setValue(value);
    ConcurrentHashMap.this.put(getKey(), value);
    return v;
  }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;keyset&#34;&gt;KeySet&lt;/h3&gt;

&lt;p&gt;ConcurrentHashMap的KeySet类型用于定义按Key进行遍历的相关操作。其中，iterator()会实例化一个KeyIterator()，进而提供相关的迭代操作。其他的方法，则是通过ConcurrentHashMap的原生方法实现。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;final class KeySet extends AbstractSet&amp;lt;K&amp;gt; {
  public Iterator&amp;lt;K&amp;gt; iterator() {
  	return new KeyIterator();
  }
  public int size() {
  	return ConcurrentHashMap.this.size();
  }
  public boolean isEmpty() {
  	return ConcurrentHashMap.this.isEmpty();
  }
  public boolean contains(Object o) {
  	return ConcurrentHashMap.this.containsKey(o);
  }
  public boolean remove(Object o) {
  	return ConcurrentHashMap.this.remove(o) != null;
  }
  public void clear() {
  	ConcurrentHashMap.this.clear();
  }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;entryset&#34;&gt;EntrySet&lt;/h3&gt;

&lt;p&gt;ConcurrentHashMap的EntrySet类型用于定义按Entry进行遍历的相关操作。其中，iterator()会实例化一个EntryIterator()，进而提供相关的迭代操作。其他的方法，则是通过ConcurrentHashMap的原生方法实现。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;final class EntrySet extends AbstractSet&amp;lt;Map.Entry&amp;lt;K,V&amp;gt;&amp;gt; {
  public Iterator&amp;lt;Map.Entry&amp;lt;K,V&amp;gt;&amp;gt; iterator() {
  	return new EntryIterator();
  }
  public boolean contains(Object o) {
    if (!(o instanceof Map.Entry))
    	return false;
    Map.Entry&amp;lt;?,?&amp;gt; e = (Map.Entry&amp;lt;?,?&amp;gt;)o;
    V v = ConcurrentHashMap.this.get(e.getKey());
    return v != null &amp;amp;&amp;amp; v.equals(e.getValue());
  }
  public boolean remove(Object o) {
  	if (!(o instanceof Map.Entry))
  		return false;
  	Map.Entry&amp;lt;?,?&amp;gt; e = (Map.Entry&amp;lt;?,?&amp;gt;)o;
  	return ConcurrentHashMap.this.remove(e.getKey(), e.getValue());
  }
  public int size() {
  	return ConcurrentHashMap.this.size();
  }
  public boolean isEmpty() {
  	return ConcurrentHashMap.this.isEmpty();
  }
  public void clear() {
  	ConcurrentHashMap.this.clear();
  }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;values&#34;&gt;Values&lt;/h3&gt;

&lt;p&gt;ConcurrentHashMap的Values类型用于定义按Value进行遍历的相关操作。其中，iterator()会实例化一个ValueIterator()，进而提供相关的迭代操作。其他的方法，则是通过ConcurrentHashMap的原生方法实现。&lt;/p&gt;

&lt;p&gt;由于ConcurrentHashMap的值可以重复，因此Values类型继承自AbstractCollection，而不是集合Set。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;final class Values extends AbstractCollection&amp;lt;V&amp;gt; {
  public Iterator&amp;lt;V&amp;gt; iterator() {
  	return new ValueIterator();
  }
  public int size() {
  	return ConcurrentHashMap.this.size();
  }
  public boolean isEmpty() {
  	return ConcurrentHashMap.this.isEmpty();
  }
  public boolean contains(Object o) {
  	return ConcurrentHashMap.this.containsValue(o);
  }
  public void clear() {
  	ConcurrentHashMap.this.clear();
  }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;concurrenthashmap函数列表&#34;&gt;ConcurrentHashMap函数列表&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;// 创建一个带有默认初始容量 (16)、加载因子 (0.75) 和 concurrencyLevel (16) 的新的空映射。
ConcurrentHashMap()
// 创建一个带有指定初始容量、默认加载因子 (0.75) 和 concurrencyLevel (16) 的新的空映射。
ConcurrentHashMap(int initialCapacity)
// 创建一个带有指定初始容量、加载因子和默认 concurrencyLevel (16) 的新的空映射。
ConcurrentHashMap(int initialCapacity, float loadFactor)
// 创建一个带有指定初始容量、加载因子和并发级别的新的空映射。
ConcurrentHashMap(int initialCapacity, float loadFactor, int concurrencyLevel)
// 构造一个与给定映射具有相同映射关系的新映射。
ConcurrentHashMap(Map&amp;lt;? extends K,? extends V&amp;gt; m)

// 从该映射中移除所有映射关系
void clear()
// 一种遗留方法，测试此表中是否有一些与指定值存在映射关系的键。
boolean contains(Object value)
// 测试指定对象是否为此表中的键。
boolean containsKey(Object key)
// 如果此映射将一个或多个键映射到指定值，则返回 true。
boolean containsValue(Object value)
// 返回此表中值的枚举。
Enumeration&amp;lt;V&amp;gt; elements()
// 返回此映射所包含的映射关系的 Set 视图。
Set&amp;lt;Map.Entry&amp;lt;K,V&amp;gt;&amp;gt; entrySet()
// 返回指定键所映射到的值，如果此映射不包含该键的映射关系，则返回 null。
V get(Object key)
// 如果此映射不包含键-值映射关系，则返回 true。
boolean isEmpty()
// 返回此表中键的枚举。
Enumeration&amp;lt;K&amp;gt; keys()
// 返回此映射中包含的键的 Set 视图。
Set&amp;lt;K&amp;gt; keySet()
// 将指定键映射到此表中的指定值。
V put(K key, V value)
// 将指定映射中所有映射关系复制到此映射中。
void putAll(Map&amp;lt;? extends K,? extends V&amp;gt; m)
// 如果指定键已经不再与某个值相关联，则将它与给定值关联。
V putIfAbsent(K key, V value)
// 从此映射中移除键（及其相应的值）。
V remove(Object key)
// 只有目前将键的条目映射到给定值时，才移除该键的条目。
boolean remove(Object key, Object value)
// 只有目前将键的条目映射到某一值时，才替换该键的条目。
V replace(K key, V value)
// 只有目前将键的条目映射到给定值时，才替换该键的条目。
boolean replace(K key, V oldValue, V newValue)
// 返回此映射中的键-值映射关系数。
int size()
// 返回此映射中包含的值的 Collection 视图。
Collection&amp;lt;V&amp;gt; values()
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;concurrenthashmap重点函数&#34;&gt;ConcurrentHashMap重点函数&lt;/h2&gt;

&lt;h3 id=&#34;构造函数&#34;&gt;构造函数&lt;/h3&gt;

&lt;p&gt;ConcurrentHashMap有五个构造函数，重点分析下面这个构造函数。&lt;/p&gt;

&lt;p&gt;ConcurrentHashMap初始化是通过initialCapacity，loadFactor，concurrentLevel等参数来初始化Segment数组，段偏移量segmentShift，段掩码segmentMask和每个segment里的HashEntry数组。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public ConcurrentHashMap(int initialCapacity, float loadFactor, int concurrencyLevel) {
  // 参数检查
  if (!(loadFactor &amp;gt; 0) || initialCapacity &amp;lt; 0 || concurrencyLevel &amp;lt;= 0)
    throw new IllegalArgumentException();
  // 并发级别不能超过段的最大数量
  if (concurrencyLevel &amp;gt; MAX_SEGMENTS)
    concurrencyLevel = MAX_SEGMENTS;
  // Find power-of-two sizes best matching arguments
  int sshift = 0;
  int ssize = 1;
  while (ssize &amp;lt; concurrencyLevel) {
    ++sshift;
    ssize &amp;lt;&amp;lt;= 1;
  }
  this.segmentShift = 32 - sshift;
  this.segmentMask = ssize - 1;
  if (initialCapacity &amp;gt; MAXIMUM_CAPACITY)
    initialCapacity = MAXIMUM_CAPACITY;
  int c = initialCapacity / ssize;
  if (c * ssize &amp;lt; initialCapacity)
    ++c;
  int cap = MIN_SEGMENT_TABLE_CAPACITY;
  while (cap &amp;lt; c)
    cap &amp;lt;&amp;lt;= 1;
  // create segments and segments[0]
  Segment&amp;lt;K,V&amp;gt; s0 =
    new Segment&amp;lt;K,V&amp;gt;(loadFactor, (int)(cap * loadFactor),
                     (HashEntry&amp;lt;K,V&amp;gt;[])new HashEntry[cap]);
  Segment&amp;lt;K,V&amp;gt;[] ss = (Segment&amp;lt;K,V&amp;gt;[])new Segment[ssize];
  UNSAFE.putOrderedObject(ss, SBASE, s0); // ordered write of segments[0]
  this.segments = ss;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;segments数组的长度ssize通过concurrencyLevel计算得出。&lt;/strong&gt;为了能通过按位与的哈希算法来定位segments数组的索引，必须保证segments数组的长度是2的N次方（power-of-two size），所以必须计算出一个是大于或等于concurrencyLevel的最小的2的N次方值来作为segments数组的长度。假如concurrencyLevel等于14，15或16，ssize都会等于16，即容器里锁的个数也是16。注意concurrencyLevel的最大大小是65535，意味着segments数组的长度最大为65536，对应的二进制是16位，对应全局常量MAX_SEGMENTS = 1 &amp;lt;&amp;lt; 16。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;初始化segmentShift和segmentMask。&lt;/strong&gt; 这两个全局变量在定位segment时的哈希算法里需要使用，sshift等于ssize从1向左移位的次数，在默认情况下concurrencyLevel等于16，1需要向左移位移动4次，所以sshift等于4。segmentShift用于定位参与hash运算的位数，segmentShift等于32减sshift，所以等于28，这里之所以用32是因为ConcurrentHashMap里的hash()方法输出的最大数是32位的，后面的测试中我们可以看到这点。segmentMask是哈希运算的掩码，等于ssize减1，即15，掩码的二进制各个位的值都是1。因为ssize的最大长度是65536，所以segmentShift最大值是16，segmentMask最大值是65535，对应的二进制是16位，每个位都是1。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;初始化每个Segment。&lt;/strong&gt;输入参数initialCapacity是ConcurrentHashMap的初始化容量，loadfactor是每个segment的负载因子，在构造方法里需要通过这两个参数来初始化数组中的每个segment。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;初始化每个segment里HashEntry数组的长度cap&lt;/strong&gt;。cap等于initialCapacity除以ssize的倍数c，如果c大于1，就会取大于等于c的2的N次方值，所以cap不是1，就是2的N次方。segment的容量threshold＝(int)cap*loadFactor，默认情况下initialCapacity等于16，loadfactor等于0.75，通过运算cap等于1，threshold等于零。&lt;/p&gt;

&lt;h3 id=&#34;put-k-key-v-value&#34;&gt;put(K key, V value)&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public V put(K key, V value) {
  Segment&amp;lt;K,V&amp;gt; s;
  if (value == null)
  	throw new NullPointerException();
  int hash = hash(key);
  int j = (hash &amp;gt;&amp;gt;&amp;gt; segmentShift) &amp;amp; segmentMask;
  if ((s = (Segment&amp;lt;K,V&amp;gt;)UNSAFE.getObject          // nonvolatile; recheck
  	(segments, (j &amp;lt;&amp;lt; SSHIFT) + SBASE)) == null) //  in ensureSegment
  s = ensureSegment(j);
  return s.put(key, hash, value, false);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Segment内部类中的put方法：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;final V put(K key, int hash, V value, boolean onlyIfAbsent) {
	// tryLock(): 如果锁可用，则获取锁，并立即返回true，否则返回false。
	// scanAndLockForPut扫描指定key的节点，并获取锁，如果不存在就新建一个HashEntry。
	// 在scanAndLockForPut方法里，会循环执行MAX_SCAN_RETRIES次tryLock。
	// 如果还是没有获取到锁，则调用lock()方法使用CAS获取锁。
	// 总之，在node返回时，当前线程一定已经取到了当前segment的锁。
	HashEntry&amp;lt;K,V&amp;gt; node = tryLock() ? null : 
		scanAndLockForPut(key, hash, value);
	V oldValue;
	try {
        HashEntry&amp;lt;K,V&amp;gt;[] tab = table;
        int index = (tab.length - 1) &amp;amp; hash;
        HashEntry&amp;lt;K,V&amp;gt; first = entryAt(tab, index);
        for (HashEntry&amp;lt;K,V&amp;gt; e = first;;) {
        	if (e != null) {
        		K k;
        		if ((k = e.key) == key ||
        			(e.hash == hash &amp;amp;&amp;amp; key.equals(k))) {
        			oldValue = e.value;
        			if (!onlyIfAbsent) {
        				e.value = value;
        				++modCount;
                  }
                  break;
              }
              e = e.next;
            }
            else {
                if (node != null)
                    node.setNext(first);
                else
                    node = new HashEntry&amp;lt;K,V&amp;gt;(hash, key, value, first);
                int c = count + 1;
                if (c &amp;gt; threshold &amp;amp;&amp;amp; tab.length &amp;lt; MAXIMUM_CAPACITY)
                    rehash(node);
                else
                    setEntryAt(tab, index, node);
                ++modCount;
                count = c;
                oldValue = null;
                break;
            }
		}
    } finally {
    unlock();
    }
    return oldValue;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;put操作开始，首先定位到Segment，为了线程安全，锁定当前Segment；然后在Segment里进行插入操作，首先判断是否需要扩容，然后在定位添加元素的位置放在HashEntry数组里。&lt;/p&gt;

&lt;p&gt;扩容：在插入元素前会先判断Segment里的HashEntry数组是否超过容量（threshold），如果超过阀值，数组进行扩容。值得一提的是，Segment的扩容判断比HashMap更恰当，因为HashMap是在插入元素后判断元素是否已经到达容量的，如果到达了就进行扩容，但是很有可能扩容之后没有新元素插入，这时HashMap就进行了一次无效的扩容。&lt;/p&gt;

&lt;p&gt;扩容的时候首先会创建一个两倍于原容量的数组，然后将原数组里的元素进行再hash后插入到新的数组里。为了高效ConcurrentHashMap不会对整个容器进行扩容，而只对某个segment进行扩容。&lt;/p&gt;

&lt;h3 id=&#34;get-k-key&#34;&gt;get(K key)&lt;/h3&gt;

&lt;p&gt;在ConcurrentHashMap中get(K key)方法没有加锁，因此可能会读到其他线程put的新数据。这也是ConcurrentHashMap弱一致性的体现。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public V get(Object key) {
    Segment&amp;lt;K,V&amp;gt; s; // manually integrate access methods to reduce overhead
    HashEntry&amp;lt;K,V&amp;gt;[] tab;
    int h = hash(key);
    long u = (((h &amp;gt;&amp;gt;&amp;gt; segmentShift) &amp;amp; segmentMask) &amp;lt;&amp;lt; SSHIFT) + SBASE;
    if ((s = (Segment&amp;lt;K,V&amp;gt;)UNSAFE.getObjectVolatile(segments, u)) != null &amp;amp;&amp;amp;
        (tab = s.table) != null) {
        for (HashEntry&amp;lt;K,V&amp;gt; e = (HashEntry&amp;lt;K,V&amp;gt;) UNSAFE.getObjectVolatile
                 (tab, ((long)(((tab.length - 1) &amp;amp; h)) &amp;lt;&amp;lt; TSHIFT) + TBASE);
             e != null; e = e.next) {
            K k;
            if ((k = e.key) == key || (e.hash == h &amp;amp;&amp;amp; key.equals(k)))
                return e.value;
        }
    }
    return null;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;size&#34;&gt;size()&lt;/h3&gt;

&lt;p&gt;要统计整个ConcurrentHashMap里元素的大小，就必须统计所有Segment里元素的大小后求和。Segment里的全局变量count是一个volatile变量，那么在多线程场景下，我们是不是直接把所有Segment的count相加就可以得到整个ConcurrentHashMap大小了呢？不是的，虽然相加时可以获取每个Segment的count的最新值，但是拿到之后可能累加前使用的count发生了变化，那么统计结果就不准了。所以最安全的做法，是在统计size的时候把所有Segment的put，remove和clean方法全部锁住，但是这种做法显然非常低效。&lt;/p&gt;

&lt;p&gt;因为在累加count操作过程中，之前累加过的count发生变化的几率非常小，所以ConcurrentHashMap的做法是先尝试2次通过不锁住Segment的方式来统计各个Segment大小，如果统计的过程中，容器的count发生了变化，则再采用加锁的方式来统计所有Segment的大小。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public int size() {
  // Try a few times to get accurate count. On failure due to
  // continuous async changes in table, resort to locking.
  final Segment&amp;lt;K,V&amp;gt;[] segments = this.segments;
  int size;
  boolean overflow; // true if size overflows 32 bits
  long sum;         // sum of modCounts
  long last = 0L;   // previous sum
  int retries = -1; // first iteration isn&#39;t retry
  try {
    for (;;) {
        if (retries++ == RETRIES_BEFORE_LOCK) {
            for (int j = 0; j &amp;lt; segments.length; ++j)
                ensureSegment(j).lock(); // force creation
        }
        sum = 0L;
        size = 0;
        overflow = false;
        for (int j = 0; j &amp;lt; segments.length; ++j) {
            Segment&amp;lt;K,V&amp;gt; seg = segmentAt(segments, j);
            if (seg != null) {
            sum += seg.modCount;
            int c = seg.count;
            if (c &amp;lt; 0 || (size += c) &amp;lt; 0)
            overflow = true;
            }
        }
        if (sum == last)
          break;
      	last = sum;
    }
  } finally {
      if (retries &amp;gt; RETRIES_BEFORE_LOCK) {
          for (int j = 0; j &amp;lt; segments.length; ++j)
              segmentAt(segments, j).unlock();
      }
  }
  return overflow ? Integer.MAX_VALUE : size;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;putifabsent-k-key-v-value&#34;&gt;putIfAbsent(K key, V value)&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;// 如果key在容器中不存在则将其放入其中，否则donothing.
// 返回 null,表示确实不存在，并且value被成功放入
// 返回非 null, 表示 key 存在，返回值是key在容器中的当前值 。
public V putIfAbsent(K key, V value) {
  Segment&amp;lt;K,V&amp;gt; s;
  if (value == null)
    throw new NullPointerException();
  int hash = hash(key);
  int j = (hash &amp;gt;&amp;gt;&amp;gt; segmentShift) &amp;amp; segmentMask;
  if ((s = (Segment&amp;lt;K,V&amp;gt;)UNSAFE.getObject
       (segments, (j &amp;lt;&amp;lt; SSHIFT) + SBASE)) == null)
    s = ensureSegment(j);
  return s.put(key, hash, value, true);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;参考：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;a href=&#34;http://ifeve.com/concurrenthashmap-weakly-consistent/&#34;&gt;为什么ConcurrentHashMap是弱一致的&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://www.cnblogs.com/skywang12345/p/3498537.html&#34;&gt;JUC集合之ConcurrentHashMap&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://a-ray-of-sunshine.github.io/2016/08/01/%E5%B9%B6%E5%8F%91%E5%AE%B9%E5%99%A8-ConcurrentMap/&#34;&gt;并发容器-ConcurrentMap&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://cxis.me/2016/05/26/ConcurrentHashMap%E7%AE%80%E4%BB%8B/&#34;&gt;ConcurrentHashMap简介&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;
</description>
    </item>
    
    <item>
      <title>CopyOnWriteArraySet源码分析</title>
      <link>http://nituchao.com/post/juc.concurrent/copy-on-write-array-set/</link>
      <pubDate>Thu, 23 Feb 2017 18:26:27 +0800</pubDate>
      
      <guid>http://nituchao.com/post/juc.concurrent/copy-on-write-array-set/</guid>
      <description>

&lt;h2 id=&#34;一言&#34;&gt;一言&lt;/h2&gt;

&lt;p&gt;&lt;code&gt;CopyOnWriteArraySet&lt;/code&gt;是线程安全的无序集合，它是通过聚合了一个&lt;code&gt;CopyOnWriteArray&lt;/code&gt;成员变量来实现的。&lt;/p&gt;

&lt;h2 id=&#34;概要&#34;&gt;概要&lt;/h2&gt;

&lt;p&gt;&lt;code&gt;CopyOnWriteArraySet&lt;/code&gt;是线程安全的无序集合，可以将它理解成线程安全的HashSet。有意思的是，&lt;code&gt;CopyOnWriteArraySet&lt;/code&gt;和HashSet虽然都继承于共同的父类AbstractSet；但是，HashSet是通过&amp;rdquo;散列表(HashSet)&amp;ldquo;实现的，而CopyConWriteArraySet则是通过&amp;rdquo;动态数组(CopyOnWriteArrayList)&amp;ldquo;实现的，并不是散列表。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;CopyOnWriteArraySet&lt;/code&gt;具有以下特性：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;它最适合于具有以下特征的应用程序：Set 大小通常保持很小，只读操作远多于可变操作，需要在遍历期间防止线程间的冲突。&lt;/li&gt;
&lt;li&gt;它是线程安全的。它的线程安全通过volatile、互斥锁来实现。&lt;/li&gt;
&lt;li&gt;因为通常需要复制整个基础数组，所以可变操作（add()、set() 和 remove() 等等）的开销很大。&lt;/li&gt;
&lt;li&gt;迭代器支持hasNext(), next()等不可变操作，但不支持可变 remove()等 操作。&lt;/li&gt;
&lt;li&gt;使用迭代器进行遍历的速度很快，并且不会与其他线程发生冲突。在构造迭代器时，迭代器依赖于不变的数组快照。&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;本文基于JDK1.7.0_67。&lt;/p&gt;

&lt;h2 id=&#34;copyonwritearrayset原理&#34;&gt;CopyOnWriteArraySet原理&lt;/h2&gt;

&lt;p&gt;CopyOnWriteArraySet的数据结构，如下图所示：&lt;/p&gt;

&lt;p&gt;&lt;code&gt;图&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;说明&lt;/strong&gt;&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;CopyOnWriteArraySet继承于AbstractSet，这就意味着它是一个集合。&lt;/li&gt;
&lt;li&gt;CopyOnWriteArraySet聚合了一个CopyOnWriteArrayList对象，它是通过CopyOnWriteArrayList实现的。而CopyOnWriteArrayList本质是个动态数组队列，所以CopyOnWriteArraySet相当于通过动态数组实现的&amp;rdquo;集合&amp;rdquo;！&lt;/li&gt;
&lt;li&gt;CopyOnWriteArraySet不允许有重复元素。因此，CopyOnWriteArrayList额外提供了addIfAbsent()和addAllAbsent()这两个添加元素的API，通过这些API来添加元素时，只有当元素不存在时才执行添加操作。&lt;/li&gt;
&lt;li&gt;CopyOnWriteArraySet的&amp;rdquo;线程安全&amp;rdquo;机制是通过volatile和互斥锁来实现的。而它本身没有volatile变量和互斥锁，都是借由CopyOnWriteArrayList实现。&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&#34;copyonwritearrayset成员变量&#34;&gt;CopyOnWriteArraySet成员变量&lt;/h2&gt;

&lt;p&gt;CopyOnWriteArraySet只有下面一个成员变量&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;private final CopyOnWriteArrayList&amp;lt;E&amp;gt; al;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;说明:&lt;/strong&gt;&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;成员变量al是&lt;code&gt;final&lt;/code&gt;类型的，通过构造函数进行初始化后将不能再修改。&lt;/li&gt;
&lt;li&gt;成员变量al里的&lt;code&gt;添加/修改/删除&lt;/code&gt;操作都是通过互斥锁和volatile变量来保证现场安全的，因此，成员变量al不再用&lt;code&gt;volatile&lt;/code&gt;修饰，也不再额外声明可重入锁lock。&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&#34;copyonwritearrayset函数列表&#34;&gt;CopyOnWriteArraySet函数列表&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;// 创建一个空 set。
CopyOnWriteArraySet()
// 创建一个包含指定 collection 所有元素的 set。
CopyOnWriteArraySet(Collection&amp;lt;? extends E&amp;gt; c)

// 如果指定元素并不存在于此 set 中，则添加它。
boolean add(E e)
// 如果此 set 中没有指定 collection 中的所有元素，则将它们都添加到此 set 中。
boolean addAll(Collection&amp;lt;? extends E&amp;gt; c)
// 移除此 set 中的所有元素。
void clear()
// 如果此 set 包含指定元素，则返回 true。
boolean contains(Object o)
// 如果此 set 包含指定 collection 的所有元素，则返回 true。
boolean containsAll(Collection&amp;lt;?&amp;gt; c)
// 比较指定对象与此 set 的相等性。
boolean equals(Object o)
// 如果此 set 不包含任何元素，则返回 true。
boolean isEmpty()
// 返回按照元素添加顺序在此 set 中包含的元素上进行迭代的迭代器。
Iterator&amp;lt;E&amp;gt; iterator()
// 如果指定元素存在于此 set 中，则将其移除。
boolean remove(Object o)
// 移除此 set 中包含在指定 collection 中的所有元素。
boolean removeAll(Collection&amp;lt;?&amp;gt; c)
// 仅保留此 set 中那些包含在指定 collection 中的元素。
boolean retainAll(Collection&amp;lt;?&amp;gt; c)
// 返回此 set 中的元素数目。
int size()
// 返回一个包含此 set 所有元素的数组。
Object[] toArray()
// 返回一个包含此 set 所有元素的数组；返回数组的运行时类型是指定数组的类型。
&amp;lt;T&amp;gt; T[] toArray(T[] a)
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;copyonwritearrayset重点函数&#34;&gt;CopyOnWriteArraySet重点函数&lt;/h2&gt;

&lt;h3 id=&#34;构造函数&#34;&gt;构造函数&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public CopyOnWriteArraySet() {
        al = new CopyOnWriteArrayList&amp;lt;E&amp;gt;();
}
public CopyOnWriteArraySet(Collection&amp;lt;? extends E&amp;gt; c) {
        al = new CopyOnWriteArrayList&amp;lt;E&amp;gt;();
        al.addAllAbsent(c);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;CopyOnWriteArraySet允许初始化一个空的集合，也允许通过复制一个集合里的元素来进行初始化。本质上将，CopyOnWriteArraySet的初始化是通过初始化成员变量CopyOnWriteArrayList al来实现的。&lt;/p&gt;

&lt;h3 id=&#34;添加&#34;&gt;添加&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public boolean add(E e) {
        return al.addIfAbsent(e);
}

public boolean addAll(Collection&amp;lt;? extends E&amp;gt; c) {
        return al.addAllAbsent(c) &amp;gt; 0;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;CopyOnWriteArraySet不允许重复元素。因此，添加操作都是调用CopyOnWriteArrayList的&lt;code&gt;addIfAbsent&lt;/code&gt;方法或者&lt;code&gt;addAllAbsent&lt;/code&gt;方法实现的。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>CopyOnWriteArrayList源码分析</title>
      <link>http://nituchao.com/post/juc.concurrent/copy-on-write-array-list/</link>
      <pubDate>Thu, 23 Feb 2017 18:25:27 +0800</pubDate>
      
      <guid>http://nituchao.com/post/juc.concurrent/copy-on-write-array-list/</guid>
      <description>

&lt;h2 id=&#34;概述&#34;&gt;概述&lt;/h2&gt;

&lt;p&gt;CopyOnWriteArrayList相当于线程安全的ArrayList。和ArrayList一样，它是个可变数组；但是和ArrayList不同的是，它具有以下特性：
1. 它最适合于具有以下特征的应用程序：List大小通常保持很小，只读操作远多于可变操作，需要在遍历期间防止线程间的冲突。
2. 它是线程安全的。它的线程安全表现在两个方面，修改时使用锁进行同步，读取时使用数据快照。
3. 因为通常要复制整个基础数组，所以可变操作（add()、set()和remove()等操作）的开销很大。
4. 迭代器支持hasNext()、next等不可变操作，但不支持可变remove()等操作。
5. 使用迭代器进行遍历的速度很快，并且不会与其他线程发生冲突。在构造迭代器时，迭代器依赖于不变的数组快照。&lt;/p&gt;

&lt;p&gt;本文基于JDK1.7.0_67。&lt;/p&gt;

&lt;h2 id=&#34;copyonwritearraylist原理和数据结构&#34;&gt;CopyOnWriteArrayList原理和数据结构&lt;/h2&gt;

&lt;p&gt;CopyOnWriteArrayList的数据结构，如下图所示：&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;CopyOnWriteArrayList UML图&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;说明：
1. CopyOnWriteArrayList实现了List接口，因此可以认为它是一个有序的集合。
2. CopyOnWriteArrayList实现了RandomAccess接口，因此可以认为它的元素可以随机访问。
3. CopyOnWriteArrayList包含一个可重入锁Lock。每一个CopyOnWriteArrayList都和一个互斥锁lock绑定，通过lock，实现了对CopyOnWriteArrayList的互斥访问。
4. CopyOnWriteArrayList包含了成员array数组，这说明CopyOnWriteArrayList本质上通过数组实现的。而且，可存储的元素个数没有上限。&lt;/p&gt;

&lt;p&gt;下面从&amp;rdquo;动态数组&amp;rdquo;和&amp;rdquo;线程安全&amp;rdquo;两个方面进一步对CopyOnWriteArrayList的原理进行说明。
1. &lt;strong&gt;CopyOnWriteArrayList的&amp;rdquo;动态数组&amp;rdquo;机制&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;它内部有个&amp;rdquo;volatile数组&amp;rdquo;(array)来保持数据。在&amp;rdquo;添加/修改/删除&amp;rdquo;数据时，都会新建一个数组，并将更新后的数据拷贝到新建的数组中，最后再将该数组赋值给&amp;rdquo;volatile数组&amp;rdquo;。这就是它叫做CopyOnWriteArrayList的原因！&lt;/p&gt;

&lt;p&gt;CopyOnWriteArrayList就是通过这种方式实现的动态数组；不过正由于它在&amp;rdquo;添加/修改/删除&amp;rdquo;数据时，都会新建数组，所以涉及到修改数据的操作，CopyOnWriteArrayList效率很低。但是单单只是进行遍历的话，效率比较高。&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;CopyOnWriteArrayList的&amp;rdquo;线程安全&amp;rdquo;机制&lt;/strong&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;是通过volatile和互斥锁来实现的。
 a. CopyOnWriteArrayList是通过&amp;rdquo;volatile数组&amp;rdquo;来保存数据的。&lt;/p&gt;

&lt;p&gt;一个线程读取volatile数组时，总能看到其他线程对该volatile变量最后的写入。就这样，通过volatile提供了&amp;rdquo;读取到的数据总是最新的&amp;rdquo;这个机制的保证。
 b. CopyOnWriteArrayList通过互斥锁来保护数据。&lt;/p&gt;

&lt;p&gt;在&amp;rdquo;添加/修改/删除&amp;rdquo;数据时，会先&amp;rdquo;获取互斥锁&amp;rdquo;，在修改完毕后，先将数据更新到&amp;rdquo;volatile数组&amp;rdquo;中，然后再&amp;rdquo;释放互斥锁&amp;rdquo;；这样，就达到了保护数据的目的。&lt;/p&gt;

&lt;h2 id=&#34;copyonwritearraylist成员变量&#34;&gt;CopyOnWriteArrayList成员变量&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;/** 可重入锁，对数组进行添加/修改/删除操作时，通过lock来进行同步操作 */
transient final ReentrantLock lock = new ReentrantLock();

/** 数组，保存数据的地方。对数组array的操作都要通过getArray和setArray进行操作 */
private volatile transient Object[] array;
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;copyonwritearraylist函数列表&#34;&gt;CopyOnWriteArrayList函数列表&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;// 创建一个空列表，默认大小为0。
CopyOnWriteArrayList()
// 创建一个按 collection 的迭代器返回元素的顺序包含指定 collection 元素的列表。
CopyOnWriteArrayList(Collection&amp;lt;? extends E&amp;gt; c)
// 创建一个保存给定数组的副本的列表。 
CopyOnWriteArrayList(E[] toCopyIn)
// 将指定元素添加到此列表的尾部。
boolean add(E e)
// 在此列表的指定位置上插入指定元素。
void add(int index, E element)
// 按照指定 collection 的迭代器返回元素的顺序，将指定 collection 中的所有元素添加此列表的尾部。
boolean addAll(Collection&amp;lt;? extends E&amp;gt; c)
// 从指定位置开始，将指定 collection 的所有元素插入此列表。
boolean addAll(int index, Collection&amp;lt;? extends E&amp;gt; c)
// 按照指定 collection 的迭代器返回元素的顺序，将指定 collection 中尚未包含在此列表中的所有元素添加列表的尾部。
int addAllAbsent(Collection&amp;lt;? extends E&amp;gt; c)
// 添加元素（如果不存在）。
boolean addIfAbsent(E e)
// 从此列表移除所有元素。
void clear()
// 返回此列表的浅表副本。
Object clone()
// 如果此列表包含指定的元素，则返回 true。
boolean contains(Object o)
// 如果此列表包含指定 collection 的所有元素，则返回 true。
boolean containsAll(Collection&amp;lt;?&amp;gt; c)
// 比较指定对象与此列表的相等性。
boolean equals(Object o)
// 返回列表中指定位置的元素。
E get(int index)
// 返回此列表的哈希码值。
int hashCode()
// 返回第一次出现的指定元素在此列表中的索引，从 index 开始向前搜索，如果没有找到该元素，则返回 -1。
int indexOf(E e, int index)
// 返回此列表中第一次出现的指定元素的索引；如果此列表不包含该元素，则返回 -1。
int indexOf(Object o)
// 如果此列表不包含任何元素，则返回 true。
boolean isEmpty()
// 返回以恰当顺序在此列表元素上进行迭代的迭代器。
Iterator&amp;lt;E&amp;gt; iterator()
// 返回最后一次出现的指定元素在此列表中的索引，从 index 开始向后搜索，如果没有找到该元素，则返回 -1。
int lastIndexOf(E e, int index)
// 返回此列表中最后出现的指定元素的索引；如果列表不包含此元素，则返回 -1。
int lastIndexOf(Object o)
// 返回此列表元素的列表迭代器（按适当顺序）。
ListIterator&amp;lt;E&amp;gt; listIterator()
// 返回列表中元素的列表迭代器（按适当顺序），从列表的指定位置开始。
ListIterator&amp;lt;E&amp;gt; listIterator(int index)
// 移除此列表指定位置上的元素。
E remove(int index)
// 从此列表移除第一次出现的指定元素（如果存在）。
boolean remove(Object o)
// 从此列表移除所有包含在指定 collection 中的元素。
boolean removeAll(Collection&amp;lt;?&amp;gt; c)
// 只保留此列表中包含在指定 collection 中的元素。
boolean retainAll(Collection&amp;lt;?&amp;gt; c)
// 用指定的元素替代此列表指定位置上的元素。
E set(int index, E element)
// 返回此列表中的元素数。
int size()
// 返回此列表中 fromIndex（包括）和 toIndex（不包括）之间部分的视图。
List&amp;lt;E&amp;gt; subList(int fromIndex, int toIndex)
// 返回一个按恰当顺序（从第一个元素到最后一个元素）包含此列表中所有元素的数组。
Object[] toArray()
// 返回以恰当顺序（从第一个元素到最后一个元素）包含列表所有元素的数组；
// 返回数组的运行时类型是指定数组的运行时类型。
&amp;lt;T&amp;gt; T[] toArray(T[] a)
// 返回此列表的字符串表示形式。
String toString()
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;copyonwritearraylist重点函数&#34;&gt;CopyOnWriteArrayList重点函数&lt;/h2&gt;

&lt;h3 id=&#34;构造函数&#34;&gt;构造函数&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;// 初始化一个大小为0的对象数组
public CopyOnWriteArrayList() {
    setArray(new Object[0]);
}

// 使用一个集合里的元素来初始化一个对象数组
public CopyOnWriteArrayList(Collection&amp;lt;? extends E&amp;gt; c) {
    Object[] elements = c.toArray();
    if (elements.getClass() != Object[].class)
        elements = Arrays.copyOf(elements, elements.length, Object[].class);
    setArray(elements);
}

// 使用一个数组里元素来初始化一个对象数组
public CopyOnWriteArrayList(E[] toCopyIn) {
    setArray(Arrays.copyOf(toCopyIn, toCopyIn.length, Object[].class));
}

final Object[] getArray() {
    return array;
}

final void setArray(Object[] a) {
    array = a;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;CopyOnWriteArrayList的三个构造函数都调用了setArray()，将新创建的数组赋值给CopyOnWriteArrayList的成员变量array。&lt;/p&gt;

&lt;h3 id=&#34;添加&#34;&gt;添加&lt;/h3&gt;

&lt;h4 id=&#34;直接添加&#34;&gt;直接添加&lt;/h4&gt;

&lt;p&gt;以add(E e)为例来分析&lt;code&gt;CopyOnWriteArrayList&lt;/code&gt;的添加操作。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public boolean add(E e) {
    final ReentrantLock lock = this.lock;
    // 获取“锁”
    lock.lock();
    try {
        // 获取原始”volatile数组“中的数据和数据长度。
        Object[] elements = getArray();
        int len = elements.length;
        // 新建一个数组newElements，并将原始数据拷贝到newElements中；
        // newElements数组的长度=“原始数组的长度”+1
        Object[] newElements = Arrays.copyOf(elements, len + 1);
        // 将“新增加的元素”保存到newElements中。
        newElements[len] = e;
        // 将newElements赋值给”volatile数组“。
        setArray(newElements);
        return true;
    } finally {
        // 释放“锁”
        lock.unlock();
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;说明&lt;/strong&gt;：&lt;/p&gt;

&lt;p&gt;add(E e)的作用就是将数据e添加到”volatile数组“中。它的实现方式是，新建一个数组，接着将原始的”volatile数组“的数据拷贝到新数组中，然后将新增数据也添加到新数组中；最后，将新数组赋值给”volatile数组“。&lt;/p&gt;

&lt;p&gt;在add(E e)中有两点需要关注。&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;在”添加操作“开始前，获取独占锁(lock)，若此时有需要线程要获取锁，则必须等待；在操作完毕后，释放独占锁(lock)，此时其它线程才能获取锁。通过独占锁，来防止多线程同时修改数据！lock的定义如下：&lt;/li&gt;
&lt;/ol&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;transient final ReentrantLock lock = new ReentrantLock();
&lt;/code&gt;&lt;/pre&gt;

&lt;ol&gt;
&lt;li&gt;操作完毕时，会通过setArray()来更新”volatile数组“。而且，前面我们提过”即对一个volatile变量的读，总是能看到（任意线程）对这个volatile变量最后的写入“；这样，每次添加元素之后，其它线程都能看到新添加的元素。&lt;/li&gt;
&lt;/ol&gt;

&lt;h4 id=&#34;不重复添加&#34;&gt;不重复添加&lt;/h4&gt;

&lt;p&gt;由于CopyOnWriteArraySet是通过聚合了一个CopyOnWriteArrayList实现的，而CopyOnWriteArraySet是不包含重复元素的，因此CopyOnWriteArrayList提供了一个不添加重复元素的方法&lt;code&gt;addIfAbsent&lt;/code&gt;，该方法每次从头遍历数组，如果发现元素已经存在，则直接返回false，如果遍历后待添加元素不存在，则添加到新数组的末尾，然后将新数组设置为成员数组。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public boolean addIfAbsent(E e) {
        final ReentrantLock lock = this.lock;
        lock.lock();
        try {
            // Copy while checking if already present.
            // This wins in the most common case where it is not present
            Object[] elements = getArray();
            int len = elements.length;
            Object[] newElements = new Object[len + 1];
            for (int i = 0; i &amp;lt; len; ++i) {
                if (eq(e, elements[i]))
                    return false; // exit, throwing away copy
                else
                    newElements[i] = elements[i];
            }
            newElements[len] = e;
            setArray(newElements);
            return true;
        } finally {
            lock.unlock();
        }
    }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;有在检查待添加元素是否已经存在时要从头遍历数组，因此随着元素个数递增，该方法的效率线性下降。&lt;/p&gt;

&lt;h3 id=&#34;获取&#34;&gt;获取&lt;/h3&gt;

&lt;p&gt;以get(int index)为例，来对&lt;code&gt;CopyOnWriteArrayList&lt;/code&gt;的删除操作进行说明。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public E get(int index) {
    return get(getArray(), index);
}

private E get(Object[] a, int index) {
    return (E) a[index];
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;说明:&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;get(int index)的实现非常简单，就是返回&amp;rdquo;volatile数组&amp;rdquo;中的第index个元素。读取元素的过程不需要加锁，是读取时array的镜像。&lt;/p&gt;

&lt;h3 id=&#34;删除&#34;&gt;删除&lt;/h3&gt;

&lt;p&gt;以remove(int index)为例，来说明&lt;code&gt;CopyOnWriteArrayList&lt;/code&gt;的删除操作。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public E remove(int index) {
    final ReentrantLock lock = this.lock;
    // 获取“锁”
    lock.lock();
    try {
        // 获取原始”volatile数组“中的数据和数据长度。
        Object[] elements = getArray();
        int len = elements.length;
        // 获取elements数组中的第index个数据。
        E oldValue = get(elements, index);
        int numMoved = len - index - 1;
        // 如果被删除的是最后一个元素，则直接通过Arrays.copyOf()进行处理，而不需要新建数组。
        // 否则，新建数组，然后将”volatile数组中被删除元素之外的其它元素“拷贝到新数组中。
        // 最后，将新数组赋值给”volatile数组“。
        if (numMoved == 0)
            setArray(Arrays.copyOf(elements, len - 1));
        else {
            Object[] newElements = new Object[len - 1];
            System.arraycopy(elements, 0, newElements, 0, index);
            System.arraycopy(elements, index + 1, newElements, index,
                             numMoved);
            setArray(newElements);
        }
        return oldValue;
    } finally {
        // 释放“锁”
        lock.unlock();
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;说明&lt;/strong&gt;：&lt;/p&gt;

&lt;p&gt;remove(int index)的作用就是将”volatile数组“中第index个元素删除。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;em&gt;它的实现方式是，如果被删除的是最后一个元素，则直接通过Arrays.copyOf()进行处理，而不需要新建数组。&lt;/em&gt;&lt;/strong&gt;否则，新建数组，然后将”volatile数组中被删除元素之外的其它元素“拷贝到新数组中。最后，将新数组赋值给”volatile数组“。
和add(E e)一样，remove(int index)也是”在操作之前，获取独占锁；操作完成之后，释放独占是“；并且”在操作完成时，会通过将数据更新到volatile数组中“。&lt;/p&gt;

&lt;p&gt;remove操作没有检查index的合法性，有可能会抛出IndexOutOfBoundsExceptions&lt;/p&gt;

&lt;h3 id=&#34;遍历&#34;&gt;遍历&lt;/h3&gt;

&lt;p&gt;以&lt;code&gt;iterator()&lt;/code&gt;为例，来说明&lt;code&gt;CopyOnWriteArrayList&lt;/code&gt;的遍历操作。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public Iterator&amp;lt;E&amp;gt; iterator() {
  return new COWIterator&amp;lt;E&amp;gt; (getArray(), 0);
}

private static class COWIterator&amp;lt;E&amp;gt; implements ListIterator&amp;lt;E&amp;gt; {
    private final Object[] snapshot;
    private int cursor;

    private COWIterator(Object[] elements, int initialCursor) {
        cursor = initialCursor;
        snapshot = elements;
    }

    public boolean hasNext() {
        return cursor &amp;lt; snapshot.length;
    }

    public boolean hasPrevious() {
        return cursor &amp;gt; 0;
    }

    // 获取下一个元素
    @SuppressWarnings(&amp;quot;unchecked&amp;quot;)
    public E next() {
        if (!hasNext())
            throw new NoSuchElementException();
        return (E) snapshot[cursor++];
    }

    // 获取上一个元素
    @SuppressWarnings(&amp;quot;unchecked&amp;quot;)
    public E previous() {
        if (!hasPrevious())
            throw new NoSuchElementException();
        return (E) snapshot[--cursor];
    }

    public int nextIndex() {
        return cursor;
    }

    public int previousIndex() {
        return cursor-1;
    }

    public void remove() {
        throw new UnsupportedOperationException();
    }

    public void set(E e) {
        throw new UnsupportedOperationException();
    }

    public void add(E e) {
        throw new UnsupportedOperationException();
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;说明&lt;/strong&gt;：&lt;/p&gt;

&lt;p&gt;COWIterator不支持修改元素的操作。例如，对于&lt;code&gt;remove()&lt;/code&gt;,&lt;code&gt;set()&lt;/code&gt;,&lt;code&gt;add()&lt;/code&gt;等操作，&lt;code&gt;COWIterator&lt;/code&gt;都会抛出异常！
另外，需要提到的一点是，CopyOnWriteArrayList返回迭代器不会抛出&lt;code&gt;ConcurrentModificationException&lt;/code&gt;异常，即它不是fail-fast机制的！&lt;/p&gt;

&lt;p&gt;参考：&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;http://www.cnblogs.com/skywang12345/p/3498483.html&#34;&gt;Java多线程系列之CopyOnWriteArrayList&lt;/a&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>JVM行为相关的配置参数</title>
      <link>http://nituchao.com/post/2016/jvm-xing-wei-xiang-guan-de-pei-zhi-can-shu/</link>
      <pubDate>Thu, 29 Dec 2016 13:53:12 +0800</pubDate>
      
      <guid>http://nituchao.com/post/2016/jvm-xing-wei-xiang-guan-de-pei-zhi-can-shu/</guid>
      <description>&lt;p&gt;文本将分析与JVM行为相关的配置参数。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>JVM G1收集器配置参数</title>
      <link>http://nituchao.com/post/2016/jvm-g1-shou-ji-qi-pei-zhi-can-shu/</link>
      <pubDate>Thu, 29 Dec 2016 12:22:12 +0800</pubDate>
      
      <guid>http://nituchao.com/post/2016/jvm-g1-shou-ji-qi-pei-zhi-can-shu/</guid>
      <description>&lt;p&gt;G1收集器配置参数&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>JVM常用的非标准配置参数</title>
      <link>http://nituchao.com/post/2016/jvm-chan-yong-de-fei-biao-zhun-pei-zhi-can-shu/</link>
      <pubDate>Thu, 29 Dec 2016 10:18:12 +0800</pubDate>
      
      <guid>http://nituchao.com/post/2016/jvm-chan-yong-de-fei-biao-zhun-pei-zhi-can-shu/</guid>
      <description>&lt;p&gt;本文将研究JVM常见常见的非标准配置参数。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>JVM性能相关的配置参数</title>
      <link>http://nituchao.com/post/2016/jvm-xing-neng-xiang-guan-de-pei-zhi-can-shu/</link>
      <pubDate>Thu, 29 Dec 2016 09:30:12 +0800</pubDate>
      
      <guid>http://nituchao.com/post/2016/jvm-xing-neng-xiang-guan-de-pei-zhi-can-shu/</guid>
      <description>&lt;p&gt;本问将介绍JVM性能相关的配置参数。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>JVM配置参数-X与-XX的区别</title>
      <link>http://nituchao.com/post/2016/jvm-options-x-vs-xx/</link>
      <pubDate>Wed, 28 Dec 2016 13:14:12 +0800</pubDate>
      
      <guid>http://nituchao.com/post/2016/jvm-options-x-vs-xx/</guid>
      <description>

&lt;p&gt;启动JVM时通过指定配置参数来指导虚拟机按照我们的要求提供服务，这一点对大多数的Java程序员来说已经是司空见惯。&lt;/p&gt;

&lt;p&gt;在指定配置参数时，会有-X和-XX两种形式，那么它们两者有什么区别呢，今天我想借这篇文章总结一下。&lt;/p&gt;

&lt;p&gt;下面是我们的某个Java项目在正式环境上启动JVM时的一个典型命令，在该命令中指定了各种启动参数：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;java -Xmx15G \
-Xms10G \
-Xmn3G \
-Xss512k \
-XX:MaxPermSize=512M \
-XX:PermSize=512M \
-XX:+PrintFlagsFinal \
-XX:MaxTenuringThreshold=1 \
-XX:SurvivorRatio=23 \
-XX:TargetSurvivorRatio=80 \
-Xnoclassgc \
-XX:+UseParNewGC \
-XX:+UseConcMarkSweepGC \
-XX:CMSInitiatingOccupancyFraction=80 \
-XX:ParallelGCThreads=24 \
-XX:ConcGCThreads=24 \
-XX:+CMSParallelRemarkEnabled \
-XX:+CMSScavengeBeforeRemark \
-XX:+ExplicitGCInvokesConcurrent \
-XX:+UseTLAB \
-XX:TLABSize=64K, -verbose:gc \
-XX:+PrintGCDetails \
-XX:+PrintGCDateStamps \
-XX:+PrintGCTimeStamps \
-XX:+PrintGCApplicationStoppedTime \
-Xloggc:./gc.log
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Java HotSpot VM的官方文档中将启动参数分为如下两类：&lt;/p&gt;

&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th align=&#34;center&#34;&gt;配置 参数&lt;/th&gt;
&lt;th align=&#34;center&#34;&gt;类型&lt;/th&gt;
&lt;th align=&#34;left&#34;&gt;说明&lt;/th&gt;
&lt;th align=&#34;center&#34;&gt;举例&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;

&lt;tbody&gt;
&lt;tr&gt;
&lt;td align=&#34;center&#34;&gt;-X&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;non-standard&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;非标准参数。&lt;br/&gt;&lt;br/&gt;这些参数不是虚拟机规范规定的。因此，不是所有VM的实现(如:HotSpot,JRockit,J9等)都支持这些配置参数。&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;-Xmx、-Xms、-Xmn、-Xss&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;center&#34;&gt;-XX&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;not-stable&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;不稳定参数。&lt;br/&gt;&lt;br/&gt;这些参数是虚拟机规范中规定的。这些参数指定虚拟机实例在运行时的各种行为，从而对虚拟机的运行时性能有很大影响。&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;-XX:SurvivorRatio、-XX:+UseParNewGc&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;补充: -X和-XX两种参数都可能随着JDK版本的变更而发生变化，有些参数可以能会被废弃掉，有些参数的功能会发生改变，但是JDK官方不会通知开发者这些变化，需要使用者注意。&lt;/p&gt;

&lt;p&gt;-XX参数被称为不稳定参数，是因为这类参数的设置会引起JVM运行时性能上的差异，配置得当可以提高JVM性能，配置不当则会使JVM出现各种问题, 甚至造成JVM崩溃。&lt;/p&gt;

&lt;p&gt;国外有个哥们从HotSpot VM的源码里发现了934个此类型的配置参数，因此能对JVM做出很多组合配置，对JVM的调优也没有统一的标准，需要我们在实践中不断总结经验，并结合实际业务来进行操作，最终找到最适合当前业务的那些配置。&lt;/p&gt;

&lt;h2 id=&#34;一些有用的-xx配置&#34;&gt;一些有用的-XX配置&lt;/h2&gt;

&lt;p&gt;对于-XX类型的配置选项，虚拟机规范有一些惯例，针对不同的平台虚拟机也会提供不同的默认值。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;对于布尔(Boolean)类型的配置选项，通过&lt;code&gt;-XX:+&amp;lt;option&amp;gt;&lt;/code&gt;来开启，通过&lt;code&gt;-XX:-&amp;lt;option&amp;gt;&lt;/code&gt;来关闭。&lt;/li&gt;
&lt;li&gt;对于数字(Numberic)类型的配置选项，通过&lt;code&gt;-XX:&amp;lt;option&amp;gt;=&amp;lt;number&amp;gt;&lt;/code&gt;来配置。&lt;code&gt;&amp;lt;number&amp;gt;&lt;/code&gt;后面可以携带单位字母，比如: &amp;lsquo;k&amp;rsquo;或者&amp;rsquo;K&amp;rsquo;代表千字节，&amp;rsquo;m&amp;rsquo;或者&amp;rsquo;M&amp;rsquo;代表兆字节，&amp;rsquo;g&amp;rsquo;或者&amp;rsquo;G&amp;rsquo;代表千兆字节。&lt;/li&gt;
&lt;li&gt;对于字符串(String)类型的配置选项，通过&lt;code&gt;-XX:&amp;lt;option&amp;gt;=&amp;lt;string&amp;gt;&lt;/code&gt;来配置。这种配置通过用来指定文件，路径或者命令列表。&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;参考文献&#34;&gt;参考文献&lt;/h2&gt;

&lt;p&gt;1, &lt;a href=&#34;http://jvm-options.tech.xebia.fr/&#34;&gt;JVM Options - The complete reference&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;2, &lt;a href=&#34;http://www.oracle.com/technetwork/java/javase/tech/vmoptions-jsp-140102.html&#34;&gt;Java HotSpot VM Options&lt;/a&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Java通过信号量机制实现生产者消费者</title>
      <link>http://nituchao.com/post/2016/java-xin-hao-liang-ji-zhi-shi-xian-sheng-chan-zhe-xiao-fei-zhe/</link>
      <pubDate>Tue, 27 Dec 2016 16:12:12 +0800</pubDate>
      
      <guid>http://nituchao.com/post/2016/java-xin-hao-liang-ji-zhi-shi-xian-sheng-chan-zhe-xiao-fei-zhe/</guid>
      <description>

&lt;p&gt;信号量是一种计数器，用来保护一个或者多个共享资源的访问。Java提供了Semaphore类来实现信号量机制。&lt;/p&gt;

&lt;p&gt;如果线程要访问一个共享资源，它必须先获得信号量。如果信号量的内部计数器大于0，信号量将减1，然后允许访问这个共享资源。计数器大于0意味着有可以使用的资源，因此线程将被允许使用其中一个资源。&lt;/p&gt;

&lt;p&gt;否则，如果信号量的计数器等于0，信号量将会把线程置入休眠直至计数器大于0.计数器等于0的时候意味着所有的共享资源已经被其他线程使用了，所以需要访问这个共享资源的线程必须等待。&lt;/p&gt;

&lt;p&gt;当线程使用完某个共享资源时，信号量必须被释放，以便其他线程能够访问共享资源。释放操作将使信号量的内部计数器增加1。&lt;/p&gt;

&lt;h3 id=&#34;设计思想&#34;&gt;设计思想&lt;/h3&gt;

&lt;p&gt;为了使用信号量机制来实现生产者VS消费者模型，我们需要实例化一个二进制信号量对象，即内部计数器只有0和1两个值。多个生产者线程和多个消费者线程竞争这个信号量来互斥访问共享缓冲区。&lt;/p&gt;

&lt;p&gt;另外，由于共享缓冲区是有空间限制的，生产者在生产前要判断共享缓冲区空间是否充足。消费者在消费前要判断共享缓冲区内的元素是否足够消费。&lt;/p&gt;

&lt;h3 id=&#34;代码实现&#34;&gt;代码实现&lt;/h3&gt;

&lt;p&gt;基于上面的设计思想，我们需要实现共享缓冲区，生产者线程，消费者线程和主程序四部分。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;共享缓冲区&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;package com.nituchao.jvm.prosumer.semaphore;

import java.util.ArrayList;
import java.util.List;
import java.util.concurrent.Semaphore;

/**
 * 缓冲区
 * Created by liang on 2016/12/29.
 */
public class Buffer {
    private int MAX_SIZE = 100;
    private final List&amp;lt;String&amp;gt; list;
    private final Semaphore semaphore;

    public Buffer() {
        this.list = new ArrayList&amp;lt;&amp;gt;();
        this.semaphore = new Semaphore(1);
    }

    /**
     * 生产Buffer元素
     *
     * @param num
     */
    public boolean BufferProduct(int num) {
        boolean result = true;

        try {
            // 获取信号量
            semaphore.acquire();

            // 如果缓冲区能够容纳要生成的元素，允许生产
            if (list.size() + num &amp;lt;= MAX_SIZE) {
                // 开始生产
                for (int i = 1; i &amp;lt;= num; i++) {
                    list.add(0, Thread.currentThread().getName() + &amp;quot; : &amp;quot; + i);
                }

                result = true;

                System.out.printf(&amp;quot;Thread %s: Buffer Product succ, num is %d, buffer size is %d\n&amp;quot;, Thread.currentThread().getName(), num, list.size());
            } else {
                // 缓冲区无法容纳要生成的元素，禁止生产
                result = false;

                System.out.printf(&amp;quot;Thread %s: Buffer Product fail, num is %d, buffer size is %d\n&amp;quot;, Thread.currentThread().getName(), num, list.size());
            }
        } catch (InterruptedException e) {
            e.printStackTrace();
        } finally {
            semaphore.release();
        }

        return result;
    }

    /**
     * 消费Buffer元素
     *
     * @param num
     * @return
     */
    public boolean BufferConsume(int num) {
        boolean result = true;

        try {
            // 获取信号量
            semaphore.acquire();

            // 如果缓冲区中有足够的元素消费，允许消费
            if (list.size() - num &amp;gt;= 0) {
                // 开始消费
                for (int i = 1; i &amp;lt;= num; i++) {
                    String element = list.remove(0);
                }

                result = true;

                System.out.printf(&amp;quot;Thread: %s, Buffer Consume succ, num is %d, buffer size is %d\n&amp;quot;, Thread.currentThread().getName(), num, list.size());
            } else {
                // 缓冲取没有足够的元素供消费，禁止消费
                result = false;

                System.out.printf(&amp;quot;Thread: %s, Buffer Consume fail, num is %d, buffer size is %d\n&amp;quot;, Thread.currentThread().getName(), num, list.size());
            }
        } catch (InterruptedException e) {
            e.printStackTrace();
        } finally {
            semaphore.release();
        }

        return result;
    }
}

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;生产者线程&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;package com.nituchao.jvm.prosumer.semaphore;

import java.util.Random;
import java.util.concurrent.TimeUnit;

/**
 * 生产者线程
 * Created by liang on 2016/12/29.
 */
public class BufferProducer implements Runnable {
    private Buffer buffer;
    private int num;

    public BufferProducer(Buffer buffer, int num) {
        this.buffer = buffer;
        this.num = num;
    }

    @Override
    public void run() {
        while (!buffer.BufferProduct(num)) {
            try {
                TimeUnit.MILLISECONDS.sleep(new Random(1000).nextInt());
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
        }
    }
}


&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;消费者线程&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;package com.nituchao.jvm.prosumer.semaphore;

import java.util.Random;
import java.util.concurrent.TimeUnit;

/**
 * 消费者线程
 * Created by liang on 2016/12/29.
 */
public class BufferConsumer implements Runnable {
    private Buffer buffer;
    private int num;

    public BufferConsumer(Buffer buffer, int num) {
        this.buffer = buffer;
        this.num = num;
    }

    @Override
    public void run() {
        while (!buffer.BufferConsume(num)) {
            try {
                TimeUnit.MILLISECONDS.sleep(new Random(1000).nextInt());
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
        }
    }
}

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;主程序&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;package com.nituchao.jvm.prosumer.semaphore;

/**
 * 主程序
 * Created by liang on 2016/12/29.
 */
public class BufferMain {

    public static void main(String[] args) {
        int num = 10;

        // 初始化Buffer对象
        Buffer buffer = new Buffer();

        // 实例化num个生产者和消费者线程
        Thread[] threadProducers = new Thread[num];
        Thread[] threadConsumers = new Thread[num];

        for (int i = 0; i &amp;lt; num; i++) {
            threadProducers[i] = new Thread(new BufferProducer(buffer, i + 1));
            threadConsumers[i] = new Thread(new BufferConsumer(buffer, i + 1));
        }

        // 分别启动生产者和消费者线程
        for (int i = 0; i &amp;lt; num; i++) {
            // 故意先开始消费
            threadConsumers[i].start();

            // 故意后开始生产
            threadProducers[i].start();
        }
    }
}

&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;运行结果&#34;&gt;运行结果&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;Connected to the target VM, address: &#39;127.0.0.1:61012&#39;, transport: &#39;socket&#39;
Thread: Thread-1, Buffer Consume fail, num is 1, buffer size is 0
Thread Thread-0: Buffer Product succ, num is 1, buffer size is 1
Thread: Thread-3, Buffer Consume fail, num is 2, buffer size is 1
Thread Thread-2: Buffer Product succ, num is 2, buffer size is 3
Thread: Thread-5, Buffer Consume succ, num is 3, buffer size is 0
Thread Thread-4: Buffer Product succ, num is 3, buffer size is 3
Thread: Thread-7, Buffer Consume fail, num is 4, buffer size is 3
Thread: Thread-7, Buffer Consume fail, num is 4, buffer size is 3
Thread: Thread-7, Buffer Consume fail, num is 4, buffer size is 3
Thread: Thread-7, Buffer Consume fail, num is 4, buffer size is 3
Thread: Thread-7, Buffer Consume fail, num is 4, buffer size is 3
Thread: Thread-7, Buffer Consume fail, num is 4, buffer size is 3
Thread Thread-6: Buffer Product succ, num is 4, buffer size is 7
Thread: Thread-9, Buffer Consume succ, num is 5, buffer size is 2
Thread Thread-8: Buffer Product succ, num is 5, buffer size is 7
Thread: Thread-11, Buffer Consume succ, num is 6, buffer size is 1
Thread Thread-10: Buffer Product succ, num is 6, buffer size is 7
Thread: Thread-13, Buffer Consume succ, num is 7, buffer size is 0
Thread Thread-12: Buffer Product succ, num is 7, buffer size is 7
Thread: Thread-15, Buffer Consume fail, num is 8, buffer size is 7
Thread: Thread-15, Buffer Consume fail, num is 8, buffer size is 7
Thread: Thread-15, Buffer Consume fail, num is 8, buffer size is 7
Thread: Thread-15, Buffer Consume fail, num is 8, buffer size is 7
Thread: Thread-15, Buffer Consume fail, num is 8, buffer size is 7
Thread Thread-14: Buffer Product succ, num is 8, buffer size is 15
Thread: Thread-17, Buffer Consume succ, num is 9, buffer size is 6
Thread Thread-16: Buffer Product succ, num is 9, buffer size is 15
Thread: Thread-19, Buffer Consume succ, num is 10, buffer size is 5
Thread Thread-18: Buffer Product succ, num is 10, buffer size is 15
Thread: Thread-3, Buffer Consume succ, num is 2, buffer size is 13
Thread: Thread-1, Buffer Consume succ, num is 1, buffer size is 12
Thread: Thread-7, Buffer Consume succ, num is 4, buffer size is 8
Thread: Thread-15, Buffer Consume succ, num is 8, buffer size is 0
Disconnected from the target VM, address: &#39;127.0.0.1:61012&#39;, transport: &#39;socket&#39;

Process finished with exit code 0
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;工作原理&#34;&gt;工作原理&lt;/h3&gt;

&lt;p&gt;主程序首先实例化一个二进制信号量对象semaphore，指定该信号量内部计数器只有0和1，这样可以保证同一时间只有一个线程能够访问共享缓冲区。这样一来，共享缓冲区buffer本质上就成为一个队列。&lt;/p&gt;

&lt;p&gt;主程序实例化num个生产者线程和num个消费者线程。&lt;/p&gt;

&lt;p&gt;生产者线程负责向缓冲区里生产元素，每个生产者生产的数量都各不相同，从而能更好的观察效果。生产者首先会去尝试获取信号量(acquire)，然后检查当前共享缓冲区是否有足够空间容纳自己可生产的元素。如果有，则进行生产，如果没有，则不进行生产。最后，释放信号量(release)并把生产的结果返回(boolen)。生产者线程如果发现自己生产失败，则会随机休眠一段时间再重复上面的操作，直到生产操作成功。&lt;/p&gt;

&lt;p&gt;消费者线程负责从缓冲区里消费元素，每个消费者消费的数量都各不相同，从而能更好的观察效果。消费者首先回去尝试获取信号量(acquire)，然后检查当前共享缓冲区中是否有足够的元素供自己消费。如果有，则进行消费，如果没有，则不进行消费。最后，释放信号量(release)并把消费的结果返回(boolean)。消费者线程如果发现自己消费失败，则会随机休眠一段时间再重复上面的操作，直到消费操作成功。&lt;/p&gt;

&lt;p&gt;生产者线程和消费者线程访问是信号量是公平竞争，第一个获取信号量的线程将能够访问临界区，其余的线程将被信号量阻塞，直到信号量被释放。一旦信号量被释放，被被阻塞的线程就可以重新竞争信号量并访问临界区。&lt;/p&gt;
</description>
    </item>
    
  </channel>
</rss>