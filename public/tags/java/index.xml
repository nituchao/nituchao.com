<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Java on 泥土巢</title>
    <link>http://nituchao.com/tags/java/</link>
    <description>Recent content in Java on 泥土巢</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh-CN</language>
    <copyright>Copyright (c) 2017, nituchao | All rights reserved.</copyright>
    <lastBuildDate>Tue, 28 Feb 2017 19:01:58 +0800</lastBuildDate>
    
	<atom:link href="http://nituchao.com/tags/java/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>jstack命令</title>
      <link>http://nituchao.com/post/2017/tong-guo-jstack-fen-xi/</link>
      <pubDate>Tue, 28 Feb 2017 19:01:58 +0800</pubDate>
      
      <guid>http://nituchao.com/post/2017/tong-guo-jstack-fen-xi/</guid>
      <description>Java程序在操作系统上是以单进程、多线程的形式运行。
[work@zc-stage1-miui-sec02 ~]$ jstack Usage: jstack [-l] &amp;lt;pid&amp;gt; (to connect to running process) jstack -F [-m] [-l] &amp;lt;pid&amp;gt; (to connect to a hung process) jstack [-m] [-l] &amp;lt;executable&amp;gt; &amp;lt;core&amp;gt; (to connect to a core file) jstack [-m] [-l] [server_id@]&amp;lt;remote server IP or hostname&amp;gt; (to connect to a remote debug server) Options: -F to force a thread dump. Use when jstack &amp;lt;pid&amp;gt; does not respond (process is hung) -m to print both java and native frames (mixed mode) -l long listing.</description>
    </item>
    
    <item>
      <title>解决Java进程占用CPU过高的问题</title>
      <link>http://nituchao.com/post/2017/ji-lu-yi-ci-cpu-guo-gao-chu-li/</link>
      <pubDate>Tue, 28 Feb 2017 09:16:18 +0800</pubDate>
      
      <guid>http://nituchao.com/post/2017/ji-lu-yi-ci-cpu-guo-gao-chu-li/</guid>
      <description></description>
    </item>
    
    <item>
      <title>Atomic变量</title>
      <link>http://nituchao.com/post/juc.atomic/atomic-summary/</link>
      <pubDate>Thu, 23 Feb 2017 18:39:27 +0800</pubDate>
      
      <guid>http://nituchao.com/post/juc.atomic/atomic-summary/</guid>
      <description>Java原子变量的诞生源自一个简单的需求 —— 多个线程共享某个变量或者对象时，需要对修改和读取操作进行同步。
同步包含两层含义：
 互斥访问 可见性  通常，多线程对临界资源的互斥访问通过对象锁(synchronized关键字)保证。对象锁是一种独占锁（悲观锁），会导致其它所有需要锁的线程挂起。而可见性则由volatile的内存语义保证。
Java 1.5开始提供了原子变量和原子引用，这些类放置在java.util.concurrent下。大概可以归为4类：
 基本类型：AtomicInteger, AtomicLong, AtomicBoolean; 数组类型：AtomicIntegerArray, AtomicLongArray, AtomicReferenceArray; 引用类型：AtomicReference, AtomicStampedReference, AtomicMarkableReference; 对象的属性修改类型：AtomicIntegerFieldUpdater, AtomicLongFieldUpdater, AtomicReferenceFieldUpdater;  Java原子变量的存在是为了对相应的数据进行原子操作。
所谓的原子操作包含下面几层含义：
 操作过程不会被中断。 操作过程不会被阻塞。 修改结果被其他线程可见。  </description>
    </item>
    
    <item>
      <title>Java锁之Unsafe类的理解</title>
      <link>http://nituchao.com/post/juc.lock/java-unsafe/</link>
      <pubDate>Thu, 23 Feb 2017 18:39:27 +0800</pubDate>
      
      <guid>http://nituchao.com/post/juc.lock/java-unsafe/</guid>
      <description>一言 sun.misc.Unsafe类是超越Java的存在，它违反了Java在内存管理上的设计初衷，却又是Java很多重要特性与功能得以实现的基础，它使Java的安全性受到威胁，却有使Java在很多方面的性能得到提升，它是魔鬼与天使的混合体。
概述 Java是一个安全的开发工具，它阻止开发人员犯很低级的错误，而大部分的错误都是基于内存管理的。Unsafe类突破了Java原生的内存管理体制，使用Unsafe类可以在系统内存的任意地址进行读写数据，而这些操作对于普通用户来说是非常危险的，Unsafe的操作粒度不是类，而是数据和地址。
从另一方讲，Java正被广泛应用于游戏服务器和高频率的交易应用。这些之所以能够实现主要归功于Java提供的这个非常便利的类sun.mics.Unsafe。Unsafe类为了速度，在Java严格的安全标准方法做了一些妥协。
Java在JUC包中提供了对sun.misc.Unsafe类的封装实现，这就是java.util.concurrent.LockSupport。
本文基于JDK1.7.0_67
 java version &amp;ldquo;1.7.067&amp;rdquo;
_Java&amp;trade; SE Runtime Environment (build 1.7.0_67-b01)
Java HotSpot&amp;trade; 64-Bit Server VM (build 24.65-b04, mixed mode)
 重要函数 sun.mics.Unsafe一共提供了106个函数，这些函数涵盖了以下五个方面的功能：
 对变量和数组内容的原子访问，自定义内存屏障 对序列化的支持 自定义内存管理/高效的内存布局 与原生代码和其他JVM进行互操作 对高级锁的支持  获取实例 sun.misc.Unsafe只有一个无参的私有构造函数，要想实例化sun.misc.Unsafe可以调用getUnsafe()方法。
@CallerSensitive public static Unsafe getUnsafe() { Class var0 = Reflection.getCallerClass(); if(var0.getClassLoader() != null) { throw new SecurityException(&amp;quot;Unsafe&amp;quot;); } else { return theUnsafe; } }  出于安全考虑，Unsafe类只能被系统类加载器实例化，否则会抛出SecurityException异常。普通用户如果想实例化sun.misc.Unsafe类的对象，需要通过类反射机制或者修改Java的安全策略。
内存操作 获取成员变量偏移量 // 返回对象中指定静态成员变量的内存偏移量(相对于类存储) public native long staticFieldOffset(Field f); // 返回对象中指定成员变量的内存偏移量(相对于对象实例) public native long objectFieldOffset(Field f); // 返回对象中指定成员变量 public native Object staticFieldBase(Field f);  sun.</description>
    </item>
    
    <item>
      <title>AtomicLong源码分析</title>
      <link>http://nituchao.com/post/juc.atomic/atomic-long/</link>
      <pubDate>Thu, 23 Feb 2017 18:30:28 +0800</pubDate>
      
      <guid>http://nituchao.com/post/juc.atomic/atomic-long/</guid>
      <description>概述 在原子变量相关类中，AtomicBoolean, AtomicInteger, AtomicLong三个类是对于基本数据类型的操作，其原理和用法类似，区别在于Boolean, Integer, Long分别是8位，32位，64位的类型，本文重点研究AtomicLong。
Boolean类型数据长度为8位，Integer类型数据是32位，在当前32位操作系统或者64位操作中都能够直接对其进行原子修改和读取。而Long类型数据是64位，在32位JVM上会当做两个分离的32位来进行操作，所以本身不具备原子性。
还好我们现在的JDK基本都已经更新到64位，对long型数据的直接修改不存在原子性问题，但是当出现运算操作(比如++, —等)时还是会出现性问题，AtomicLong的目的是实现Long类型数据的各种原子操作。
Java原子变量的实现依赖于sun.misc.Unsafe的CAS操作和volatile的内存可见性语义。
本文基于JDK1.7.0_67
 java version &amp;ldquo;1.7.067&amp;rdquo;
_Java&amp;trade; SE Runtime Environment (build 1.7.0_67-b01)
Java HotSpot&amp;trade; 64-Bit Server VM (build 24.65-b04, mixed mode)
 成员变量 // 成员变量unsafe是原子变量相关操作的基础 // 原子变量的修改操作最终有sun.misc.Unsafe类的CAS操作实现 private static final Unsafe unsafe = Unsafe.getUnsafe(); // 成员变量value的内存偏移值，在静态代码块中初始化 private static final long valueOffset; // 通过volatile关键字保证可见性，用于保存值 private volatile long value; // 记录当前虚拟机是否支持long的原子化操作，如果支持，可以使用CAS进行更新 // 这个问题主要是针对32位JVM对long的更新 static final boolean VM_SUPPORTS_LONG_CAS = VMSupportsCS8(); static { try { valueOffset = unsafe.</description>
    </item>
    
    <item>
      <title>AtomicLongArray源码分析</title>
      <link>http://nituchao.com/post/juc.atomic/atomic-long-array/</link>
      <pubDate>Thu, 23 Feb 2017 18:30:27 +0800</pubDate>
      
      <guid>http://nituchao.com/post/juc.atomic/atomic-long-array/</guid>
      <description>概述 在原子变量相关类中，AtomicIntegerArray, AtomicLongArray, AtomicReferenceArray三个类是对数组类型的原子类操作，其原理和用法类似，本文重点研究AtomicLongArray。
Java原子变量的实现依赖于sun.misc.Unsafe的CAS操作和volatile的内存可见性语义。
本文基于JDK1.7.0_67
 java version &amp;ldquo;1.7.067&amp;rdquo;
_Java&amp;trade; SE Runtime Environment (build 1.7.0_67-b01)
Java HotSpot&amp;trade; 64-Bit Server VM (build 24.65-b04, mixed mode)
 成员变量 // 成员变量unsafe是原子变量相关操作的基础 // 原子变量的修改操作最终有sun.misc.Unsafe类的CAS操作实现 private static final Unsafe unsafe = Unsafe.getUnsafe(); // arrayBaseOffset获取数组首个元素地址偏移 private static final int base = unsafe.arrayBaseOffset(long[].class); // shift就是数组元素的偏移量 private static final int shift; // 保存数据的数组，在构造函数中初始化 private final long[] array; static { // scale数组元素的增量偏移 int scale = unsafe.arrayIndexScale(long[].class); // 用二进制&amp;amp;操作判断是否是2的倍数，很精彩 // 对于int型数组，scale是4 // 对于lang型数组，scale是8 // 对于Reference型数组，scale是4 if ((scale &amp;amp; (scale - 1)) !</description>
    </item>
    
    <item>
      <title>AtomicReference源码分析</title>
      <link>http://nituchao.com/post/juc.atomic/atomic-reference/</link>
      <pubDate>Thu, 23 Feb 2017 18:30:27 +0800</pubDate>
      
      <guid>http://nituchao.com/post/juc.atomic/atomic-reference/</guid>
      <description>概述 在原子变量相关类中，AtomicReference, AtomicStampedReference, AtomicMarkableReference三个类是对于引用类型的操作，其原理和用法类似。
AtomicStampedReference是带了整型版本号(int stamp)的引用型原子变量，每次执行CAS操作时需要对比版本，如果版本满足要求，则操作成功，否则操作失败，用于防止CAS操作的ABA问题。
AtomicMarkableReference则是带了布尔型标记位(Boolean mark)的引用型原子量，每次执行CAS操作是需要对比该标记位，如果标记满足要求，则操作成功，否则操作失败。
Java原子变量的实现依赖于sun.misc.Unsafe的CAS操作和volatile的内存可见性语义。
本文基于JDK1.7.0_67
 java version &amp;ldquo;1.7.067&amp;rdquo;
_Java&amp;trade; SE Runtime Environment (build 1.7.0_67-b01)
Java HotSpot&amp;trade; 64-Bit Server VM (build 24.65-b04, mixed mode)
 成员变量 AtomicReference通过泛型T来声明成员值的类型，表示这是对引用类型的操作。
// 成员变量unsafe是原子变量相关操作的基础 // 原子变量的修改操作最终有sun.misc.Unsafe类的CAS操作实现 private static final Unsafe unsafe = Unsafe.getUnsafe(); // 成员变量value的内存偏移值，在静态代码块中初始化 private static final long valueOffset; // 通过volatile关键字保证可见性，用于保存值 private volatile V value; static { try { valueOffset = unsafe.objectFieldOffset (AtomicReference.class.getDeclaredField(&amp;quot;value&amp;quot;)); } catch (Exception ex) { throw new Error(ex); } }  函数列表 // 构造函数，初始化值为null public AtomicReference() // 构造函数，指定初始化值 public AtomicReference(V initialValue) // 以原子方式获取当前值 public final V get() // 以原子方式设置当前值为新的值newValue public final void set(V newValue) // 以原子方式设置当前值为新的值newValue // 优先保证修改操作，而不保证volatile的可见性语义 // 效率较高 public final void lazySet(V newValue) // 以原子方式设置当前值为update // 如果当前值等于except，则设置成功，返回true // 如果当前值不等于except，则设置失败，返回fase // 该过程不阻塞 public final boolean compareAndSet(V expect, V update) // 以原子方式设置当前值为update // 如果当前值等于except，则设置成功，返回true // 如果当前值不等于except，则设置失败，返回fase // 该过程不阻塞 // 该过程不保证volatile成员的happens-before语义顺序 public final boolean weakCompareAndSet(V expect, V update) // 以原子方式设置当前值为update // 返回更新前的值 public final V getAndSet(V newValue) // 返回当前值的string表达式 public String toString()  重点函数分析 set(V newValue) 以原子方式设置当前值为newValue，因为set方法只是一个单操作的赋值语句，因此是原子的。加上volatile的内存可见性保证，Set是原子操作无疑。</description>
    </item>
    
    <item>
      <title>AtomicStampedReference源码分析</title>
      <link>http://nituchao.com/post/juc.atomic/atomic-stamped-reference/</link>
      <pubDate>Thu, 23 Feb 2017 18:30:27 +0800</pubDate>
      
      <guid>http://nituchao.com/post/juc.atomic/atomic-stamped-reference/</guid>
      <description>概述 在原子变量相关类中，AtomicReference, AtomicStampedReference, AtomicMarkableReference三个类是对于引用类型的操作，其原理和用法类似。
AtomicStampedReference是带了整型版本号(int stamp)的引用型原子变量，每次执行CAS操作时需要对比版本，如果版本满足要求，则操作成功，否则操作失败，用于防止CAS操作的ABA问题。本文重点分析AtomicStampedReference。
AtomicMarkableReference则是带了布尔型标记位(Boolean mark)的引用型原子量，每次执行CAS操作是需要对比该标记位，如果标记满足要求，则操作成功，否则操作失败。
Java原子变量的实现依赖于sun.misc.Unsafe的CAS操作和volatile的内存可见性语义。
本文基于JDK1.7.0_67
 java version &amp;ldquo;1.7.067&amp;rdquo;
_Java&amp;trade; SE Runtime Environment (build 1.7.0_67-b01)
Java HotSpot&amp;trade; 64-Bit Server VM (build 24.65-b04, mixed mode)
 内部类 AtomicStampedReference是带整形版本号的原子引用类型，为了同时兼顾引用值和版本号，它定义了一个静态内部类Pair，AtomicStampedReference的相关操作都是对Pair内成员的操作。
private static class Pair&amp;lt;T&amp;gt; { final T reference; final int stamp; private Pair(T reference, int stamp) { this.reference = reference; this.stamp = stamp; } static &amp;lt;T&amp;gt; Pair&amp;lt;T&amp;gt; of(T reference, int stamp) { return new Pair&amp;lt;T&amp;gt;(reference, stamp); } }  成员变量 AtomicStampedReference除了常规的sun.</description>
    </item>
    
    <item>
      <title>AtomicMarkableReference源码分析</title>
      <link>http://nituchao.com/post/juc.atomic/atomic-markable-reference/</link>
      <pubDate>Thu, 23 Feb 2017 18:30:25 +0800</pubDate>
      
      <guid>http://nituchao.com/post/juc.atomic/atomic-markable-reference/</guid>
      <description>概述 在原子变量相关类中，AtomicReference, AtomicStampedReference, AtomicMarkableReference三个类是对于引用类型的操作，其原理和用法类似。
AtomicStampedReference是带了整型标记值(int stamp)的引用型原子变量，每次执行CAS操作时需要对比版本，如果版本满足要求，则操作成功，否则操作失败，用于防止CAS操作的ABA问题。
AtomicMarkableReference则是带了布尔型标记位(Boolean mark)的引用型原子量，每次执行CAS操作是需要对比该标记位，如果标记满足要求，则操作成功，否则操作失败。本文重点分析AtomicMarkableReference。
Java原子变量的实现依赖于sun.misc.Unsafe的CAS操作和volatile的内存可见性语义。
本文基于JDK1.7.0_67
 java version &amp;ldquo;1.7.0_67&amp;rdquo;
_Java&amp;trade; SE Runtime Environment (build 1.7.0_67-b01)
Java HotSpot&amp;trade; 64-Bit Server VM (build 24.65-b04, mixed mode)
 内部类 AtomicMarkableReference是带布尔型标记为的原子引用类型，为了同时兼顾引用值和标记位，它定义了一个静态内部类Pair，AtomicMarkableReference的相关操作都是对Pair内成员的操作。
private static class Pair&amp;lt;T&amp;gt; { final T reference; final boolean mark; private Pair(T reference, boolean mark) { this.reference = reference; this.mark = mark; } static &amp;lt;T&amp;gt; Pair&amp;lt;T&amp;gt; of(T reference, int mark) { return new Pair&amp;lt;T&amp;gt;(reference, mark); } }  成员变量 AtomicMarkableReference除了常规的sun.</description>
    </item>
    
    <item>
      <title>Java锁之自旋锁的原理</title>
      <link>http://nituchao.com/post/juc.lock/clh-spin-ticket-mcs-lock/</link>
      <pubDate>Thu, 23 Feb 2017 18:29:27 +0800</pubDate>
      
      <guid>http://nituchao.com/post/juc.lock/clh-spin-ticket-mcs-lock/</guid>
      <description>概述 锁作为数据同步工具，Java提供了两种实现：synchronized和AQS，这两种锁的实现根本不同，但是在加锁和解锁的过程中，也有很多共同点。它们在进行加锁/解锁时或多或少的用到自旋锁的设计思想。对于这几种自旋锁设计思想的研究，可以帮助我们更好的理解Java的Lock框架。
SPIN锁 Spin锁即自旋锁。自旋锁是采用让当前线程不停地在循环体内检测并设置临界资源的状态，直到状态满足条件并设置为指定的新状态。检测并设置临界资源操作必须是原子的，这样即使多个线程在给定时间自旋，也只有一个线程可获得该锁。
自旋锁的优点之一是自旋的线程不会被阻塞，一直处于活跃状态，对于锁保护的临界区较小的情况下，自旋获取锁和释放锁的成本都比较低，时间比较短。
Java中的自旋锁 在JAVA中，我们可以使用原子变量和Unsafe类的CAS操作来实现自旋锁：
public class SpinLock { private AtomicReference&amp;lt;Thread&amp;gt; atomic = new AtomicReference&amp;lt;Thread&amp;gt;(); public void lock() { Thread currentThread = Thread.currentThread(); // 如果锁未被占用，则设置当前线程为锁的拥有者。 while(!atomic.compareAndSet(null, currentThread)) {} } public void unlock() { Thread currentThread = Thread.currentThread(); // 只有锁的拥有者能释放锁 atomic.compareAndSet(currentThread, null); } }  缺点  CAS操作需要硬件的配合；
 保证各个CPU的缓存（L1、L2、L3、跨CPU Socket、主存）的数据一致性，通讯开销很大，在多处理器系统上更严重；
 没法保证公平性，不保证等待进程/线程按照FIFO顺序获得锁。
  ​
Linux中的自旋锁 自旋锁在Linux内核中广泛使用。在Linux操作系统中，自旋锁是一个互斥设备，它只有两个值锁定和解锁。
由于操作系统和CPU直接打交道，自旋锁又可分为在单核处理器上和多核处理器上。
单核处理器 用在单核处理器上，有可分为两种：
 系统不支持内核抢占  此时自旋锁什么也不做，确实也不需要做什么，因为单核处理器只有一个线程在执行，又不支持内核抢占，因此资源不可能会被其他的线程访问到。
 系统支持内核抢占  这种情况下，自旋锁加锁仅仅是禁止了内核抢占，解锁则是启用了内核抢占。</description>
    </item>
    
    <item>
      <title>Java锁之Lock框架概述</title>
      <link>http://nituchao.com/post/juc.lock/lock-summary/</link>
      <pubDate>Thu, 23 Feb 2017 18:28:27 +0800</pubDate>
      
      <guid>http://nituchao.com/post/juc.lock/lock-summary/</guid>
      <description> 在Java中关于锁有两个体系，一个是synchronized代表的对象监视器同步锁，一个是以AQS为基础的锁框架，该框架位于java.uti.concurrent包下。
本文基于JDK1.7.0_67
 java version &amp;ldquo;1.7.067&amp;rdquo;
_Java&amp;trade; SE Runtime Environment (build 1.7.0_67-b01)
Java HotSpot&amp;trade; 64-Bit Server VM (build 24.65-b04, mixed mode)
 AQS框架原理 JUC包中的锁 相比同步锁，JUC包中的锁的功能更加强大，它为锁提供了一个框架，该框架允许更灵活地使用锁，只是它的用法更难罢了。
JUC包中的锁，包括：
 Lock接口 ReadWriteLock接口 Condition接口 ReentrantLock独占锁 ReentrantReadWriteLock读写锁 CountDownLatch CyclicBarrier Semaphore AbstractOwnableSynchronizer抽象类 AbstractQueuedSynchronizer抽象类 AbstractQueuedLongSynchronizer抽象类  </description>
    </item>
    
    <item>
      <title>AtomicLongFieldUpdater源码分析</title>
      <link>http://nituchao.com/post/juc.atomic/atomic-long-field-updater/</link>
      <pubDate>Thu, 23 Feb 2017 18:27:27 +0800</pubDate>
      
      <guid>http://nituchao.com/post/juc.atomic/atomic-long-field-updater/</guid>
      <description>概述 在原子变量相关类中，AtomicIntegerFieldUpdater, AtomicLongFieldUpdater, AtomicReferenceFieldUpdater三个类是用于原子地修改对象的成员属性，它们的原理和用法类似，区别在于对Integer，Long，Reference类型的成员属性进行修改。本文重点研究AtomicLongFieldUpdater。
AtomicLongFieldUpdater的设计非常有意思。AtomicLongFieldUpdater本身是一个抽象类，只有一个受保护的构造函数，它本身不能被实例化。
AtomicLongFieldUpdater有两个私有的静态内部类CASUpdater和LockedUpdater，它们都是AtomicLongFieldUpdater的子类。
用户使用AtomicLongFieldUpdater的静态方法newUpdater实例化AtomicLongFieldUpdater子类对象，本质是上是根据条件实例化了子类CASUpdater或者LockedUpdater，然后通过子类来完成具体的工作。CASUpdater和LockedUpdater值的读取和更新最后都是使用sun.misc.Unsafe类的相关操作。
CASUpdater使用下面的方法：
public native Object getLongVolatile(Object o, long offset); public native void putLongVolatile(Object o, long offset, long x);  LockedUpdater使用下面的方法：
public native long getLong(Object o, long offset); public native void putLong(Object o, long offset, long x);  为了防止操作过程中的指令重排，LockedUpdater使用synchronized进行同步。
本文基于JDK1.7.0_67
 java version &amp;ldquo;1.7.0_67&amp;rdquo;
_Java™ SE Runtime Environment (build 1.7.0_67-b01)
Java HotSpot™ 64-Bit Server VM (build 24.65-b04, mixed mode)
 内部类 AtomicLongFieldUpdater本身是抽象类，通过两个私有的静态内部子类来完成具体的工作。
 CASUpdater：顾名思义，使用CAS操作对象的成员变量。 LockedUpdater：顾名思义，在更新和读取对象的成员变量时，使用对象锁来保证同步。  成员变量 AtomicLongFieldUpdater是个抽象类，具体的业务逻辑都是交给它的子类实现的，它本身没有包含任何成员变量。</description>
    </item>
    
    <item>
      <title>ConcurrentHashMap源码分析</title>
      <link>http://nituchao.com/post/juc.concurrent/concurrent-hasmap/</link>
      <pubDate>Thu, 23 Feb 2017 18:27:27 +0800</pubDate>
      
      <guid>http://nituchao.com/post/juc.concurrent/concurrent-hasmap/</guid>
      <description>一言 ConcurrentHashMap是线程安全的、高效的哈希表。默认支持16个并发级别，并发级别在初始化后不能扩展。
概述 HashMap是非线程安全的哈希表，常用于单线程程序中。
Hashtable是线程安全的哈希表，它是通过synchronized来保证线程安全的；多线程通过同一个“对象的同步锁”来实现并发控制。Hashtable在线程竞争激烈时，效率比较低(此时建议使用ConcurrentHashMap)！因为当一个线程访问Hashtable的同步方法时，其它线程就访问Hashtable的同步方法时，可能会进入阻塞状态。
ConcurrentHashMap是线程安全的哈希表，它是通过“锁分段”来保证线程安全的。ConcurrentHashMap将哈希表分成许多片段(Segment)，每一个片段除了保存哈希表之外，本质上也是一个“可重入的互斥锁”(ReentrantLock)。多线程对同一个片段的访问，是互斥的；但是，对于不同片段的访问，却是可以同步进行的。
本文基于JDK1.7.0_67
 java version &amp;ldquo;1.7.067&amp;rdquo;
_Java&amp;trade; SE Runtime Environment (build 1.7.0_67-b01)
Java HotSpot&amp;trade; 64-Bit Server VM (build 24.65-b04, mixed mode)
 ConcurrentHashMap数据结构 要想搞清ConcurrentHashMap，必须先弄清楚它的数据结构：
图
说明:
 ConcurrentHashMap继承于AbstractMap抽象类。 Setment是ConcurrentHashMap的内部类，它就是ConcurrentHashMap中的&amp;rdquo;锁分段&amp;rdquo;对应的数据结构。ConcurrentHashMap与Segment是组合关系，1个ConcurrentHashMap对象包含若干个Segment对象。在代码中，这表现为ConcurrentHashMap类中存在&amp;rdquo;Segment数组&amp;rdquo;成员。 Segment类继承于ReentrantLock类，所以Segment本质上是一个可重入的互斥锁。 HashEntry也是ConcurrentHashMap的内部类，是单向链表节点，存储着key-value键值对。Segment与HashEntry是组合关系，Segment类中存在“HashEntry数组”成员，“HashEntry数组”中的每个HashEntry就是一个单向链表。  对于多线程访问对一个“哈希表对象”竞争资源，Hashtable是通过一把锁来控制并发；而ConcurrentHashMap则是将哈希表分成许多片段，对于每一个片段分别通过一个互斥锁来控制并发。ConcurrentHashMap对并发的控制更加细腻，它也更加适应于高并发场景！
ConcurrentHashMap常量定义 // 默认初始容量(HashEntry的个数) static final int DEFAULT_INITIAL_CAPACITY = 16; // 默认负载因子 static final float DEFAULT_LOAD_FACTOR = 0.75f; // 默认并发级别 static final int DEFAULT_CONCURRENCY_LEVEL = 16; // 最大容量(HashEntry的个数) static final int MAXIMUM_CAPACITY = 1 &amp;lt;&amp;lt; 30; // 每个段(Segment)中HashEntry数组(table)的最小容量 // 设置最小为2，是为了防止构造完成后立即resize static final int MIN_SEGMENT_TABLE_CAPACITY = 2; // 段的最大个数 static final int MAX_SEGMENTS = 1 &amp;lt;&amp;lt; 16; // slightly conservative // 在计算size时，先尝试不获取段锁计算，最多尝试RETRIES_BEFORE_LOCK次。 // 如果重试超过RETRIES_BEFORE_LOCK次，则获取段锁后进行计算。 static final int RETRIES_BEFORE_LOCK = 2;  ConcurrentHashMap成员变量 // 制造一个随机值，使得在计算key的hash值时不容易出现冲突。 // 该值通过sun.</description>
    </item>
    
    <item>
      <title>AtomicIntegerFieldUpdater源码分析</title>
      <link>http://nituchao.com/post/juc.atomic/atomic-integer-field-updater/</link>
      <pubDate>Thu, 23 Feb 2017 18:27:25 +0800</pubDate>
      
      <guid>http://nituchao.com/post/juc.atomic/atomic-integer-field-updater/</guid>
      <description>概述 在原子变量相关类中，AtomicIntegerFieldUpdater, AtomicLongFieldUpdater, AtomicReferenceFieldUpdater三个类是用于原子地修改对象的成员属性，它们的原理和用法类似，区别在于对Integer，Long，Reference类型的成员属性进行修改。本文重点研究AtomicIntegerFieldUpdater。
AtomicIntegerFieldUpdater的设计非常有意思。AtomicIntegerFieldUpdater本身是一个抽象类，只有一个受保护的构造函数，它本身不能被实例化。在AtomicIntegerFieldUpdater中定义了一些基本的模板方法，然后通过一个静态内部子类AtomicIntegerFieldUpdaterImpl来实现具体的操作。AtomicIntegerFieldUpdaterImpl中的相关操作也都是基于Unsafe类来实现的。
本文基于JDK1.7.0_67
 java version &amp;ldquo;1.7.0_67&amp;rdquo;
_Java™ SE Runtime Environment (build 1.7.0_67-b01)
Java HotSpot™ 64-Bit Server VM (build 24.65-b04, mixed mode)
 内部类 AtomicIntegerFieldUpdater本身是一个抽象类，通过一个静态内部子类来实现相关的操作。
private static class AtomicIntegerFieldUpdaterImpl&amp;lt;T&amp;gt; extends AtomicIntegerFieldUpdater&amp;lt;T&amp;gt;  成员变量 AtomicIntegerFieldUpdater是个抽象类，具体的业务逻辑都是交给它的子类实现的，它本身没有包含任何成员变量。
函数列表 // 受保护的无操作构造函数，供子类使用 protected AtomicIntegerFieldUpdater() // 为对象创建并返回一个具有给定字段的更新器。 public static &amp;lt;U&amp;gt; AtomicIntegerFieldUpdater&amp;lt;U&amp;gt; newUpdater(Class&amp;lt;U&amp;gt; tclass, String fieldName) // 以原子方式设置当前值为update // 如果当前值等于expect，并设置成功，返回true // 如果当前值不等于expect，则设置失败，返回false // 该过程通过CAS实现，不阻塞 public abstract boolean compareAndSet(T obj, int expect, int update) // 以原子方式设置当前值为update // 如果当前值等于expect，并设置成功，返回true // 如果当前值不等于expect，则设置失败，返回false // 该过程通过CAS实现，不阻塞 // 该过程不保证volatile成员的happens-before语义顺序 public abstract boolean weakCompareAndSet(T obj, int expect, int update) // 以原子方式设置当前值为newValue // 使用Unsafe类的putIntVolatile进行操作，具有原子性 public abstract void set(T obj, int newValue) // 以原子方式设置当前值为newValue // 使用Unsafe类的putOrderedInt进行操作，所以本身具有原子性 public abstract void lazySet(T obj, int newValue) // 以原子方式获取当前值 // 使用Unsafe类的getIntVolatile进行操作，所以本身具有原子性 public abstract int get(T obj) // 以原子方式设置当前值为newValue，并返回更新前的值 // 使用Unsafe类的compareAndSwapInt进行操作，所以本身具有原子性 // 操作过程中使用自旋方式，直到操作成功 public int getAndSet(T obj, int newValue) // 以原子方式将当前值加1，并返回更新前的值 // 使用Unsafe类的compareAndSwapInt进行操作，所以本身具有原子性 // 操作过程中使用自旋方式，直到操作成功 public int getAndIncrement(T obj) // 以原子方式将当前值减1，并返回更新前的值 // 使用Unsafe类的compareAndSwapInt进行操作，所以本身具有原子性 // 操作过程中使用自旋方式，直到操作成功 public int getAndDecrement(T obj) // 以原子方式将当前值加上给定值delta，并返回更新前的值 // 使用Unsafe类的compareAndSwapInt进行操作，所以本身具有原子性 // 操作过程中使用自旋方式，直到操作成功 public int getAndAdd(T obj, int delta) // 以原子方式将当前值加1，并返回更新后的值 // 使用Unsafe类的compareAndSwapInt进行操作，所以本身具有原子性 // 操作过程中使用自旋方式，直到操作成功 public int incrementAndGet(T obj) // 以原子方式将当前值减1，并返回更新前的值 // 使用Unsafe类的compareAndSwapInt进行操作，所以本身具有原子性 // 操作过程中使用自旋方式，直到操作成功 public int decrementAndGet(T obj) // 以原子方式将当前值加上给定值delta，并返回更新后的值 // 使用Unsafe类的compareAndSwapInt进行操作，所以本身具有原子性 // 操作过程中使用自旋方式，直到操作成功 public int addAndGet(T obj, int delta)  重点函数分析 newUpdater 为对象创建并返回一个具有给定字段的更新器实例。在该方法中，直接构造一个AtomicIntegerFieldUpdaterImpl实例。</description>
    </item>
    
    <item>
      <title>CopyOnWriteArraySet源码分析</title>
      <link>http://nituchao.com/post/juc.concurrent/copy-on-write-array-set/</link>
      <pubDate>Thu, 23 Feb 2017 18:26:27 +0800</pubDate>
      
      <guid>http://nituchao.com/post/juc.concurrent/copy-on-write-array-set/</guid>
      <description>一言 CopyOnWriteArraySet是线程安全的无序集合，它是通过聚合了一个CopyOnWriteArray成员变量来实现的。
概要 CopyOnWriteArraySet是线程安全的无序集合，可以将它理解成线程安全的HashSet。有意思的是，CopyOnWriteArraySet和HashSet虽然都继承于共同的父类AbstractSet；但是，HashSet是通过&amp;rdquo;散列表(HashSet)&amp;ldquo;实现的，而CopyConWriteArraySet则是通过&amp;rdquo;动态数组(CopyOnWriteArrayList)&amp;ldquo;实现的，并不是散列表。
CopyOnWriteArraySet具有以下特性：
 它最适合于具有以下特征的应用程序：Set 大小通常保持很小，只读操作远多于可变操作，需要在遍历期间防止线程间的冲突。 它是线程安全的。它的线程安全通过volatile、互斥锁来实现。 因为通常需要复制整个基础数组，所以可变操作（add()、set() 和 remove() 等等）的开销很大。 迭代器支持hasNext(), next()等不可变操作，但不支持可变 remove()等 操作。 使用迭代器进行遍历的速度很快，并且不会与其他线程发生冲突。在构造迭代器时，迭代器依赖于不变的数组快照。  本文基于JDK1.7.0_67
 java version &amp;ldquo;1.7.067&amp;rdquo;
_Java&amp;trade; SE Runtime Environment (build 1.7.0_67-b01)
Java HotSpot&amp;trade; 64-Bit Server VM (build 24.65-b04, mixed mode)
 CopyOnWriteArraySet原理 CopyOnWriteArraySet的数据结构，如下图所示：
图
说明
 CopyOnWriteArraySet继承于AbstractSet，这就意味着它是一个集合。 CopyOnWriteArraySet聚合了一个CopyOnWriteArrayList对象，它是通过CopyOnWriteArrayList实现的。而CopyOnWriteArrayList本质是个动态数组队列，所以CopyOnWriteArraySet相当于通过动态数组实现的&amp;rdquo;集合&amp;rdquo;！ CopyOnWriteArraySet不允许有重复元素。因此，CopyOnWriteArrayList额外提供了addIfAbsent()和addAllAbsent()这两个添加元素的API，通过这些API来添加元素时，只有当元素不存在时才执行添加操作。 CopyOnWriteArraySet的&amp;rdquo;线程安全&amp;rdquo;机制是通过volatile和互斥锁来实现的。而它本身没有volatile变量和互斥锁，都是借由CopyOnWriteArrayList实现。  CopyOnWriteArraySet成员变量 CopyOnWriteArraySet只有下面一个成员变量
private final CopyOnWriteArrayList&amp;lt;E&amp;gt; al;  说明:
 成员变量al是final类型的，通过构造函数进行初始化后将不能再修改。 成员变量al里的添加/修改/删除操作都是通过互斥锁和volatile变量来保证现场安全的，因此，成员变量al不再用volatile修饰，也不再额外声明可重入锁lock。  CopyOnWriteArraySet函数列表 // 创建一个空 set。 CopyOnWriteArraySet() // 创建一个包含指定 collection 所有元素的 set。 CopyOnWriteArraySet(Collection&amp;lt;?</description>
    </item>
    
    <item>
      <title>CopyOnWriteArrayList源码分析</title>
      <link>http://nituchao.com/post/juc.concurrent/copy-on-write-array-list/</link>
      <pubDate>Thu, 23 Feb 2017 18:25:27 +0800</pubDate>
      
      <guid>http://nituchao.com/post/juc.concurrent/copy-on-write-array-list/</guid>
      <description>概述 CopyOnWriteArrayList相当于线程安全的ArrayList。和ArrayList一样，它是个可变数组；但是和ArrayList不同的是，它具有以下特性： 1. 它最适合于具有以下特征的应用程序：List大小通常保持很小，只读操作远多于可变操作，需要在遍历期间防止线程间的冲突。 2. 它是线程安全的。它的线程安全表现在两个方面，修改时使用锁进行同步，读取时使用数据快照。 3. 因为通常要复制整个基础数组，所以可变操作（add()、set()和remove()等操作）的开销很大。 4. 迭代器支持hasNext()、next等不可变操作，但不支持可变remove()等操作。 5. 使用迭代器进行遍历的速度很快，并且不会与其他线程发生冲突。在构造迭代器时，迭代器依赖于不变的数组快照。
本文基于JDK1.7.0_67
 java version &amp;ldquo;1.7.067&amp;rdquo;
_Java&amp;trade; SE Runtime Environment (build 1.7.0_67-b01)
Java HotSpot&amp;trade; 64-Bit Server VM (build 24.65-b04, mixed mode)
 CopyOnWriteArrayList原理和数据结构 CopyOnWriteArrayList的数据结构，如下图所示：
CopyOnWriteArrayList UML图
说明： 1. CopyOnWriteArrayList实现了List接口，因此可以认为它是一个有序的集合。 2. CopyOnWriteArrayList实现了RandomAccess接口，因此可以认为它的元素可以随机访问。 3. CopyOnWriteArrayList包含一个可重入锁Lock。每一个CopyOnWriteArrayList都和一个互斥锁lock绑定，通过lock，实现了对CopyOnWriteArrayList的互斥访问。 4. CopyOnWriteArrayList包含了成员array数组，这说明CopyOnWriteArrayList本质上通过数组实现的。而且，可存储的元素个数没有上限。
下面从&amp;rdquo;动态数组&amp;rdquo;和&amp;rdquo;线程安全&amp;rdquo;两个方面进一步对CopyOnWriteArrayList的原理进行说明。 1. CopyOnWriteArrayList的&amp;rdquo;动态数组&amp;rdquo;机制
它内部有个&amp;rdquo;volatile数组&amp;rdquo;(array)来保持数据。在&amp;rdquo;添加/修改/删除&amp;rdquo;数据时，都会新建一个数组，并将更新后的数据拷贝到新建的数组中，最后再将该数组赋值给&amp;rdquo;volatile数组&amp;rdquo;。这就是它叫做CopyOnWriteArrayList的原因！
CopyOnWriteArrayList就是通过这种方式实现的动态数组；不过正由于它在&amp;rdquo;添加/修改/删除&amp;rdquo;数据时，都会新建数组，所以涉及到修改数据的操作，CopyOnWriteArrayList效率很低。但是单单只是进行遍历的话，效率比较高。
 CopyOnWriteArrayList的&amp;rdquo;线程安全&amp;rdquo;机制  是通过volatile和互斥锁来实现的。 a. CopyOnWriteArrayList是通过&amp;rdquo;volatile数组&amp;rdquo;来保存数据的。
一个线程读取volatile数组时，总能看到其他线程对该volatile变量最后的写入。就这样，通过volatile提供了&amp;rdquo;读取到的数据总是最新的&amp;rdquo;这个机制的保证。 b. CopyOnWriteArrayList通过互斥锁来保护数据。
在&amp;rdquo;添加/修改/删除&amp;rdquo;数据时，会先&amp;rdquo;获取互斥锁&amp;rdquo;，在修改完毕后，先将数据更新到&amp;rdquo;volatile数组&amp;rdquo;中，然后再&amp;rdquo;释放互斥锁&amp;rdquo;；这样，就达到了保护数据的目的。
CopyOnWriteArrayList成员变量 /** 可重入锁，对数组进行添加/修改/删除操作时，通过lock来进行同步操作 */ transient final ReentrantLock lock = new ReentrantLock(); /** 数组，保存数据的地方。对数组array的操作都要通过getArray和setArray进行操作 */ private volatile transient Object[] array;  CopyOnWriteArrayList函数列表 // 创建一个空列表，默认大小为0。 CopyOnWriteArrayList() // 创建一个按 collection 的迭代器返回元素的顺序包含指定 collection 元素的列表。 CopyOnWriteArrayList(Collection&amp;lt;?</description>
    </item>
    
    <item>
      <title>JVM行为相关的配置参数</title>
      <link>http://nituchao.com/post/2016/jvm-xing-wei-xiang-guan-de-pei-zhi-can-shu/</link>
      <pubDate>Thu, 29 Dec 2016 13:53:12 +0800</pubDate>
      
      <guid>http://nituchao.com/post/2016/jvm-xing-wei-xiang-guan-de-pei-zhi-can-shu/</guid>
      <description>文本将分析与JVM行为相关的配置参数。</description>
    </item>
    
    <item>
      <title>JVM G1收集器配置参数</title>
      <link>http://nituchao.com/post/2016/jvm-g1-shou-ji-qi-pei-zhi-can-shu/</link>
      <pubDate>Thu, 29 Dec 2016 12:22:12 +0800</pubDate>
      
      <guid>http://nituchao.com/post/2016/jvm-g1-shou-ji-qi-pei-zhi-can-shu/</guid>
      <description>G1收集器配置参数</description>
    </item>
    
    <item>
      <title>JVM常用的非标准配置参数</title>
      <link>http://nituchao.com/post/2016/jvm-chan-yong-de-fei-biao-zhun-pei-zhi-can-shu/</link>
      <pubDate>Thu, 29 Dec 2016 10:18:12 +0800</pubDate>
      
      <guid>http://nituchao.com/post/2016/jvm-chan-yong-de-fei-biao-zhun-pei-zhi-can-shu/</guid>
      <description>本文将研究JVM常见常见的非标准配置参数。</description>
    </item>
    
    <item>
      <title>JVM性能相关的配置参数</title>
      <link>http://nituchao.com/post/2016/jvm-xing-neng-xiang-guan-de-pei-zhi-can-shu/</link>
      <pubDate>Thu, 29 Dec 2016 09:30:12 +0800</pubDate>
      
      <guid>http://nituchao.com/post/2016/jvm-xing-neng-xiang-guan-de-pei-zhi-can-shu/</guid>
      <description>本问将介绍JVM性能相关的配置参数。</description>
    </item>
    
    <item>
      <title>JVM配置参数-X与-XX的区别</title>
      <link>http://nituchao.com/post/2016/jvm-options-x-vs-xx/</link>
      <pubDate>Wed, 28 Dec 2016 13:14:12 +0800</pubDate>
      
      <guid>http://nituchao.com/post/2016/jvm-options-x-vs-xx/</guid>
      <description>启动JVM时通过指定配置参数来指导虚拟机按照我们的要求提供服务，这一点对大多数的Java程序员来说已经是司空见惯。
在指定配置参数时，会有-X和-XX两种形式，那么它们两者有什么区别呢，今天我想借这篇文章总结一下。
下面是我们的某个Java项目在正式环境上启动JVM时的一个典型命令，在该命令中指定了各种启动参数：
java -Xmx15G \ -Xms10G \ -Xmn3G \ -Xss512k \ -XX:MaxPermSize=512M \ -XX:PermSize=512M \ -XX:+PrintFlagsFinal \ -XX:MaxTenuringThreshold=1 \ -XX:SurvivorRatio=23 \ -XX:TargetSurvivorRatio=80 \ -Xnoclassgc \ -XX:+UseParNewGC \ -XX:+UseConcMarkSweepGC \ -XX:CMSInitiatingOccupancyFraction=80 \ -XX:ParallelGCThreads=24 \ -XX:ConcGCThreads=24 \ -XX:+CMSParallelRemarkEnabled \ -XX:+CMSScavengeBeforeRemark \ -XX:+ExplicitGCInvokesConcurrent \ -XX:+UseTLAB \ -XX:TLABSize=64K, -verbose:gc \ -XX:+PrintGCDetails \ -XX:+PrintGCDateStamps \ -XX:+PrintGCTimeStamps \ -XX:+PrintGCApplicationStoppedTime \ -Xloggc:./gc.log  Java HotSpot VM的官方文档中将启动参数分为如下两类：
   配置 参数 类型 说明 举例     -X non-standard 非标准参数。这些参数不是虚拟机规范规定的。因此，不是所有VM的实现(如:HotSpot,JRockit,J9等)都支持这些配置参数。 -Xmx、-Xms、-Xmn、-Xss   -XX not-stable 不稳定参数。这些参数是虚拟机规范中规定的。这些参数指定虚拟机实例在运行时的各种行为，从而对虚拟机的运行时性能有很大影响。 -XX:SurvivorRatio、-XX:+UseParNewGc    补充: -X和-XX两种参数都可能随着JDK版本的变更而发生变化，有些参数可以能会被废弃掉，有些参数的功能会发生改变，但是JDK官方不会通知开发者这些变化，需要使用者注意。</description>
    </item>
    
    <item>
      <title>Java通过信号量机制实现生产者消费者</title>
      <link>http://nituchao.com/post/2016/java-xin-hao-liang-ji-zhi-shi-xian-sheng-chan-zhe-xiao-fei-zhe/</link>
      <pubDate>Tue, 27 Dec 2016 16:12:12 +0800</pubDate>
      
      <guid>http://nituchao.com/post/2016/java-xin-hao-liang-ji-zhi-shi-xian-sheng-chan-zhe-xiao-fei-zhe/</guid>
      <description>信号量是一种计数器，用来保护一个或者多个共享资源的访问。Java提供了Semaphore类来实现信号量机制。
如果线程要访问一个共享资源，它必须先获得信号量。如果信号量的内部计数器大于0，信号量将减1，然后允许访问这个共享资源。计数器大于0意味着有可以使用的资源，因此线程将被允许使用其中一个资源。
否则，如果信号量的计数器等于0，信号量将会把线程置入休眠直至计数器大于0.计数器等于0的时候意味着所有的共享资源已经被其他线程使用了，所以需要访问这个共享资源的线程必须等待。
当线程使用完某个共享资源时，信号量必须被释放，以便其他线程能够访问共享资源。释放操作将使信号量的内部计数器增加1。
设计思想 为了使用信号量机制来实现生产者VS消费者模型，我们需要实例化一个二进制信号量对象，即内部计数器只有0和1两个值。多个生产者线程和多个消费者线程竞争这个信号量来互斥访问共享缓冲区。
另外，由于共享缓冲区是有空间限制的，生产者在生产前要判断共享缓冲区空间是否充足。消费者在消费前要判断共享缓冲区内的元素是否足够消费。
代码实现 基于上面的设计思想，我们需要实现共享缓冲区，生产者线程，消费者线程和主程序四部分。
共享缓冲区
package com.nituchao.jvm.prosumer.semaphore; import java.util.ArrayList; import java.util.List; import java.util.concurrent.Semaphore; /** * 缓冲区 * Created by liang on 2016/12/29. */ public class Buffer { private int MAX_SIZE = 100; private final List&amp;lt;String&amp;gt; list; private final Semaphore semaphore; public Buffer() { this.list = new ArrayList&amp;lt;&amp;gt;(); this.semaphore = new Semaphore(1); } /** * 生产Buffer元素 * * @param num */ public boolean BufferProduct(int num) { boolean result = true; try { // 获取信号量 semaphore.</description>
    </item>
    
    <item>
      <title>Java通过重入锁实现生产者消费者</title>
      <link>http://nituchao.com/post/2016/java-chong-ru-suo-shi-xian-sheng-chan-zhe-xiao-fei-zhe/</link>
      <pubDate>Tue, 27 Dec 2016 16:12:12 +0800</pubDate>
      
      <guid>http://nituchao.com/post/2016/java-chong-ru-suo-shi-xian-sheng-chan-zhe-xiao-fei-zhe/</guid>
      <description>ReentrantLock是一个可重入的互斥锁，又被称为&amp;rdquo;独占锁&amp;rdquo;，ReentrantLock锁在同一个时间点只能被一个线程锁持有，而可重入的意思是，ReentrantLock可以被单个线程多次获取，ReentrantLock的性能并不高，优点是比价灵活。ReentrantLock比Synchronized关键词更加灵活，并且能支持条件变量，后面我还会单独介绍使用条件变量实现生产者消费者模型的方法。
设计思想 本文希望同ReentrantLock来实现一个共享缓冲区，生产者线程和消费者线程通过该共享缓冲区来实现相关的生产和消费操作，每个线程对共享缓冲区的访问是互斥的。
另外，由于共享缓冲区是有空间限制的，生产者在生产前要判断共享缓冲区空间是否充足。消费者在消费前要判断共享缓冲区内的元素是否足够消费。
代码实现 根据上面的设计思想，我们需要实现共享缓冲区，生产者线程，消费者线程，主程序等四个部分。
共享缓冲区
package com.nituchao.jvm.prosumer.reentrant; import java.util.ArrayList; import java.util.List; import java.util.concurrent.locks.Lock; import java.util.concurrent.locks.ReentrantLock; /** * 共享缓冲区 * Created by liang on 2016/12/30. */ public class Buffer { private final List&amp;lt;String&amp;gt; list; private int MAX_SIZE = 10; private final Lock lock; public Buffer() { this.list = new ArrayList&amp;lt;String&amp;gt;(); this.lock = new ReentrantLock(); } /** * 生产num个元素 * * @param num * @return */ public boolean bufferProduct(int num) { boolean result = true; try { lock.</description>
    </item>
    
    <item>
      <title>Java通过阻塞队列实现生产者消费者</title>
      <link>http://nituchao.com/post/2016/java-zu-se-dui-lie-shi-xian-sheng-chan-xiao-fei-zhe/</link>
      <pubDate>Tue, 27 Dec 2016 16:10:12 +0800</pubDate>
      
      <guid>http://nituchao.com/post/2016/java-zu-se-dui-lie-shi-xian-sheng-chan-xiao-fei-zhe/</guid>
      <description>Java通过阻塞队列实现生产者消费者。</description>
    </item>
    
    <item>
      <title>Java通过对象同步机制实现生产者消费者</title>
      <link>http://nituchao.com/post/2016/java-dui-xiang-suo-shi-xian-sheng-chan-zhe-xiao-fei-zhe/</link>
      <pubDate>Tue, 27 Dec 2016 12:54:28 +0800</pubDate>
      
      <guid>http://nituchao.com/post/2016/java-dui-xiang-suo-shi-xian-sheng-chan-zhe-xiao-fei-zhe/</guid>
      <description>每个Java类都是从Object类派生出来的，Object类原生提供了wait(),notify(),notifyAll()等方法来实现线程间的同步控制。
进一步讲，每个对象都能当做一个锁，每个对象也能当做一个条件队列，对象中的wait(), notify(), notifyAll()方法构成了内部条件队列的API，而队列正是生产者消费者模型的一个关键元素。当对象调用wait()方法时，当前线程会释放获得的对象锁，同时，当前对象会请求操作系统挂起当前线程，此时对象的对象锁就可用了，允许其他等待线程进入。当对象调用notify()或者notifyAll()方法时，当前线程也会释放获得的对象锁，同时，操作系统会结束当前线程的执行，并从阻塞在该对象上的线程列表中选择一个进行唤醒，该线程会获得对线锁并被让操作系统调度。
设计思想 为了设计基于Java对象同步机制的生产者消费者程序，并且是多个生产者线程VS多个消费者线程，可以从以下三点出发。
首先，我们需要有一个缓冲区来充当生产者和消费者之间交换数据的媒介，这个缓冲区可以是一个普通的列表对象，我们在该列表对象上进行生产者和消费者的互斥访问控制。本质上讲，这个缓冲器就相当于一个队列，一方面允许生产者往里面添加数据，一方面允许消费者从里面取走数据。这个列表对象非常重要，所有的wait()和notify()操作以及对象锁的控制都是针对该对象的。因此，这是一个共享对象，在各个生产者线程和消费者线程之间充当媒介。
其次，我们需要有若干个生产者线程。生产者线程要争夺缓冲区对象锁，如果未得到锁则wait()进入阻塞等待被唤醒。如果得到了对象锁，还要判断缓冲区是否已满。如果缓冲区已满，则要wait()进入阻塞等待被唤醒，并释放缓冲区对象锁。如果缓冲区未满，则可以进行生产活动，结束后释放缓冲区对象锁，并唤醒一个阻塞的线程。
最后，我们需要有若干个消费者线程。消费者线程要争夺缓冲区对象锁，如果未得到锁则wait()进行阻塞等待被唤醒。如果得到了对象锁，还要判断缓冲区里的元素是否满足自己的需要。如果缓冲区里的元素不够自己消费，则要wait()进入阻塞等待被唤醒，并释放缓冲区对象锁。如果缓冲区里的元素满足自己的需要，则进行消费操作，结束后释放缓冲区对象锁，并唤醒一个阻塞的线程。
代码实现 基于上面的设计，我们需要实现共享缓冲区，生产者线程，消费者线程和主程序四部分。
共享缓冲区
package com.nituchao.jvm.prosumer.objectsync; import java.util.Date; import java.util.LinkedList; /** * 共享缓冲区 * Created by liang on 2016/12/15. */ public class Buffer { private static final int MAX_SIZE = 100; private LinkedList&amp;lt;String&amp;gt; list; public Buffer(LinkedList&amp;lt;String&amp;gt; list) { this.list = list; } /** * 生产n个产品 * * @param num * @throws InterruptedException */ public void BufferProduce(int num) throws InterruptedException { synchronized (list) { while (list.</description>
    </item>
    
    <item>
      <title>Java通过Exchange机制实现生产者消费者</title>
      <link>http://nituchao.com/post/2016/java-exchange-shi-xian-sheng-chan-zhe-xiao-fei-zhe/</link>
      <pubDate>Sat, 26 Nov 2016 22:17:12 +0800</pubDate>
      
      <guid>http://nituchao.com/post/2016/java-exchange-shi-xian-sheng-chan-zhe-xiao-fei-zhe/</guid>
      <description>Java并发API提供了一个同步辅助类&amp;mdash;Exchanger，它允许并发线程之间交换数据。具体来说，Exchanger类允许在两个线程之间定义同步点(Synchronization Point)。当两个线程都达到同步点时，它们交换数据结构，因此第一个线程的数据结构进入到第二个线程中，同时第二个线程的数据结构进入到第一个线程。
生产者VS消费者模型本质上就是两个线程交换数据。因此，对于只有一个生产者和一个消费者的场景，就可以使用Exchanger类。
设计思想 为了通过Exchanger类实现生产者VS消费者模型，我们在设计的时候需要考虑以下三点：
1, 生产者线程和消费者线程需要各自持有一个自己的缓冲区对象。
2, 生产者线程和消费者线程需要持有一个共同的Exchanger对象，通过该对象实现两个线程的同步和数据结构交换。
3, 消费者每次交换前，需要清空自己的数据结构，因为消费者不需要给生产者传递数据。
代码实现 基于上面的设计，分别实现了生产者线程，消费者线程，主程序。
生产者线程
package com.nituchao.jvm.prosumer.exchanger; import java.util.List; import java.util.concurrent.Exchanger; /** * 生产者 * Created by liang on 2016/11/26. */ public class BufferProducer implements Runnable { private List&amp;lt;String&amp;gt; buffer; private final Exchanger&amp;lt;List&amp;lt;String&amp;gt;&amp;gt; exchanger; public BufferProducer(List&amp;lt;String&amp;gt; buffer, Exchanger&amp;lt;List&amp;lt;String&amp;gt;&amp;gt; exchanger) { this.buffer = buffer; this.exchanger = exchanger; } @Override public void run() { // 循环10次数据交换 int cycle = 1; for (int i = 0; i &amp;lt; 10; i++) { System.</description>
    </item>
    
  </channel>
</rss>