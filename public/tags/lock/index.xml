<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Lock on 泥土巢</title>
    <link>http://nituchao.com/tags/lock/</link>
    <description>Recent content in Lock on 泥土巢</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh-CN</language>
    <copyright>Copyright (c) 2017, nituchao | All rights reserved.</copyright>
    <lastBuildDate>Thu, 23 Feb 2017 18:39:27 +0800</lastBuildDate>
    
	<atom:link href="http://nituchao.com/tags/lock/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>Java锁之Unsafe类的理解</title>
      <link>http://nituchao.com/post/juc.lock/java-unsafe/</link>
      <pubDate>Thu, 23 Feb 2017 18:39:27 +0800</pubDate>
      
      <guid>http://nituchao.com/post/juc.lock/java-unsafe/</guid>
      <description>一言 sun.misc.Unsafe类是超越Java的存在，它违反了Java在内存管理上的设计初衷，却又是Java很多重要特性与功能得以实现的基础，它使Java的安全性受到威胁，却有使Java在很多方面的性能得到提升，它是魔鬼与天使的混合体。
概述 Java是一个安全的开发工具，它阻止开发人员犯很低级的错误，而大部分的错误都是基于内存管理的。Unsafe类突破了Java原生的内存管理体制，使用Unsafe类可以在系统内存的任意地址进行读写数据，而这些操作对于普通用户来说是非常危险的，Unsafe的操作粒度不是类，而是数据和地址。
从另一方讲，Java正被广泛应用于游戏服务器和高频率的交易应用。这些之所以能够实现主要归功于Java提供的这个非常便利的类sun.mics.Unsafe。Unsafe类为了速度，在Java严格的安全标准方法做了一些妥协。
Java在JUC包中提供了对sun.misc.Unsafe类的封装实现，这就是java.util.concurrent.LockSupport。
本文基于JDK1.7.0_67
 java version &amp;ldquo;1.7.067&amp;rdquo;
_Java&amp;trade; SE Runtime Environment (build 1.7.0_67-b01)
Java HotSpot&amp;trade; 64-Bit Server VM (build 24.65-b04, mixed mode)
 重要函数 sun.mics.Unsafe一共提供了106个函数，这些函数涵盖了以下五个方面的功能：
 对变量和数组内容的原子访问，自定义内存屏障 对序列化的支持 自定义内存管理/高效的内存布局 与原生代码和其他JVM进行互操作 对高级锁的支持  获取实例 sun.misc.Unsafe只有一个无参的私有构造函数，要想实例化sun.misc.Unsafe可以调用getUnsafe()方法。
@CallerSensitive public static Unsafe getUnsafe() { Class var0 = Reflection.getCallerClass(); if(var0.getClassLoader() != null) { throw new SecurityException(&amp;quot;Unsafe&amp;quot;); } else { return theUnsafe; } }  出于安全考虑，Unsafe类只能被系统类加载器实例化，否则会抛出SecurityException异常。普通用户如果想实例化sun.misc.Unsafe类的对象，需要通过类反射机制或者修改Java的安全策略。
内存操作 获取成员变量偏移量 // 返回对象中指定静态成员变量的内存偏移量(相对于类存储) public native long staticFieldOffset(Field f); // 返回对象中指定成员变量的内存偏移量(相对于对象实例) public native long objectFieldOffset(Field f); // 返回对象中指定成员变量 public native Object staticFieldBase(Field f);  sun.</description>
    </item>
    
    <item>
      <title>AtomicLong源码分析</title>
      <link>http://nituchao.com/post/juc.atomic/atomic-long/</link>
      <pubDate>Thu, 23 Feb 2017 18:30:28 +0800</pubDate>
      
      <guid>http://nituchao.com/post/juc.atomic/atomic-long/</guid>
      <description>概述 在原子变量相关类中，AtomicBoolean, AtomicInteger, AtomicLong三个类是对于基本数据类型的操作，其原理和用法类似，区别在于Boolean, Integer, Long分别是8位，32位，64位的类型，本文重点研究AtomicLong。
Boolean类型数据长度为8位，Integer类型数据是32位，在当前32位操作系统或者64位操作中都能够直接对其进行原子修改和读取。而Long类型数据是64位，在32位JVM上会当做两个分离的32位来进行操作，所以本身不具备原子性。
还好我们现在的JDK基本都已经更新到64位，对long型数据的直接修改不存在原子性问题，但是当出现运算操作(比如++, —等)时还是会出现性问题，AtomicLong的目的是实现Long类型数据的各种原子操作。
Java原子变量的实现依赖于sun.misc.Unsafe的CAS操作和volatile的内存可见性语义。
本文基于JDK1.7.0_67
 java version &amp;ldquo;1.7.067&amp;rdquo;
_Java&amp;trade; SE Runtime Environment (build 1.7.0_67-b01)
Java HotSpot&amp;trade; 64-Bit Server VM (build 24.65-b04, mixed mode)
 成员变量 // 成员变量unsafe是原子变量相关操作的基础 // 原子变量的修改操作最终有sun.misc.Unsafe类的CAS操作实现 private static final Unsafe unsafe = Unsafe.getUnsafe(); // 成员变量value的内存偏移值，在静态代码块中初始化 private static final long valueOffset; // 通过volatile关键字保证可见性，用于保存值 private volatile long value; // 记录当前虚拟机是否支持long的原子化操作，如果支持，可以使用CAS进行更新 // 这个问题主要是针对32位JVM对long的更新 static final boolean VM_SUPPORTS_LONG_CAS = VMSupportsCS8(); static { try { valueOffset = unsafe.</description>
    </item>
    
    <item>
      <title>AtomicLongArray源码分析</title>
      <link>http://nituchao.com/post/juc.atomic/atomic-long-array/</link>
      <pubDate>Thu, 23 Feb 2017 18:30:27 +0800</pubDate>
      
      <guid>http://nituchao.com/post/juc.atomic/atomic-long-array/</guid>
      <description>概述 在原子变量相关类中，AtomicIntegerArray, AtomicLongArray, AtomicReferenceArray三个类是对数组类型的原子类操作，其原理和用法类似，本文重点研究AtomicLongArray。
Java原子变量的实现依赖于sun.misc.Unsafe的CAS操作和volatile的内存可见性语义。
本文基于JDK1.7.0_67
 java version &amp;ldquo;1.7.067&amp;rdquo;
_Java&amp;trade; SE Runtime Environment (build 1.7.0_67-b01)
Java HotSpot&amp;trade; 64-Bit Server VM (build 24.65-b04, mixed mode)
 成员变量 // 成员变量unsafe是原子变量相关操作的基础 // 原子变量的修改操作最终有sun.misc.Unsafe类的CAS操作实现 private static final Unsafe unsafe = Unsafe.getUnsafe(); // arrayBaseOffset获取数组首个元素地址偏移 private static final int base = unsafe.arrayBaseOffset(long[].class); // shift就是数组元素的偏移量 private static final int shift; // 保存数据的数组，在构造函数中初始化 private final long[] array; static { // scale数组元素的增量偏移 int scale = unsafe.arrayIndexScale(long[].class); // 用二进制&amp;amp;操作判断是否是2的倍数，很精彩 // 对于int型数组，scale是4 // 对于lang型数组，scale是8 // 对于Reference型数组，scale是4 if ((scale &amp;amp; (scale - 1)) !</description>
    </item>
    
    <item>
      <title>Java锁之自旋锁的原理</title>
      <link>http://nituchao.com/post/juc.lock/clh-spin-ticket-mcs-lock/</link>
      <pubDate>Thu, 23 Feb 2017 18:29:27 +0800</pubDate>
      
      <guid>http://nituchao.com/post/juc.lock/clh-spin-ticket-mcs-lock/</guid>
      <description>概述 锁作为数据同步工具，Java提供了两种实现：synchronized和AQS，这两种锁的实现根本不同，但是在加锁和解锁的过程中，也有很多共同点。它们在进行加锁/解锁时或多或少的用到自旋锁的设计思想。对于这几种自旋锁设计思想的研究，可以帮助我们更好的理解Java的Lock框架。
SPIN锁 Spin锁即自旋锁。自旋锁是采用让当前线程不停地在循环体内检测并设置临界资源的状态，直到状态满足条件并设置为指定的新状态。检测并设置临界资源操作必须是原子的，这样即使多个线程在给定时间自旋，也只有一个线程可获得该锁。
自旋锁的优点之一是自旋的线程不会被阻塞，一直处于活跃状态，对于锁保护的临界区较小的情况下，自旋获取锁和释放锁的成本都比较低，时间比较短。
Java中的自旋锁 在JAVA中，我们可以使用原子变量和Unsafe类的CAS操作来实现自旋锁：
public class SpinLock { private AtomicReference&amp;lt;Thread&amp;gt; atomic = new AtomicReference&amp;lt;Thread&amp;gt;(); public void lock() { Thread currentThread = Thread.currentThread(); // 如果锁未被占用，则设置当前线程为锁的拥有者。 while(!atomic.compareAndSet(null, currentThread)) {} } public void unlock() { Thread currentThread = Thread.currentThread(); // 只有锁的拥有者能释放锁 atomic.compareAndSet(currentThread, null); } }  缺点  CAS操作需要硬件的配合；
 保证各个CPU的缓存（L1、L2、L3、跨CPU Socket、主存）的数据一致性，通讯开销很大，在多处理器系统上更严重；
 没法保证公平性，不保证等待进程/线程按照FIFO顺序获得锁。
  ​
Linux中的自旋锁 自旋锁在Linux内核中广泛使用。在Linux操作系统中，自旋锁是一个互斥设备，它只有两个值锁定和解锁。
由于操作系统和CPU直接打交道，自旋锁又可分为在单核处理器上和多核处理器上。
单核处理器 用在单核处理器上，有可分为两种：
 系统不支持内核抢占  此时自旋锁什么也不做，确实也不需要做什么，因为单核处理器只有一个线程在执行，又不支持内核抢占，因此资源不可能会被其他的线程访问到。
 系统支持内核抢占  这种情况下，自旋锁加锁仅仅是禁止了内核抢占，解锁则是启用了内核抢占。</description>
    </item>
    
    <item>
      <title>Java锁之Lock框架概述</title>
      <link>http://nituchao.com/post/juc.lock/lock-summary/</link>
      <pubDate>Thu, 23 Feb 2017 18:28:27 +0800</pubDate>
      
      <guid>http://nituchao.com/post/juc.lock/lock-summary/</guid>
      <description> 在Java中关于锁有两个体系，一个是synchronized代表的对象监视器同步锁，一个是以AQS为基础的锁框架，该框架位于java.uti.concurrent包下。
本文基于JDK1.7.0_67
 java version &amp;ldquo;1.7.067&amp;rdquo;
_Java&amp;trade; SE Runtime Environment (build 1.7.0_67-b01)
Java HotSpot&amp;trade; 64-Bit Server VM (build 24.65-b04, mixed mode)
 AQS框架原理 JUC包中的锁 相比同步锁，JUC包中的锁的功能更加强大，它为锁提供了一个框架，该框架允许更灵活地使用锁，只是它的用法更难罢了。
JUC包中的锁，包括：
 Lock接口 ReadWriteLock接口 Condition接口 ReentrantLock独占锁 ReentrantReadWriteLock读写锁 CountDownLatch CyclicBarrier Semaphore AbstractOwnableSynchronizer抽象类 AbstractQueuedSynchronizer抽象类 AbstractQueuedLongSynchronizer抽象类  </description>
    </item>
    
  </channel>
</rss>