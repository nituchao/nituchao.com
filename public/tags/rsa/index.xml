<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Rsa on 泥土巢</title>
    <link>http://nituchao.com/tags/rsa/</link>
    <description>Recent content in Rsa on 泥土巢</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh-CN</language>
    <copyright>Copyright (c) 2017, nituchao | All rights reserved.</copyright>
    <lastBuildDate>Sat, 12 Jul 2014 19:19:00 +0800</lastBuildDate>
    
	<atom:link href="http://nituchao.com/tags/rsa/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>服务器端与客户端加密通信设计</title>
      <link>http://nituchao.com/post/2014/fu-wu-duan-yu-ke-hu-duan-jia-mi-tong-xin-she-ji/</link>
      <pubDate>Sat, 12 Jul 2014 19:19:00 +0800</pubDate>
      
      <guid>http://nituchao.com/post/2014/fu-wu-duan-yu-ke-hu-duan-jia-mi-tong-xin-she-ji/</guid>
      <description>最近的一个项目涉及到服务器与Android客户端交换一些敏感数据，这部分数据必须要经过安全加密后才能在Android与服务器间传递，然后再解密后进行相关的业务操作，而且要做到，即使客户端被恶意反编译，已经发送的数据也不会被破解。
我们首先想到的是对称加密算法AES和DES,但是，如果客户端被恶意反编译，客户端写死的密钥就会被拿到，已经发送的数据就很容易被破解了，因此，安全上，对称加密不满足我们的需求。
我们很快想到了非对称加密算法RSA，即使黑客拿到了客户端的公钥，没有私钥还是无法破解已经发送的数据包，但是，RSA算法速度非常慢，而且一次最多加密128位的数据，虽然安全上满足需求，速度和操作复杂度上还是存在一些硬伤。
于是，我们的解决办法是联合使用RSA和AES算法，具体的做法是，客户端提交的正文内容使用AES加密，AES加密时的密钥由客户端随机生成，然后把随机生成的密钥使用RSA算法加密后与正文内容加密后的密文一起提交给服务器端，服务器端先用自己的RSA私钥解密AES算法的密钥，然后用AES算法配合解密出的密钥解密正文内容。
交互过程 客户端提交内容如下:
 { msgkey: &amp;quot;f7l1mKVA3TVUf9F/lUIM30bzHG+PxXEOoO3vZ0N8ulsyPu8IaO/wmKAlOqUyIHwLtQnCOU2&amp;quot;, msgtxt: &amp;quot;MuoJ+HrOJzneiFwvBcOV8loBhRS0LjbmRyWkvSs0C2w=&amp;quot; }  其中：
 msgtxt是客户端提交的正文内容经过AES算法加密后的密文，AES加密时的密钥key由客户端随机生成。 msgkey是AES算法加密时用到的密钥key经过客户端RSA算法加密后的密文，RSA加密时的公钥由服务器端提供并固定内置的客户端。  以下是交互图:
RSA工具类 以下是我们用到的RSA加密/解密算法，该算法服务器端和客户端必须同时使用:
package com.xiaomi.miui.sec.common; import java.io.FileInputStream; import java.io.FileOutputStream; import java.io.ObjectInputStream; import java.io.ObjectOutputStream; import java.math.BigInteger; import java.security.KeyFactory; import java.security.KeyPair; import java.security.KeyPairGenerator; import java.security.NoSuchAlgorithmException; import java.security.interfaces.RSAPrivateKey; import java.security.interfaces.RSAPublicKey; import java.security.spec.RSAPrivateKeySpec; import java.security.spec.RSAPublicKeySpec; import java.util.HashMap; import javax.crypto.Cipher; /** * RSA工具类 * Created by liang on 7/9/14. */ public class RSAUtils { /** * 生成公钥和私钥 * * @throws NoSuchAlgorithmException */ public static HashMap&amp;lt;String, Object&amp;gt; getKeys() throws NoSuchAlgorithmException { HashMap&amp;lt;String, Object&amp;gt; map = new HashMap&amp;lt;String, Object&amp;gt;(); KeyPairGenerator keyPairGen = KeyPairGenerator.</description>
    </item>
    
  </channel>
</rss>