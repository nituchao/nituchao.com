<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Queue on 泥土巢</title>
    <link>http://nituchao.com/tags/queue/</link>
    <description>Recent content in Queue on 泥土巢</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh-CN</language>
    <copyright>Copyright (c) 2017, nituchao | All rights reserved.</copyright>
    <lastBuildDate>Tue, 27 Dec 2016 16:12:12 +0800</lastBuildDate>
    
	<atom:link href="http://nituchao.com/tags/queue/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>Java通过重入锁实现生产者消费者</title>
      <link>http://nituchao.com/post/2016/java-chong-ru-suo-shi-xian-sheng-chan-zhe-xiao-fei-zhe/</link>
      <pubDate>Tue, 27 Dec 2016 16:12:12 +0800</pubDate>
      
      <guid>http://nituchao.com/post/2016/java-chong-ru-suo-shi-xian-sheng-chan-zhe-xiao-fei-zhe/</guid>
      <description>ReentrantLock是一个可重入的互斥锁，又被称为&amp;rdquo;独占锁&amp;rdquo;，ReentrantLock锁在同一个时间点只能被一个线程锁持有，而可重入的意思是，ReentrantLock可以被单个线程多次获取，ReentrantLock的性能并不高，优点是比价灵活。ReentrantLock比Synchronized关键词更加灵活，并且能支持条件变量，后面我还会单独介绍使用条件变量实现生产者消费者模型的方法。
设计思想 本文希望同ReentrantLock来实现一个共享缓冲区，生产者线程和消费者线程通过该共享缓冲区来实现相关的生产和消费操作，每个线程对共享缓冲区的访问是互斥的。
另外，由于共享缓冲区是有空间限制的，生产者在生产前要判断共享缓冲区空间是否充足。消费者在消费前要判断共享缓冲区内的元素是否足够消费。
代码实现 根据上面的设计思想，我们需要实现共享缓冲区，生产者线程，消费者线程，主程序等四个部分。
共享缓冲区
package com.nituchao.jvm.prosumer.reentrant; import java.util.ArrayList; import java.util.List; import java.util.concurrent.locks.Lock; import java.util.concurrent.locks.ReentrantLock; /** * 共享缓冲区 * Created by liang on 2016/12/30. */ public class Buffer { private final List&amp;lt;String&amp;gt; list; private int MAX_SIZE = 10; private final Lock lock; public Buffer() { this.list = new ArrayList&amp;lt;String&amp;gt;(); this.lock = new ReentrantLock(); } /** * 生产num个元素 * * @param num * @return */ public boolean bufferProduct(int num) { boolean result = true; try { lock.</description>
    </item>
    
  </channel>
</rss>