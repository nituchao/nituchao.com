<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Atomic on 泥土巢</title>
    <link>http://nituchao.com/tags/atomic/</link>
    <description>Recent content in Atomic on 泥土巢</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh-CN</language>
    <copyright>Copyright (c) 2017, nituchao | All rights reserved.</copyright>
    <lastBuildDate>Thu, 23 Feb 2017 18:39:27 +0800</lastBuildDate>
    
	<atom:link href="http://nituchao.com/tags/atomic/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>Atomic变量</title>
      <link>http://nituchao.com/post/juc.atomic/atomic-summary/</link>
      <pubDate>Thu, 23 Feb 2017 18:39:27 +0800</pubDate>
      
      <guid>http://nituchao.com/post/juc.atomic/atomic-summary/</guid>
      <description>Java原子变量的诞生源自一个简单的需求 —— 多个线程共享某个变量或者对象时，需要对修改和读取操作进行同步。
同步包含两层含义：
 互斥访问 可见性  通常，多线程对临界资源的互斥访问通过对象锁(synchronized关键字)保证。对象锁是一种独占锁（悲观锁），会导致其它所有需要锁的线程挂起。而可见性则由volatile的内存语义保证。
Java 1.5开始提供了原子变量和原子引用，这些类放置在java.util.concurrent下。大概可以归为4类：
 基本类型：AtomicInteger, AtomicLong, AtomicBoolean; 数组类型：AtomicIntegerArray, AtomicLongArray, AtomicReferenceArray; 引用类型：AtomicReference, AtomicStampedReference, AtomicMarkableReference; 对象的属性修改类型：AtomicIntegerFieldUpdater, AtomicLongFieldUpdater, AtomicReferenceFieldUpdater;  Java原子变量的存在是为了对相应的数据进行原子操作。
所谓的原子操作包含下面几层含义：
 操作过程不会被中断。 操作过程不会被阻塞。 修改结果被其他线程可见。  </description>
    </item>
    
    <item>
      <title>AtomicReference源码分析</title>
      <link>http://nituchao.com/post/juc.atomic/atomic-reference/</link>
      <pubDate>Thu, 23 Feb 2017 18:30:27 +0800</pubDate>
      
      <guid>http://nituchao.com/post/juc.atomic/atomic-reference/</guid>
      <description>概述 在原子变量相关类中，AtomicReference, AtomicStampedReference, AtomicMarkableReference三个类是对于引用类型的操作，其原理和用法类似。
AtomicStampedReference是带了整型版本号(int stamp)的引用型原子变量，每次执行CAS操作时需要对比版本，如果版本满足要求，则操作成功，否则操作失败，用于防止CAS操作的ABA问题。
AtomicMarkableReference则是带了布尔型标记位(Boolean mark)的引用型原子量，每次执行CAS操作是需要对比该标记位，如果标记满足要求，则操作成功，否则操作失败。
Java原子变量的实现依赖于sun.misc.Unsafe的CAS操作和volatile的内存可见性语义。
本文基于JDK1.7.0_67
 java version &amp;ldquo;1.7.067&amp;rdquo;
_Java&amp;trade; SE Runtime Environment (build 1.7.0_67-b01)
Java HotSpot&amp;trade; 64-Bit Server VM (build 24.65-b04, mixed mode)
 成员变量 AtomicReference通过泛型T来声明成员值的类型，表示这是对引用类型的操作。
// 成员变量unsafe是原子变量相关操作的基础 // 原子变量的修改操作最终有sun.misc.Unsafe类的CAS操作实现 private static final Unsafe unsafe = Unsafe.getUnsafe(); // 成员变量value的内存偏移值，在静态代码块中初始化 private static final long valueOffset; // 通过volatile关键字保证可见性，用于保存值 private volatile V value; static { try { valueOffset = unsafe.objectFieldOffset (AtomicReference.class.getDeclaredField(&amp;quot;value&amp;quot;)); } catch (Exception ex) { throw new Error(ex); } }  函数列表 // 构造函数，初始化值为null public AtomicReference() // 构造函数，指定初始化值 public AtomicReference(V initialValue) // 以原子方式获取当前值 public final V get() // 以原子方式设置当前值为新的值newValue public final void set(V newValue) // 以原子方式设置当前值为新的值newValue // 优先保证修改操作，而不保证volatile的可见性语义 // 效率较高 public final void lazySet(V newValue) // 以原子方式设置当前值为update // 如果当前值等于except，则设置成功，返回true // 如果当前值不等于except，则设置失败，返回fase // 该过程不阻塞 public final boolean compareAndSet(V expect, V update) // 以原子方式设置当前值为update // 如果当前值等于except，则设置成功，返回true // 如果当前值不等于except，则设置失败，返回fase // 该过程不阻塞 // 该过程不保证volatile成员的happens-before语义顺序 public final boolean weakCompareAndSet(V expect, V update) // 以原子方式设置当前值为update // 返回更新前的值 public final V getAndSet(V newValue) // 返回当前值的string表达式 public String toString()  重点函数分析 set(V newValue) 以原子方式设置当前值为newValue，因为set方法只是一个单操作的赋值语句，因此是原子的。加上volatile的内存可见性保证，Set是原子操作无疑。</description>
    </item>
    
    <item>
      <title>AtomicStampedReference源码分析</title>
      <link>http://nituchao.com/post/juc.atomic/atomic-stamped-reference/</link>
      <pubDate>Thu, 23 Feb 2017 18:30:27 +0800</pubDate>
      
      <guid>http://nituchao.com/post/juc.atomic/atomic-stamped-reference/</guid>
      <description>概述 在原子变量相关类中，AtomicReference, AtomicStampedReference, AtomicMarkableReference三个类是对于引用类型的操作，其原理和用法类似。
AtomicStampedReference是带了整型版本号(int stamp)的引用型原子变量，每次执行CAS操作时需要对比版本，如果版本满足要求，则操作成功，否则操作失败，用于防止CAS操作的ABA问题。本文重点分析AtomicStampedReference。
AtomicMarkableReference则是带了布尔型标记位(Boolean mark)的引用型原子量，每次执行CAS操作是需要对比该标记位，如果标记满足要求，则操作成功，否则操作失败。
Java原子变量的实现依赖于sun.misc.Unsafe的CAS操作和volatile的内存可见性语义。
本文基于JDK1.7.0_67
 java version &amp;ldquo;1.7.067&amp;rdquo;
_Java&amp;trade; SE Runtime Environment (build 1.7.0_67-b01)
Java HotSpot&amp;trade; 64-Bit Server VM (build 24.65-b04, mixed mode)
 内部类 AtomicStampedReference是带整形版本号的原子引用类型，为了同时兼顾引用值和版本号，它定义了一个静态内部类Pair，AtomicStampedReference的相关操作都是对Pair内成员的操作。
private static class Pair&amp;lt;T&amp;gt; { final T reference; final int stamp; private Pair(T reference, int stamp) { this.reference = reference; this.stamp = stamp; } static &amp;lt;T&amp;gt; Pair&amp;lt;T&amp;gt; of(T reference, int stamp) { return new Pair&amp;lt;T&amp;gt;(reference, stamp); } }  成员变量 AtomicStampedReference除了常规的sun.</description>
    </item>
    
    <item>
      <title>AtomicMarkableReference源码分析</title>
      <link>http://nituchao.com/post/juc.atomic/atomic-markable-reference/</link>
      <pubDate>Thu, 23 Feb 2017 18:30:25 +0800</pubDate>
      
      <guid>http://nituchao.com/post/juc.atomic/atomic-markable-reference/</guid>
      <description>概述 在原子变量相关类中，AtomicReference, AtomicStampedReference, AtomicMarkableReference三个类是对于引用类型的操作，其原理和用法类似。
AtomicStampedReference是带了整型标记值(int stamp)的引用型原子变量，每次执行CAS操作时需要对比版本，如果版本满足要求，则操作成功，否则操作失败，用于防止CAS操作的ABA问题。
AtomicMarkableReference则是带了布尔型标记位(Boolean mark)的引用型原子量，每次执行CAS操作是需要对比该标记位，如果标记满足要求，则操作成功，否则操作失败。本文重点分析AtomicMarkableReference。
Java原子变量的实现依赖于sun.misc.Unsafe的CAS操作和volatile的内存可见性语义。
本文基于JDK1.7.0_67
 java version &amp;ldquo;1.7.0_67&amp;rdquo;
_Java&amp;trade; SE Runtime Environment (build 1.7.0_67-b01)
Java HotSpot&amp;trade; 64-Bit Server VM (build 24.65-b04, mixed mode)
 内部类 AtomicMarkableReference是带布尔型标记为的原子引用类型，为了同时兼顾引用值和标记位，它定义了一个静态内部类Pair，AtomicMarkableReference的相关操作都是对Pair内成员的操作。
private static class Pair&amp;lt;T&amp;gt; { final T reference; final boolean mark; private Pair(T reference, boolean mark) { this.reference = reference; this.mark = mark; } static &amp;lt;T&amp;gt; Pair&amp;lt;T&amp;gt; of(T reference, int mark) { return new Pair&amp;lt;T&amp;gt;(reference, mark); } }  成员变量 AtomicMarkableReference除了常规的sun.</description>
    </item>
    
    <item>
      <title>AtomicLongFieldUpdater源码分析</title>
      <link>http://nituchao.com/post/juc.atomic/atomic-long-field-updater/</link>
      <pubDate>Thu, 23 Feb 2017 18:27:27 +0800</pubDate>
      
      <guid>http://nituchao.com/post/juc.atomic/atomic-long-field-updater/</guid>
      <description>概述 在原子变量相关类中，AtomicIntegerFieldUpdater, AtomicLongFieldUpdater, AtomicReferenceFieldUpdater三个类是用于原子地修改对象的成员属性，它们的原理和用法类似，区别在于对Integer，Long，Reference类型的成员属性进行修改。本文重点研究AtomicLongFieldUpdater。
AtomicLongFieldUpdater的设计非常有意思。AtomicLongFieldUpdater本身是一个抽象类，只有一个受保护的构造函数，它本身不能被实例化。
AtomicLongFieldUpdater有两个私有的静态内部类CASUpdater和LockedUpdater，它们都是AtomicLongFieldUpdater的子类。
用户使用AtomicLongFieldUpdater的静态方法newUpdater实例化AtomicLongFieldUpdater子类对象，本质是上是根据条件实例化了子类CASUpdater或者LockedUpdater，然后通过子类来完成具体的工作。CASUpdater和LockedUpdater值的读取和更新最后都是使用sun.misc.Unsafe类的相关操作。
CASUpdater使用下面的方法：
public native Object getLongVolatile(Object o, long offset); public native void putLongVolatile(Object o, long offset, long x);  LockedUpdater使用下面的方法：
public native long getLong(Object o, long offset); public native void putLong(Object o, long offset, long x);  为了防止操作过程中的指令重排，LockedUpdater使用synchronized进行同步。
本文基于JDK1.7.0_67
 java version &amp;ldquo;1.7.0_67&amp;rdquo;
_Java™ SE Runtime Environment (build 1.7.0_67-b01)
Java HotSpot™ 64-Bit Server VM (build 24.65-b04, mixed mode)
 内部类 AtomicLongFieldUpdater本身是抽象类，通过两个私有的静态内部子类来完成具体的工作。
 CASUpdater：顾名思义，使用CAS操作对象的成员变量。 LockedUpdater：顾名思义，在更新和读取对象的成员变量时，使用对象锁来保证同步。  成员变量 AtomicLongFieldUpdater是个抽象类，具体的业务逻辑都是交给它的子类实现的，它本身没有包含任何成员变量。</description>
    </item>
    
    <item>
      <title>AtomicIntegerFieldUpdater源码分析</title>
      <link>http://nituchao.com/post/juc.atomic/atomic-integer-field-updater/</link>
      <pubDate>Thu, 23 Feb 2017 18:27:25 +0800</pubDate>
      
      <guid>http://nituchao.com/post/juc.atomic/atomic-integer-field-updater/</guid>
      <description>概述 在原子变量相关类中，AtomicIntegerFieldUpdater, AtomicLongFieldUpdater, AtomicReferenceFieldUpdater三个类是用于原子地修改对象的成员属性，它们的原理和用法类似，区别在于对Integer，Long，Reference类型的成员属性进行修改。本文重点研究AtomicIntegerFieldUpdater。
AtomicIntegerFieldUpdater的设计非常有意思。AtomicIntegerFieldUpdater本身是一个抽象类，只有一个受保护的构造函数，它本身不能被实例化。在AtomicIntegerFieldUpdater中定义了一些基本的模板方法，然后通过一个静态内部子类AtomicIntegerFieldUpdaterImpl来实现具体的操作。AtomicIntegerFieldUpdaterImpl中的相关操作也都是基于Unsafe类来实现的。
本文基于JDK1.7.0_67
 java version &amp;ldquo;1.7.0_67&amp;rdquo;
_Java™ SE Runtime Environment (build 1.7.0_67-b01)
Java HotSpot™ 64-Bit Server VM (build 24.65-b04, mixed mode)
 内部类 AtomicIntegerFieldUpdater本身是一个抽象类，通过一个静态内部子类来实现相关的操作。
private static class AtomicIntegerFieldUpdaterImpl&amp;lt;T&amp;gt; extends AtomicIntegerFieldUpdater&amp;lt;T&amp;gt;  成员变量 AtomicIntegerFieldUpdater是个抽象类，具体的业务逻辑都是交给它的子类实现的，它本身没有包含任何成员变量。
函数列表 // 受保护的无操作构造函数，供子类使用 protected AtomicIntegerFieldUpdater() // 为对象创建并返回一个具有给定字段的更新器。 public static &amp;lt;U&amp;gt; AtomicIntegerFieldUpdater&amp;lt;U&amp;gt; newUpdater(Class&amp;lt;U&amp;gt; tclass, String fieldName) // 以原子方式设置当前值为update // 如果当前值等于expect，并设置成功，返回true // 如果当前值不等于expect，则设置失败，返回false // 该过程通过CAS实现，不阻塞 public abstract boolean compareAndSet(T obj, int expect, int update) // 以原子方式设置当前值为update // 如果当前值等于expect，并设置成功，返回true // 如果当前值不等于expect，则设置失败，返回false // 该过程通过CAS实现，不阻塞 // 该过程不保证volatile成员的happens-before语义顺序 public abstract boolean weakCompareAndSet(T obj, int expect, int update) // 以原子方式设置当前值为newValue // 使用Unsafe类的putIntVolatile进行操作，具有原子性 public abstract void set(T obj, int newValue) // 以原子方式设置当前值为newValue // 使用Unsafe类的putOrderedInt进行操作，所以本身具有原子性 public abstract void lazySet(T obj, int newValue) // 以原子方式获取当前值 // 使用Unsafe类的getIntVolatile进行操作，所以本身具有原子性 public abstract int get(T obj) // 以原子方式设置当前值为newValue，并返回更新前的值 // 使用Unsafe类的compareAndSwapInt进行操作，所以本身具有原子性 // 操作过程中使用自旋方式，直到操作成功 public int getAndSet(T obj, int newValue) // 以原子方式将当前值加1，并返回更新前的值 // 使用Unsafe类的compareAndSwapInt进行操作，所以本身具有原子性 // 操作过程中使用自旋方式，直到操作成功 public int getAndIncrement(T obj) // 以原子方式将当前值减1，并返回更新前的值 // 使用Unsafe类的compareAndSwapInt进行操作，所以本身具有原子性 // 操作过程中使用自旋方式，直到操作成功 public int getAndDecrement(T obj) // 以原子方式将当前值加上给定值delta，并返回更新前的值 // 使用Unsafe类的compareAndSwapInt进行操作，所以本身具有原子性 // 操作过程中使用自旋方式，直到操作成功 public int getAndAdd(T obj, int delta) // 以原子方式将当前值加1，并返回更新后的值 // 使用Unsafe类的compareAndSwapInt进行操作，所以本身具有原子性 // 操作过程中使用自旋方式，直到操作成功 public int incrementAndGet(T obj) // 以原子方式将当前值减1，并返回更新前的值 // 使用Unsafe类的compareAndSwapInt进行操作，所以本身具有原子性 // 操作过程中使用自旋方式，直到操作成功 public int decrementAndGet(T obj) // 以原子方式将当前值加上给定值delta，并返回更新后的值 // 使用Unsafe类的compareAndSwapInt进行操作，所以本身具有原子性 // 操作过程中使用自旋方式，直到操作成功 public int addAndGet(T obj, int delta)  重点函数分析 newUpdater 为对象创建并返回一个具有给定字段的更新器实例。在该方法中，直接构造一个AtomicIntegerFieldUpdaterImpl实例。</description>
    </item>
    
  </channel>
</rss>