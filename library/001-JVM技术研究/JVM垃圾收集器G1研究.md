---
"categories": ["Java"],
"tags": ["Java"],
"date": "2014-06-22T13:32:00+08:00",
"title": "JVM垃圾收集器概述"

---

### 概述

1999年，串行GC第一个被引入HotSpot的垃圾收集器，并作为JDK 1.3.1的组成部分。2002年，并行GC和并发标记清除GC（CMS）被引入JDK 1.4.2.这3种垃圾收集器基本覆盖了GC最重要的3中使用场景："内存占用空间以及并发开销最小化"、"应用吞吐量最大化"和"GC相关中断时间最小化"。2012年，G1垃圾收集器被引入JDK 7u4，G1是一种服务器端的垃圾收集器，应用在多处理器和大容量内存环境中，在实现高吞吐量的同时，尽可能的满足垃圾收集暂停时间的要求。2017年，JDK 9 GA版发布，G1是默认的垃圾回收器。

### 术语

要研究HotSpot的垃圾回收器，首先要搞清楚三个术语：并行、stop-the-world、并发。

`并行`的意思是，这是个多线程的垃圾收集算法。当一个垃圾收集事件活动被描述为并行，就意味着它正用多线程来执行。就HotSpot的垃圾收集器而言，几乎所有多线程GC操作都由Java VM（JVM）的内部线程处理。与此相比，一个很重要的例外就是G1垃圾收集器，在G1中某些后台的垃圾收集工作能够由应用线程来承担。

`stop-the-world`的意思是在一个垃圾收集事件中，所有的JAVA应用线程全部被暂停。一个stop-the-world垃圾收集器就意味着当它执行垃圾收集操作时会停掉所有Java应用线程。当一个垃圾收集阶段或事件被描述为stop-the-world，也就意味着在这个特定的垃圾收集阶段或事件中，所有Java应用线程都会被暂停。

`并发`的意思是在Java应用执行过程中垃圾收集活动也同时在进行。一个并发垃圾收集阶段或事件意味着这个垃圾收集阶段或事件可以和应用在同一时间执行。

一个垃圾收集器可以用以上3个术语中的任意一个或多个组合来描述。比如，一个并行并发收集器是多线程的（并行部分），同时还可以与应用同一时间执行（并发部分）。

### 串行垃圾收集器

串行垃圾收集器与并行垃圾收集器很相似，只是它是用一个单线程做所有工作。这种单线程的方式意味着垃圾收集器实现的复杂度更低，以及需要非常少的外部运行时数据结构，其内存占用空间大小（footpoint）也是所有HotSpot垃圾收集器里最低的。当然，串行垃圾收集器面对的挑战与并行收集器也非常类似，中断时间可能很长，同时随着堆的大小以及活跃数据的数量变化，中断时间会呈现线性增加或者减少。另外，串行垃圾收集器引发的长时间暂停会更加明显，因为所有垃圾收集工作都是在一个线程里完成的。

因为很少占用内存，在Java HotSpot客户端虚拟机中默认使用串行垃圾收集器，同时它还被用于大量嵌入式场景的需求。通过HotSpot命令行选项`-XX:+UseSerialGC`，明确指定了使用串行垃圾收集器来做垃圾收集。

![串行垃圾收集器](http://olno3yiqc.bkt.clouddn.com/serial_gc.png)

上图描述了Java应用线程（蓝色箭头）被暂停，同时1个GC线程（绿色箭头）接管过去做垃圾收集工作，这台机器上运行了8个Java应用线程。因为它是单线程的，所以相对于并行垃圾收集器来说，大部分情况下串行垃圾收集器执行一个垃圾收集事件需要花费更长时间，而并行垃圾收集器可以将回收工作分摊到多个线程上。

### 并行垃圾收集器

并行垃圾收集器是一种并行`stop-the-world`的收集器，也就是说没发生一次垃圾收集，它会停掉所有应用的线程并用多个线程执行垃圾回收工作。因此垃圾回收工作可以不受任何中断非常高效地完成。对相关的应用来说，这通常也是最小化垃圾收集开销时间的最好方式。然而在个别情况下，因垃圾回收而导致的应用中断也可能非常长。

在并行垃圾收集器中，年轻代和老年代的回收都是并行的，而且会`stop-the-world`。老年代的回收还会同时进行压缩动作。压缩可以将邻近的对象移动到一起，以消除它们之间被浪费的空间，形成一个最理想的堆布局。然而压缩可能会花费相当长的时间，这通常跟Java堆的大小以及老年代中存活对象的数量和大小有关。

在并行垃圾收集器被引入HotSpot的时候，只有年轻代会使用并行`stop-the-world`收集器。老年代的回收是使用一个单线程的`stop-the-world`收集器。我们回到最初并行垃圾收集器被引入的时候，激活并发垃圾收集器的HotSpot命令行选项是`-XX:+UseParallelGC`。

在并行垃圾收集器被引入时，主要是为了应对服务端要求吞吐量最优化的使用场景，因此并行垃圾收集器成为了HotSpot服务端虚拟机的缺省收集器。同时，绝大多数Java堆的尺寸已经趋向于512M~2G，这使得并行垃圾收集器的中断时间保持一个相对低的水平，哪怕是单线程的`stop-the-world`收集器。当时对延迟方面的需求比现今更加宽松。对于Web引用来说，忍受因垃圾收集器导致的额外1s的延迟是非常平常的事，很多的时候甚至会有3s~5s。

随着Java堆的尺寸以及老年代中存活对象的数量和大小的增长，老年代的垃圾收集时间越变越长。与此同时，硬件的发展进步使得我们有更多可用的硬件线程。于是，通过增加一个多线程的老年代收集器与多线程的年轻代收集器同时使用的方式，并行垃圾收集器得到了增强。这使并行垃圾收集器降低了收集和压缩堆的时间开销。

增强的并行垃圾收集器随着Java 6更新发布一同交付。它通过一个新的命令行选项`-XX:+UseParallelOldGc`来激活。当`-XX:+UseParallelOldGc`选项被激活后，并行的年轻代收集也被激活。这也是我们今天所认为的HotSpot中的并行垃圾收集器、一个多线程的`stop-the-world`年轻代收集器与一个多线程的`stop-the-world`老年代收集器的组合。

在`Java 7 update release 4`（通常被称为Java 7u4或者JDK 7u4）中，-XX:+UseParallelOldGC被作为缺省的垃圾收集器以及并行垃圾收集器的标准操作模式。从`Java 7u4`开始，指定`-XX:+UseParallelGC`也会激活`-XX:+UseParallelOldGC`，同样地，`-XX:+UseParallelOldGC`也会激活`-XX:+UseParallelGC`。

在以下场景中应该优先选择并行垃圾收集器：

1. 对应用吞吐量的要求远远高于对延迟的要求。

   批处理的引用就是一个很好的例子，因为它是非交互性质的。当你启动一个批量执行，你会希望它越快执行越好。

2. 如果能满足应用的最差延迟要求，并行垃圾收集器将提供最佳吞吐量。最差延迟要求包含2个方面：最差延迟时间和中断发生的频度。比如说：一个引用可能会有这样的延迟需求，"超过500ms的暂停每2小时不能多于1次，同时所有的暂停不能超过3s"。

   一个交互式应用拥有足够的小块活动数据，因此并行垃圾收集器的一个full GC事件就能满足甚至超额达成对应用垃圾收集导致的最差延迟要求，这就是此使用场景下的一个良好的例子。然而，活跃数据的数量与Java堆的大小有极高的相关性，所以符合这种情况的应用类型也是有限的。

对于能满足这些要求的应用来说，并行垃圾收集器可以工作的很好。但对于那些不满足要求的应用来说，暂停时间会变得很长，因为一次full GC必须标记整个Java堆空间，同时还要压缩老年代空间。导致的一个结果就是，随着Java堆空间的增大，暂停事件也会随之增加。

![并行垃圾收集器](http://olno3yiqc.bkt.clouddn.com/parallel_gc.png)

上图描述了Java应用线程（蓝色箭头）被暂停，同时GC线程（绿色箭头）接管过去做垃圾收集工作。在这张图里有8个并行GC线程和8个Java应用线程，然而在大多数应用里，应用线程的数量通常超过GC线程的数量，特别是遇到某些应用线程可能是闲置的情况。当一个垃圾收集活动开始，所有的应用线程都会被暂停，然后开始执行多个GC线程。

### 并发标记清楚（CMS）垃圾收集器

