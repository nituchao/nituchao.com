---
"categories": ["JMM"],
"tags": ["JMM", "JAVA"],
"date": "2014-06-22T13:32:00+08:00",
"title": "Java内存模型的若干问题"

---

本来是想自己总结一下JSR 133提出的新Java内存模型，后来发现了Jeremy Manson 和 Brian Goetz在2004年写的《JSR 133 (Java Memeory Model) FAQ》一文，全文以FAQ的形式，回答了为什么需要用JSR 133来实现Java新的内存模型，以及新的内存模型在内存可见性，语义重排序等几方面的改进。跟其他编程语言相比，Java从语言层面定义了自己的内存模型，而其他编程语言则需要依赖专门的线程库才能实现相关功能，不禁使我产生些许自豪感。另外，关于Java内存模型和并发编程的中文资料看了相当多，一个个有的把问题描述的很片面，有的把相关知识讲的非常复杂，有时候你甚至能感受到作者的恶意（故意把问题扩大化，复杂化），JM和BG的FAQ让我有种相见恨晚的感觉，作者高屋建瓴，全文言简意赅，观点针针见血，举例拳拳到肉，加上Doug Lea的《SR-133 cookbook》一文，都对我启发很大。看了本文是根据这篇FAQ做的总结。

###  导语

一说起多线程编程，脑子里首先闪过的概念一般是锁，同步，AQS等，这是不全面的。多线程编程产生的土壤上有两个元素：多处理器和多级缓存。为了应对这两个元素，多线程编程使用同步工具解决多处理器并发执行的问题，用内存模型解决多级缓存造成的共享变量可见性的问题。

在本文中，CPU指包含了多处理器和多级缓存的单元。

### 什么是内存模型

在多处理器系统中，每个处理器往往都有一级或多级的高速缓存，高速缓存一方面显著提高了处理器访问数据的速度，另一个方面也降低了内存数据在总线上的数据传输。高速缓存对处理器性能的提升非常显著，但也产生了大量的信息问题。比如，两个处理器同时访问（liang: 读取/修改）相同内存位置上的数据，需要有专门的机制来保证它们能看到相同的值。

在处理器层面，内存模型需要定义充分必要条件来保证：

* 其他处理器对共享变量值的修改要对当前处理器可见（liang: 其他处理器写入到内存包含写入到处理器本地缓存，并刷新到主内存。对当前处理器可见包括处理器本地缓存失效，并从主内存重新加载值）。
* 当前内存处理器对共享变量值的修改要对其他处理器可见。

有些CPU使用强一致性内存模型，所有的处理器可以同时看到给定主内存地址上的值。有些CPU则使用弱一致性内存模型，处理器通过添加了内存屏障(memory barriers)的特殊指令来保证相互之间对共享变量的可见性。在这种情况下，内存屏障能保证对共享变量的写入要立即刷新到主内存，对共享变量的读取要立即从主内存中加载(将高速缓存失效)。这些内存屏障通常在加锁(lock)和解锁(unlock)操作的过程中使用，他们在高级编程语言中对开发人员是透明的(invisible)。

在支持强一致性内存模型的CPU上编程往往比较简单，因为减少了内存屏障的使用。但是，在很多支持强一致性内存模型的CPU上，内存屏障依旧是很必要的。内存屏障的使用是违反人类直觉的，这经常给开发者带来很大困扰。在处理器设计上，目前越来越趋向于若一致性内存模型，因为它们在放松缓存一致性要求的同时，使得跨多个处理器和更大内存的可伸缩性更强。

共享变量可见的问题还要考虑指令的重排序。比如，编译器在不破坏代码语义的情况下，可以任意调整代码执行的顺序。

指令的重排序通常会发生在编译器，运行时，或者处理器等部分，对指令的重排序往往是为了提高运行效率。

分析下面的代码：

```java
Class Reordering {
  int x = 0, y = 0;
  public void writer() {
    x = 1; 			@1
    y = 2;			@2
  }

  public void reader() {
    int r1 = y; 	@3
    int r2 = x; 	@4
  }
}
```

现在有两个线程并发访问上面的代码，x和y都是普通变量。假设现在一个线程正在执行代码@3，并且读到r1=y的值为2，该线程继续往下执行代码@4，读到r2=x的值一定等于1吗？显然不是。由于指令重排序的存在，由于@1和@2之间没有关系，可以进行重排序，因此@2可能在@1之前执行，这种情况下，在执行@4时，读到r2=x的值为0(int型x的默认值)。

### 其它编程语言有内存模型吗？

大多数编程语言在设计时是不支持多线程编程的，比如C/C++。