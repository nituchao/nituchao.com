---
"categories": ["Java"],
"tags": ["Java"],
"date": "2017-08-19T17:32:00+08:00",
"title": "JVM内存概述"

---

对于Java程序员来说，JVM帮忙管理了每一个对象的内存使用，程序员不需要再花时间为每一个new操作配对一个delete或者free操作，这样子不会因为程序员们的误操作而出现内存泄漏等问题。看起来，JVM的内存管理很美好，但如果无法做到对JVM内存的使用情况做到了如指掌，心中有数的话，程序员将深陷各种奇怪的问题中，而且这些问题通常非常难排查。

## JVM内存分区
JVM在执行Java程序的过程中会将内存划分为若干个不同的数据区域，根据Java虚拟机规范，JVM所管理的内存区域分为以下几个运行时数据区域。

![JVM内存分区](http://olno3yiqc.bkt.clouddn.com/3994601-2c06cc8e2c862ea9.png)

## 程序计数器
程序计数器是一块较小的内存空间，它主要用来记录当前线程锁执行的下一条命令的指令地址。由于JVM的多线程是通过线程轮流切换分配处理器来执行的，所以在任意一个时刻，一个处理器只会执行一个线程中的一条指令，为了在切换线程之后能恢复到正确的执行位置，每一个线程都需要一个单独的程序计数器，它们独立存储，互不影响。

**备注**

1. 程序计数器是线程私有的内存区域。
2. 程序计数器是各个内存区域中，唯一不会产生OOM的区域。

## Java虚拟机栈
与程序计数器一样，Java虚拟机栈也是线程私有的，它与线程的生命周期相同。虚拟机栈描述的是Java方法执行的内存模型。在Java虚拟机规范中，对于这个区域规定了两种异常：
* StackOverflowError: 线程请求的栈深度大于JVM允许的深度，抛出该异常。
* OutOfMemoryError: 如果虚拟机栈可以动态扩展，当扩展时无法申请到足够的内存，抛出该异常。

**备注**

1. 每个方法被执行的时候，都有一个栈帧，用于存储局部变量表、操作栈、动态链接、方法出口等信息，每一个方法被执行的过程也就是栈帧的入栈栈过程。
2. JVM的指令执行是基于栈，而不是基于寄存器的。

## 本地方法栈
本地方法栈与虚拟机栈的作用是相似的，它们的区别在于本地方法栈为JVM使用到的Native方法服务。

**备注**
1. 在调用本地方法时，程序计数器里的值为空。
2. 本地方法栈也会抛出StackOverflowError和OutOfMemoryError错误。

## 堆
对于大多数的应用，堆是JVM管理的内存中最大的一块。堆被所有线程共享，在JVM启动时创建，它存在的目的就是存放对象实例，几乎所有的对象实例都在堆上进行分配。

堆是垃圾收集的主要区域，由于垃圾收集器基本都采用分代收集算法，所以堆还被细分为以下几个部分：
1. 新生代
包括Eden区、From Survivor区和To Survivor区。他们的比例为Eden:From Survivor:To Survivor=8:1:1。
2. 老年代
根据Java虚拟机规范，堆可以处于物理上不连续的内存空间中，只要逻辑上连续即可。当然，堆的大小也是可以调整的，可以通过虚拟机参数-Xmx和-Xms控制。同样，在该区域，如果没有内存分配给对象实例，并且堆也无法再扩展，会抛出OutOfMemoryError异常。

HotSpot虚拟机的最新垃圾收集器G1采用了新的分区模式，它将整个堆内存区打碎成一个个的Region，每个Region的大小一样，这些Region再构成新生代，老年代，和巨型分区。

## 方法区
方法区与堆一样，也是所有线程共享的内存区域，它主要用来存储已经被JVM加载的类信息、常量、静态变量等。许多熟悉GC的程序员们更喜欢把方法区称之为永久代，但是本质上它俩其实是不等价的，仅仅是因为HotSpot虚拟机的设计团队将GC分代收集扩展到了方法区。相对来说，垃圾收集行为在这个区域是比较少出现的，这个区域的垃圾收集目标主要是针对常量池的回收和类型的卸载。

### 运行时常量池
介绍方法区不得不说的就是运行时常量池，它是方法区的一部分。Class文件中除了有类、字段、方法、接口等描述信息外，还有一个信息是常量池，常量池主要用来存放编译期生成的各种字面量和符号引用，这部分的内容将在类加载后存放到运行时常量池中。

运行时常量池相比于Class文件常量池的一个重要特性就是具备动态性，Java并不要求常量一定只能在编译其产生，也可以在运行期间将新的常量放入常量池中，这种特性最明显的使用方法就是String.intern方法。

**备注**

JDK 8移除了永久代，引入MetaSpace，将大部分的类元数据直接存储在本地内存中。
